<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Logical thinking</title>
  
  <subtitle>Keep exploring</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://yuxuanliu.tech/"/>
  <updated>2020-08-14T16:14:04.255Z</updated>
  <id>https://yuxuanliu.tech/</id>
  
  <author>
    <name>Yuxuan Liu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>CFA Alternative Investment Notes</title>
    <link href="https://yuxuanliu.tech/CFA_Alternative_investment/"/>
    <id>https://yuxuanliu.tech/CFA_Alternative_investment/</id>
    <published>2020-08-14T23:11:54.000Z</published>
    <updated>2020-08-14T16:14:04.255Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CFA-Alternative-investment-Notes"><a href="#CFA-Alternative-investment-Notes" class="headerlink" title="CFA Alternative investment Notes"></a>CFA Alternative investment Notes</h1><h2 id="Introduction-to-Alternative-Investment"><a href="#Introduction-to-Alternative-Investment" class="headerlink" title="Introduction to Alternative Investment"></a>Introduction to Alternative Investment</h2><ol><li><p>Traditional and alternative investment comparisons:</p><table><thead><tr><th></th><th>Investment underlying</th><th>Position</th></tr></thead><tbody><tr><td>Traditional</td><td>Public stock, bond, cash only</td><td>Long position only</td></tr><tr><td>Alternative</td><td>Public stock, bond, cash, private stock, real estate, commodities, infrastructure, collectibles, patents etc.</td><td>Long position, short position and leveraged position</td></tr></tbody></table></li></ol><ol start="2"><li><p>Characteristics of alternative investments:</p><ul><li>Illiquidity of underlying assets(difficult or take longer to change asset into cash)</li><li>Narrow manager specialization(通常需要由专业PM进行)</li><li>Low correlation with traditional investments(hedge risk and diversification)</li><li>Less regulation and less transparency</li><li>Limited and problematic historical data and risk(due to less transparency)</li><li>Unique legal and tax consideration</li></ul><a id="more"></a></li><li><p>Categories of alternative investments:</p><ul><li>Investment vehicle: help customers to invest<ul><li>Hedge funds</li><li>Private equity</li></ul></li><li>Investment underlying:<ul><li>Real estate(不动产)</li><li>Commodity(大宗商品)</li><li>Infrastructure(基建投资)</li><li>Short or leverage position of traditional investment underlying</li></ul></li></ul></li><li><p>Alternative investment strategy:</p><ul><li>Absolute return:<ul><li>Seek to generate returns independent of market returns($\beta$=0)</li><li>No market index specified to beat(No benchmark)</li><li>Performance object is set relatively to cash rate and inflation</li></ul></li><li>Market segmentation:<ul><li>There are many regulatory restriction on traditional investment such as limitation on the use of derivatives and investing foreign securities.</li><li>These restriction leave <strong>market vacancy</strong> to alternative investment companies to use active investment to generate high $\alpha$</li></ul></li><li>Concentrated portfolio:<ul><li>Concentrated investment among fewer securities, strategies or portfolio managers</li><li>Resulting less diversification(higher risk) but potentially higher return</li></ul></li></ul></li><li><p>Benefits of combining traditional investment and alternative investment:</p><ul><li>Diversification as alternative investment has low correlation with traditional market(smaller $\sigma$)</li><li>Potentially higher return(greater $R_{p}$)</li><li>Potentially higher Sharpe ratio = $\frac{R_{p}-rf}{\sigma}$</li></ul></li><li><p>Risk consideration:</p><ul><li>Standard deviation may be a misleading measure of risk</li><li>Valuation of alternative investment is based on estimate as there is no observable market price</li><li>Sharpe ratio may be biased upward</li><li>Investor should take into account <strong>downside risk</strong> and <strong>use Value at Risk(VaR) and Sortino ratio to measure risk</strong></li><li>Use of derivatives introduces extra risk</li><li>Risk of portfolio managers underperform</li><li>Hedge fund and private equity are less transparent</li><li>Illiquidity</li><li>Past returns and volatility may not be a good indication of future returns and volatility</li><li>Correlations of tradition market and alternative market tends to be small in long term but may still be significant in short term.</li></ul></li><li><p>Common structure of partnership:</p><ul><li>Limited partner(LP): <strong>investors</strong> who understand risks associated with investments(本质上是投资者)</li><li>General partner(GP): runs the fund and bears unlimited liability if anything goes wrong(本质上是fund manager)</li></ul></li><li><p>Hedge fund basics:</p><ul><li>Characteristics:<ul><li>Aggressively managed, heavily use of leverage and derivative</li><li>Aimed at high return with few investment restrictions</li><li>LP open to a limited number of investors who are able to make large investments</li></ul></li><li>Impose restrictions on redemptions(赎回):<ul><li>Lockup period(锁定期): a minimum period before investors are allowed to make withdraws</li></ul></li><li>Notice period(通知期): the amount of time to fulfill a redemption request after receiving request</li></ul></li><li><p>Hedge fund strategies:</p><ul><li><p>Event-driven strategy: seek profit from short-term event such as <strong>acquisition or reconstruction</strong></p><ul><li><p>Merge arbitrage: long stock of the company being acquired and short stock of the acquiring company</p></li><li><p>Distressed securities: focus on securities of companies <strong>either in or near bankruptcy</strong></p><p>e.g. 1. purchases fixed-income securities of the company trading at significant discount to bar</p><p>​       2. buying senior debt and shorting junior debt or buying preferred stock and shorting                      ordinary stock</p><p>​       3. <strong>short sell</strong> stock of the company near bankruptcy</p></li><li><p>Activist shareholder: purchase sufficient equity to influence a company’s policy and direction(对冲基金作为积极股东,通常选择的公司是已经公开上市的)</p></li><li><p>Special situation: focus only on companies that are currently engaged in <strong>restructuring activities</strong> but not M&amp;A or bankruptcy</p></li></ul></li><li><p>Relative value strategy: seek profit from <strong>pricing discrepancy between related securities</strong></p><ul><li>Fixed income convertible arbitrage: seek mispricing between MV of convertible bond and MV of ordinary share after conversion(可转债市场价格低于转换后普通股的市场价格,有套利空间)</li><li>Fixed income asset based: mispricing of Asset backed securities(ABS). If ABS is overpriced, short it. Vice Versa</li><li>Fixed income general: 通过寻找两只债券之间周期性的规律(recursive pattern)来进行套利</li><li>Volatility: use option to go long or short <strong>market volatility</strong></li><li>Multi-strategy: look for opportunity within and across asset classes</li></ul></li><li><p>Macro strategy: seek profit from <strong>expected movements in economic variables</strong> influenced by major economic events(从宏观经济趋势中获利)</p></li><li><p>Equity hedge strategy:</p><ul><li>Market neutral: maintain a net position that is <strong>neutral to market risk e.g. $\beta$=0</strong></li><li>Fundamental growth: use <strong>fundamental analysis</strong> to recognize companies expected to have <strong>high growth&amp;</strong></li><li>Fundamental value: use <strong>fundamental analysis</strong> to recognize companies that are <strong>undervalued</strong></li><li>Quantitative directional: use <strong>technical analysis</strong> to identify overvalued and undervalued companies. Market climate should also be considered.</li><li>Short bias: short overvalued companies</li><li>Sector specific: exploits expertise in a particular sector</li></ul></li></ul></li><li><p>Funds of hedge funds(FOF)(母基金):</p><ul><li>FOF holds a portfolio of other hedge funds and FOF itself is not necessarily a hedge funds</li><li>Benefits: <ul><li>Make hedge funds accessible to smaller investors</li><li>Further diversification</li><li>GP of FOF(who is more expertise than most investor) to conduct due diligence </li><li>Able to negotiate better redemption rules with hedge funds as a fund</li><li>Possible access to closed hedge funds(hedge funds are closed but FOF is opened)</li></ul></li><li>Disadvantage: complex fee structure(higher fees)</li></ul></li><li><p>Hedge fund fee structure:</p><ul><li>Management fee: <ul><li>Must be paid regardless investment performance</li><li>Calculated based on beginning-of-period or end-of-period assets under management(AUM)</li></ul></li><li>Incentive fee:<ul><li>Calculated based on realized profit</li><li>Net of management fee: calculate incentive fee based on profit <strong>after</strong> paying management fee</li><li>Net of management fee: calculate incentive fee based on profit <strong>before</strong> paying management fee</li></ul></li><li>Example: 2/20 structure means 2 percent of AUM as management fee and 20 percent of realized profit as incentive fee </li><li>High water mark: <ul><li>incentive fees are only paid once. In other words, paid when AUM(net of management fee) is above the highest AUM previously recorded(只有比支付过激励费的最高点AUM还要高的部分才需要支付激励费).</li><li>Example: <img src="https://i.loli.net/2020/08/15/N59AwWGPxqJm37b.png" alt="High_water_mark.png">在period 1期末支付过一次incentive fee, high-water mark为期末的AUM. Period 2亏损所以不需要支付incentive fee, high-water mark仍是period 1期末AUM. Period 3盈利,在期末支付一次incentive fee, high-water mark为期末AUM</li></ul></li><li>Hurdle rate:<ul><li>Incentive fee is only earned if the fund achieves a specified return rate(hurdle rate)</li><li>Hard hurdle rate: incentive fee is only paid on the part of earning <strong>excess of benchmark return</strong>(只为超过benchmark的那盈利部分支付激励费)</li><li>Soft hurdle rate: incentive fee is paid on <strong>all earnings</strong> if return is above hurdle rate(如果超过了benchmark,所有盈利都需要支付激励费)</li><li>Assume hard hurdle rate unless specified </li></ul></li></ul></li><li><p>Hedge fund valuation:</p><ul><li><p>Valuation of liquid asset(with a market value):</p><ul><li><p>Common approach: use average quote = $\frac{bid\ price+ask\ price}{2}$</p></li><li><p>Conservative approach:</p><p>use bid price for long position(因为多头将来会卖出,所以关心市场中买价)</p><p>use ask price for short position(因为空头将来会买入,所以关心市场中卖价)</p></li></ul></li><li><p>Valuation of illiquid asset(without a reliable market value): compute MV using <strong>statistical models</strong></p></li><li><p>Reporting NAV: quoted market price</p></li><li><p>Trading NAV: incorporates liquidity discount(考虑流动性折价后的NAV,例如一个基金NAV = 100, 卖一份的价格是100, 如果卖一万份,每份价格可能就只有90, 所以reporting NAV = 100, trading NAV = 90)</p></li></ul></li><li><p>Hedge fund due diligence:</p><ul><li>Investment strategy and process</li><li>Source of competitive advantages</li><li>Longevity(产品寿命;历史表现可否持续)</li><li>Key person risk(PM reputation)</li></ul></li><li><p>Private equity basics:</p><ul><li>Definition: invests either in privately owned company or public company with the intent to take it private(上市公司私有化)</li><li>Advantage:<ul><li>Higher overall return compared to public stock market</li><li>Low correlation with traditional market(diversification)</li></ul></li><li>Disadvantage:<ul><li>PE do not regularly value their assets. It may lead to underestimate volatility and correlation of their assets</li><li>Survivorship bias: only PE that may survive will stay in the index(只有好的私募可以留在指数,会使指数偏高)</li><li>Backfill bias(回填偏差): excluding historical data for funds that are underperformed from the index(只有表现好的PE会被加入指数,导致指数偏高)</li></ul></li></ul></li><li><p>Private equity fee structure:</p><ul><li>Committed capital: the amount that LPs have agreed to provide to the PE fund(similar to AUM)</li><li>Management fees: calculated based on <strong>committed capital</strong></li><li>Incentive fees: <ul><li>Prohibiting distribution of incentive fees until LPs have received back their investment capital</li><li>Setting up an escrow account(第三方托管账户) for a proportion of incentive fees</li><li>Clawback provision: GP must return any distributed incentive fees until LPs have received initial investment and 80 percent of earnings(最后赎回清算时,如果之前先产生盈利(付了激励费),后产生亏损(没有退还)则必须根据总的净利润计算激励费,并退还多支付的激励费)</li></ul></li></ul></li><li><p>Private equity strategies:</p><ul><li>Leverage buyouts(LBOs;杠杆收购): <ul><li>acquire public or private companies with a <strong>significant percentage of the purchase price financed through debt</strong></li><li>PE自己出一部分钱,剩下大部分钱从外面贷款,并用收购的公司作为抵押</li><li>Management buyouts: management team uses LBO to acquire the company they manage</li><li>Management buy-ins: external management team uses LBO to acquire the company and replace existing management team</li><li>Characteristics of attractive targets of LBO: undervalued stock price, current management team is willing to takeover(PE和内部管理层里应外合), strong and sustainable cash flow</li></ul></li><li>Venture capital: invest in private companies with high growth potential<ul><li>VC专注于投资早期,非上市公司</li><li>Angel investing(天使投资): provided at idea stage, fund is used to transform idea into business plan and assess market potential(通常天使投资由一个人提供而不是机构)</li><li>Seed stage: fund is used to support product development and marketing(VC常在这个阶段进入)</li><li>Early stage: fund is used to initiate commercial production and sales(用于制造而不是研究)</li><li>Later stage: fund is used to expansion of production and increasing sales</li><li>Mezzanine-stage: fund is used to prepare for IPO</li></ul></li><li>Development capital(发展资本): minority equity(PE作为少数股东) investment in mature firms looking for capital to expand or enter new markets etc.</li><li>Distressed investing(危机投资): invest bond in mature companies in financial difficulties expecting their bond will increase in price in the future(投资濒临破产公司债券,期待将来债券涨价)</li></ul></li><li><p>Private equity valuation:</p><ul><li>Market/comparable approach: share price multiples, enterprise value multiples(Equity investment)</li><li>Discount after-tax cash flow approach: DCF, DDM</li><li>Asset-based approach: Equity = Asset - Liability</li></ul></li><li><p>Private equity exit strategy:</p><ul><li>PE must exit to turn earnings into realized profit</li><li>Trade sale(同行出售): sale the company to a strategic buyer or a competitor</li><li>IPO:  can potentially make the highest earnings</li><li>Recapitalization(资本结构重构):<ul><li>A company issues new debt to fund dividends to equity holders</li><li>Equity = Asset - Liability, 借款分红导致equity总额变少,每股价格降低,相当于提前拿到了一部分出售股权的钱,变相实现套现离场</li><li>Not a true exit strategy as PE still hold stocks</li><li>Popular strategy when interest is low and act as a prelude(前奏) of a later exit</li></ul></li><li>Secondary sales: sale company to another PE/investors</li><li>Written-off/liquidation(破产清算)</li></ul></li><li><p>Private equity due diligence:</p><ul><li>Alignment of GP’s interest and that of LPs’</li><li>A well-planned exiting strategy</li></ul></li><li><p>Real estate investment:</p><ul><li><p>Reasons for investing real estate:</p><ul><li>Competitive long-term return driven by rent generation and capital appreciation(增值)</li><li>Rent may be fixed for multiple years which lessen cash flow impact from economic shocks(许多年租金产生的现金流固定可以在金融危机时进行缓冲)</li><li>Low correlation with the traditional market(Diversification)</li><li>Inflation hedge as rent can be adjusted quickly according to inflation</li></ul></li><li><p>Forms of real estate investment:</p><table><thead><tr><th></th><th>Debt</th><th>Equity</th></tr></thead><tbody><tr><td>Private(Direct)</td><td>Mortgages(个人贷款买房), construction lending(开发商借钱盖楼)</td><td>Direct ownership of real estate(e.g. sole ownership, joint venture, real estate limited partnership)</td></tr><tr><td>Public(Indirect)</td><td>Mortgage-backed security(MBS)</td><td>Shares in real estate corporations, shares in real estate investment trust(REIT)</td></tr></tbody></table></li><li><p>Real estate investment trust(REIT): obligate to distribute the majority(90 percent) of their income to shareholders to retain their regulatory tax-advantage status</p></li><li><p>Real estate index:</p><ul><li>Appraisal index(评估指数): use <strong>estimates of value</strong> as inputs to indices. It is <strong>subjective</strong> and may understate volatility</li><li>Repeat sales index: use repeat sales of properties to construct the indices. There is <strong>sample selection bias</strong>(如果一个不动产永远不被卖,它就永远不被计入指数)</li><li>REIT index: use prices of public traded shares of REIT to construct indices</li></ul></li><li><p>Valuation method:</p><ul><li>Comparable sales approach: approximate value based on *<em>recent sales of similar properties *</em>and make necessary adjustments to compensate differences in location, age, condition etc.</li><li>Income approach: discount future cash flow from property ownership(DDM)</li><li>Cost approach: estimate value using replacement cost which is the value of land plus the cost of rebuilding using current construction costs and standards</li></ul></li><li><p>Risks of real estate investment;</p><ul><li>Highly influenced by national and global economic conditions</li><li>Property development is subject to regulatory issues, construction delay, budget overruns etc.(这点是对于投资地产的开发商的潜在风险而不是投资者的风险)</li><li>Real estate investment often leads to high leverage</li></ul></li></ul></li><li><p>Infrastructure investments:</p><ul><li>Brownfield investment: invest in existing infrastructure assets</li><li>Greenfield investment: invest in infrastructure assets that are under R&amp;D and to be constructed in the future(投资还在研发当中的基建)</li><li>Forms of investment:<ul><li>Infrastructure are rarely invest directly and most investors will invest indirectly</li><li>Public traded infrastructure securities e.g. Master Limited Partnership(MLP)</li></ul></li><li>Risks of infrastructure investment:<ul><li>Brownfield investment has lower risk and lower return</li><li>Greenfield investment has higher risk and higher return</li><li>Regulatory risk(政策监管的风险e.g.国家政策的改变)</li></ul></li></ul></li><li><p>Commodity(大宗商品):</p><ul><li>Characteristics of commodity investment:<ul><li>Holding commodity incurs costs for transportation and storage</li><li>Lower correlation with traditional market(diversification)</li><li>Hedge against inflation(price of commodity must increase when there is a high inflation rate)</li></ul></li><li>Investment vehicle:<ul><li>Derivative(commodity futures)</li><li>Commodity ETF</li><li>Stocks of companies which have direct link to commodity(e.g.中国石油)</li><li>Specialized fund in specific commodity sector</li></ul></li></ul></li><li><p>Commodity futures:</p><ul><li><p>How to price a future commodity contract:</p><ul><li><p><strong>Future price = spot price(1+r) + storage cost - convenience yield</strong></p><p>spot price: 现货价格</p><p>$r$: discounting rate</p><p>Convenience yield: 现货相对于期货的好处(早拿到货的好处)</p></li><li><p>Contango(期货溢价): future price &gt; spot price(there is little or no convenience yield)</p></li><li><p>Backwardation(现货溢价): future price &lt; spot price(there is high convenience yield)</p></li></ul></li><li><p>Source of returns from investing futures:</p><ul><li><p>Collateral yield: interests earned from collateral which acts as deposit for future contracts</p></li><li><p>Roll yield = spot price - future price = future price with settling date $T_{1}$ - future price with settling date $T_{2}$</p><p>Roll yield is positive in backwardation and negative in Contango</p></li><li><p>Yield from changes in spot price</p></li><li><p>Summary: <strong>percentage change in future price = percentage change in spot price + collateral yield + roll yield</strong></p></li><li><p>Example:</p><table><thead><tr><th></th><th>$T_{1}$</th><th>$T_{2}$</th><th>Return</th></tr></thead><tbody><tr><td>Future price</td><td>10</td><td>12</td><td>20%</td></tr><tr><td>Spot price</td><td>8</td><td>12</td><td>50%</td></tr></tbody></table><p>Assume collateral yield = 0</p><p>20% = 50% + roll yield</p><p>Roll yield = -30% i.e. Contango which matches spot price &lt; future price at $T_{1}$</p></li></ul></li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;CFA-Alternative-investment-Notes&quot;&gt;&lt;a href=&quot;#CFA-Alternative-investment-Notes&quot; class=&quot;headerlink&quot; title=&quot;CFA Alternative investment Notes&quot;&gt;&lt;/a&gt;CFA Alternative investment Notes&lt;/h1&gt;&lt;h2 id=&quot;Introduction-to-Alternative-Investment&quot;&gt;&lt;a href=&quot;#Introduction-to-Alternative-Investment&quot; class=&quot;headerlink&quot; title=&quot;Introduction to Alternative Investment&quot;&gt;&lt;/a&gt;Introduction to Alternative Investment&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Traditional and alternative investment comparisons:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;Investment underlying&lt;/th&gt;
&lt;th&gt;Position&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;Traditional&lt;/td&gt;
&lt;td&gt;Public stock, bond, cash only&lt;/td&gt;
&lt;td&gt;Long position only&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Alternative&lt;/td&gt;
&lt;td&gt;Public stock, bond, cash, private stock, real estate, commodities, infrastructure, collectibles, patents etc.&lt;/td&gt;
&lt;td&gt;Long position, short position and leveraged position&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;&lt;p&gt;Characteristics of alternative investments:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Illiquidity of underlying assets(difficult or take longer to change asset into cash)&lt;/li&gt;
&lt;li&gt;Narrow manager specialization(通常需要由专业PM进行)&lt;/li&gt;
&lt;li&gt;Low correlation with traditional investments(hedge risk and diversification)&lt;/li&gt;
&lt;li&gt;Less regulation and less transparency&lt;/li&gt;
&lt;li&gt;Limited and problematic historical data and risk(due to less transparency)&lt;/li&gt;
&lt;li&gt;Unique legal and tax consideration&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Finance" scheme="https://yuxuanliu.tech/categories/Finance/"/>
    
    
      <category term="CFA" scheme="https://yuxuanliu.tech/tags/CFA/"/>
    
      <category term="Finance" scheme="https://yuxuanliu.tech/tags/Finance/"/>
    
  </entry>
  
  <entry>
    <title>CFA Equity Investment Notes</title>
    <link href="https://yuxuanliu.tech/CFA_Equity_investment/"/>
    <id>https://yuxuanliu.tech/CFA_Equity_investment/</id>
    <published>2020-08-06T02:53:23.000Z</published>
    <updated>2020-08-05T20:04:29.380Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CFA-Equity-investment-Notes"><a href="#CFA-Equity-investment-Notes" class="headerlink" title="CFA Equity investment Notes"></a>CFA Equity investment Notes</h1><h2 id="Market-organization-and-structure"><a href="#Market-organization-and-structure" class="headerlink" title="Market organization and structure"></a>Market organization and structure</h2><ol><li><p>Financial market function:</p><ul><li>Achieving entities’(corporates and individuals) needs:<ul><li>Saving and borrowing(债权融资)</li><li>Raising entity capital(股权融资)</li><li>Managing risk(derivatives, insurances etc.)</li><li>Exchange assets(currency exchange etc.)</li><li>Information-motivated trading: arbitrage by valuating the intrinsic value(IV) of an asset and identify whether it is overvalued(IV&lt;market value; short position) or undervalued(IV&gt;market value; long position)</li></ul></li><li>Determining equilibrium rates of return(均衡利率): the rate that equates the supply of fund to the demand of fund(当资金的供给等于需求时的利率)</li><li>Capital allocation efficiency(资产合理配置): allocate capital to the most productive places(e.g. highest Sharpe ratio)</li></ul><a id="more"></a></li><li><p>Classification of financial markets:</p><ul><li><p>Based on delivery dates(根据交割日期分类):</p><ul><li>Spot market(现货市场): the market where delivery happens <strong>now</strong></li><li>Future market(期货市场): the market where delivery happens <strong>in the future</strong></li></ul></li><li><p>Based on maturity of fixed income instruments:</p><ul><li>Money market(货币市场): debt instruments maturing within one year</li><li>Capital market(资本市场): debt instruments maturing over one year</li></ul><p>Only make sense for fixed income instruments but not equity as all companies are assumed to be going concern(永续经营)</p></li><li><p>Based on asset types(标的物):</p><ul><li>Traditional market: public traded debts and equities(公开交易且只可以做多), pooled investment vehicles(Funds)</li><li>Alternative market: hedge funds, private equity, commodities, real estate securities, collectibles(收藏品) etc. 所有不属于Traditional market 均是 Alternative market</li></ul></li><li><p>Based on capital flow:</p><ul><li>Primary market: <strong>newly issued</strong> securities are <strong>sold by issuer to investors</strong></li><li>Secondary market: <strong>investors trade with each other</strong></li></ul></li></ul></li><li><p>Classification of financial assets based on asset characteristics:</p><ul><li>Security: <ul><li>Fixed income: bonds, <strong>repurchase agreement(repo)</strong>, certificate of deposit(大额存单), convertible debts(可转债)</li><li>Equity: common share, preferred shares, <strong>warrant(权证)</strong></li><li><strong>Pooled investment vehicle: close-ended fund, open-ended fund, ETF</strong>, ABS(资产证券化), hedge fund</li></ul></li><li>Derivative contract:<ul><li>Financial derivative contract</li><li>Physical derivative contract</li></ul></li></ul></li><li><p>Classification of financial assets based on whether publicly traded:</p><ul><li>Public security: traded on exchanges or through dealers, subject to regulatory oversight</li><li>Private security: not traded in public markets and not subject to regulations</li></ul></li><li><p>Repurchase agreement &amp; Reverse repurchase agreement:</p><ul><li><p>Repurchase agreement(Repo;央行先卖后买,市场现金先少后多): </p><p>Central bank firstly sells national debt to the market so there is less cash in the market. A few days later(normally 15 days), central bank repurchase the national debt with a higher price. Cash is going back to the market. <strong>Central bank uses repo to adjust the amount of cash in the market</strong></p></li><li><p>Reverse repurchase agreement(Reverse repo;央行先买后卖,市场现金先多后少):</p><p>Central bank firstly purchases national debt in the market with cash so there is more cash in the market. A few days later(normally 15 days), central bank sells the national debt back to the market. Cash is going back to the central bank. <strong>Central bank uses reverse repo to adjust the amount of cash in the market</strong></p></li></ul></li><li><p>Warrant: owner of a warrant has the right to buy stock at a price specified by the issuer before a given date. It is a bit similar to warrant.</p></li><li><p>Pooled investment vehicle:</p><ul><li>Open-end mutual fund(开放型公募基金):<ul><li>Investor can purchase shares of fund <strong>using cash</strong> and sell shares of fund(赎回) back to the fund company at net asset value(NAV) everyday</li><li>Advantage: more liquidity than closed-end mutual fund</li><li>Disadvantage: cash drag(基金公司不能将所有募集到的资金全部用于投资必须保留一部分作为给赎回基金的投资者的付款,因此没有最大化基金的收益)</li></ul></li><li>Closed-end mutual fund(封闭型公募基金):<ul><li>There is a lockdown period for closed-end mutual fund(5-10 years). Once issued, investors cannot sell shares of fund back to the fund company. Shares must be traded <strong>with cash</strong> at market price in the secondary market. The market price will be slightly lower than NAV due to the illiquidity.</li><li>Advantage: no cash drag </li><li>Disadvantage: illiquidity</li></ul></li><li>Exchange traded fund(ETF):<ul><li>Authorized participant uses <strong>a basket of stocks to exchange shares of ETF</strong> from fund company. Authorized participant then sells shares of ETF to investor with cash at the market price. Authorized participant can also use shares of ETF to exchange back to a basket of stocks. If NAV of a basket of stock &gt; market value of ETF, authorized participant will purchase ETF in the secondary market and exchange for stocks in order to arbitrage. Vice versa.</li><li>Advantage: easy to trade, low management fees, tax deferring(only pay tax for realized income)</li><li>Disadvantage: risk of illiquidity market, bid-ask spread(AP买卖差价)</li></ul></li></ul></li><li><p>Financial intermediaries(金融媒介):</p><ul><li>Brokers(经纪人): help clients buy or sell securities by finding counterparties(对手盘). Only make commission and not involved in the trade.</li><li>Block brokers(大宗经纪人): provide service to large traders(大宗交易者), the trade is outside the stock exchange</li><li>Dealers(做市商): trade by buying for or selling from their own inventory of stocks. Make bid-ask spread and involved in the trade. <strong>Provide liquidity in the market.</strong></li><li>Broker-dealers: act as both broker and dealer, has a conflict of interests. It is because broker wish to sell stock at a <strong>higher price</strong> for more commission. However, as a dealer we wish the <strong>bid price to be as low as possible</strong>(同时作为经纪人和做市商即:自己给自己搭桥把别人要卖的股票自己买下)</li><li>Primary dealers: trade with <strong>central bank</strong> when conducting monetary(货币) policy e.g. repo</li><li>Arbitrageurs(套利商): buy and sell similar instruments at different prices in different markets. They move liquidity through markets</li><li>Exchanges: provide places where trades can be arranged. Exchanges have <strong>regulatory authorities</strong></li><li>Alternative trading systems: same trading function as exchange but <strong>without</strong> regulatory authorities</li><li>Investment banks: help clients arrange transactions like IPO and debt offering</li><li>Securitizers(证券化商): buy assets and place them in a pool. Sell securities that represents ownership of the pool in the market e.g. ABS, MBS</li><li>Clearinghouses(清算所): guarantee derivative performance(确保衍生品合同可以履约)</li><li>Custodians: improve market integrity by holding clients asset and prevent loss due to fraud e.g. Alipay and WeChat</li><li>Depository institutions: commercial bank, credit union etc. They raise funds from depositors and lend them to borrowers</li><li>Insurance company: <ul><li>Definition: help people offset risk by creating a contract that provide a payment in the event that some loss occurs </li><li>Fraud: people may lie to get the money, leads to loss of insurance company</li><li>Moral hazard: people with insurances are likely to be more willing to risk so there is a higher chance for repayment, leads to loss of insurance company</li><li>Adverse selection: healthy people are unwilling to buy health insurance. However, people with a poor health condition are more likely to buy heath insurance. This leads to a higher chance for repayment, leads to loss of insurance company.</li></ul></li></ul></li><li><p>Position(头寸):</p><ul><li>Long position(多头头寸):<ul><li>Benefit from appreciation(涨价) in prices of the assets or contracts</li><li>Examples: purchase stocks, bonds, calls, futures, forwards; sell puts</li><li>Purchase calls(看涨期权): 现在付钱买期权,得到一个在未来以现在价格买入股票的权力,若未来股票价格上涨则行使权力,赚钱,多头头寸</li><li>Purchase futures(forwards): 买入期货, 未来交割时以现在价格交易, 若未来涨价即省钱,等同于赚钱,多头头寸</li><li>Sell puts(看跌期权): 别人给你付钱买期权, 得到一个在未来以现在价格卖出股票的权力, 若未来股票价格上涨则不会有人行使权力, 赚取了别人购买期权的钱, 多头头寸</li></ul></li><li>Short position(空头头寸):<ul><li>Benefit from decrease in prices of the assets or contracts</li><li>Examples: short-selling(卖空); purchase puts; sell call, future, forward</li><li>Purchase puts: 现在付钱买期权,得到一个在未来以现在价格卖出股票的权力,若未来股票价格下降则行使权力,赚钱,空头头寸</li><li>Sell calls: 别人给你付钱买期权, 得到一个在未来以现在价格买入股票的权力, 若未来股票价格下跌则不会有人行使权力, 赚取了别人购买期权的钱, 空头头寸</li><li>Sell futures(forwards): 卖出期货, 未来交割时以现在价格交易, 若未来降价即赚钱,空头头寸</li></ul></li><li>An important notes: buying stock is a long position but selling stock is neither long position or short position. Investors don’t make money when there is a drop in price after selling the stock. Once a stock is sold it is no longer related to investors.</li></ul></li><li><p>Option:</p><ul><li><p>期权是权力, 一个投资者需要现在花钱买权力但将来不一定要执行权力</p></li><li><table><thead><tr><th>Option</th><th>Option position</th><th>Underlying position</th></tr></thead><tbody><tr><td>Buy call</td><td>Long</td><td>Long</td></tr><tr><td>Sell call</td><td>Short</td><td>Short</td></tr><tr><td>Buy put</td><td>Long</td><td>Short</td></tr><tr><td>Sell put</td><td>Short</td><td>Long</td></tr></tbody></table><p>Option position: 只要买入option就是long, 卖出option就是short</p><p>Underlying position: 看标的物的本质会涨还是跌</p></li></ul></li><li><p>Short-selling:</p><ul><li><p>Investors borrow stocks from dealers and immediately sell them. Cash from selling stocks must act as the collateral(抵押物) of borrowing. If stock price decreases in the future, investor can buy stocks at lower cost and return them back to dealer(short position).</p></li><li><p><strong>Short selling profit = original selling price - repurchase cost - Interest of borrowing stock - Commission + Interest earned from collateral - dividends distributed during borrowing</strong></p></li><li><p>Potential gain of short selling is limited to 100%(when stock price = 0). However, the potential loss is unlimited(there is no upper limit of stock price)</p></li><li><p>If there is any dividends distributed during borrowing, short-seller must pay lender the equivalent amount in cash</p></li><li><p>Rebate rate = Interest earned from collateral - implicit loan fee(Interest of borrowing stock)</p><p>Implicit loan fee is affected by the availability of stock and rebate rate is likely to be negative. i.e. the cost of borrowing stock is higher than the return of investing collateral</p></li></ul></li><li><p>Leverage position:</p><ul><li><p>Margin transaction(保证金交易): buy securities by borrowing some of the purchase price</p></li><li><p>Buyer’s equity: portion of the security that belongs to the buyer</p></li><li><p>Financial leverage ratio = $\frac{Asset(Market\ value)}{Equity}$</p></li><li><p>Gain or loss is amplified by the value of financial leverage ratio</p></li><li><p>Initial margin requirement(IM) =  $\frac{Equity_{0}}{Market\ value_{0}}$</p></li><li><p>Maintenance margin requirement(MM) $\le \frac{Equity_{1}}{Market\ value_{1}}$</p></li><li><p>Margin call: if buyer’s equity is less than maintenance margin requirement(MM), buyer will receive a request for additional equity or the position will be liquidated(强制平仓)</p></li><li><p>Example: at $T_{0}$, $Market\ value_{0}$ = 300, $Equity_{0}$ = 100 so IM = MM = $\frac{1}{3}$</p><p>At $T_{1}$, $Market\ value_{1}$ = 250, $Equity_{1}$= 100-(300-250)=50 $\frac{1}{5}$&lt; MM so it has trigger the margin call</p></li><li><p>Price triggering a margin call(Margin call price) = $P_{0}\cdot \frac{1-IM}{1-MM}$</p><p>$P_{0}$:the initial price of stock</p><p>As IM$\ge$ MM, $\frac{1-IM}{1-MM}$ $\le$1 so margin call price is always less than or equal to initial price</p></li><li><p>Rate of return of a margin transaction = $\frac{Total\ gain - commission\ of \ selling +Dividends-Interests}{Initial\ equity+\ commission\ of \ purchase}$</p><p>Total gain = Selling price of stocks - Initial purchase price of stocks</p></li></ul></li><li><p>Orders(下单):</p><ul><li>The best bid: the <strong>highest bid price</strong> in the market</li><li>The best ask: the <strong>lowest ask price</strong> in the market</li><li>Execution instructions(执行指令): indicates how to fill the order<ul><li>Market order: instruct the broker to immediately buy at the best ask price or sell at the best bid price. The market order is quick but the purchase/sell price is not under control. Price can be unfavorable when the security is thinly traded(市场中股票稀缺) or order is very large(交易量大)</li><li>Limit order: instruct broker only buy in when best ask $\le$ limit price or sell when best bid $\ge$ limit price. Limit order is not necessarily quick and don’t guarantee a deal but purchase/sell price is under control</li><li>Aggressively priced: when the limit price of the limit order is a lot higher/lower than the market price i.e. limit price &gt;&gt; market ask price or limit price &lt;&lt; market bid price</li><li>Marketable limit order: set the current market price as the limit price. It could guarantee part of the deal is done but not necessarily all.</li></ul></li><li>Status of limit order:<ul><li><img src="https://i.loli.net/2020/08/06/aRriYDpuEH4I1dX.jpg" alt="Status_of_limit_order.jpg"></li><li>Make a new market: best ask&gt;limit buy price &gt; best bid or best bid&lt;limit sell price &lt; best ask, no deal</li><li>Make the market: best bid = limit buy price &lt; best ask or best ask = limit sell price &gt; best bid, no deal</li><li>Behind the market: limit buy price &lt; best bid &lt; best ask or limit sell order &gt; best ask &gt; best bid, no deal</li><li>Far behind the market: limit buy price &lt;&lt; best bid &lt; best ask or limit sell order &gt;&gt; best ask &gt; best bid, no deal</li><li>Take the market: limit buy price = best ask &gt; best bid or limit sell price = best bid &lt; best ask. There is a deal.</li></ul></li><li>All-or-nothing order: can only trade if <strong>the entire order can be traded</strong></li><li>Hidden orders: detail of the order is only exposed to broker/exchange not the public<ul><li>Iceberg orders: only display size of the order to the public, rest of the order is hidden</li></ul></li><li>Validity instructions(时效指令): indicates when the order may be filled<ul><li>Day orders: the order will expire if it is not filled <strong>by the end of the day</strong></li><li>Good-till-cancelled order: the order will not expire until the order is cancelled</li><li>Immediate-or-cancel order: cancel immediately if the order can not be filled partially or in full(只有一瞬间有效,能成交多少就成交多少,无法成交部分立刻作废)</li><li>Good-on-close orders: the order can only be filled at the close of trading(只有闭市一瞬间有效)</li><li>Good-on-open orders: the order can only be filled at the open of trading(只有开市一瞬间有效)</li><li>Stop sell order: only execute sell when the market price is at or below that stop price(对于多头的止损). Stop sell+market order can make sure shares are all sold but don’t guarantee price. Stop sell+limit order cannot make sure shares are all sold but guarantee price.</li><li>Stop buy order: only execute buy order when the market price is at or above the stop price(对于空头的止损)Stop buy+market order can make sure shares are all bought in but don’t guarantee price. Stop buy+limit order cannot make sure shares are all bought in but guarantee price.</li></ul></li><li>Application of stop order(止损单):<ul><li>Stop loss at a certain position</li><li>Only trade when there is a market confirmation of analytical result(等市场验证了分析结果再执行交易指令)</li><li>Reinforce market momentum(市场连锁效应,一个stop order引发另一个)</li></ul></li></ul></li><li><p>Primary market:</p><ul><li><p>Public offering(公开发行):</p><ul><li><p>Initial public offering(IPO): first-time issued by firm whose shares aren’t currently public traded</p><p>Underwritten offering(承销): the investment bank <strong>guarantees the sale of all issued share</strong></p><p>Best effort offering(代销): the investment bank acts as broker and is <strong>not obligate to sell all issued share</strong></p></li><li><p>Secondary offering: issued new shares when there are already public traded shares in the market(无论第二次发行还是第三次均叫secondary offering)</p></li></ul></li><li><p>Private offering(非公开发行):</p><ul><li>Private placement(定向增发): sell shares at discount to a small group of qualified investors. These shares have a lockdown period due to the discount</li><li>Shelf registration: corporates can decide when they wish to issue shares after the paper work is done. Corporates do not necessarily need to immediately issue shares after paper work is done</li><li>Dividend reinvestment plan: shareholders reinvest their dividends into corporates newly issued shares at discount</li><li>Right offering: shareholders are given rights to buy newly issued shares at a discount to the current market price</li></ul></li></ul></li><li><p>Secondary market:</p><ul><li><p>Classified by trading session:</p><ul><li><p>Call market(集合竞价): often executed at the start or end of the day. All buy and sell orders are gathered. A single price is chosen to <strong>maximize the total volume of trade</strong>. All bid orders over or at the chosen price have a deal at the chosen price. All ask orders under or at the chosen price have a deal at the chosen price.</p></li><li><p>Continuous market: trades are arranged and executed anytime when the market is open(买单卖单自由匹配)</p></li><li><table><thead><tr><th></th><th>Advantage</th><th>Disadvantage</th></tr></thead><tbody><tr><td>Call market</td><td>Easier for buyers and sellers to find counterparty</td><td>Only execute during a particular period</td></tr><tr><td>Continuous market</td><td>Execute during most of the day</td><td>If a buyer and seller arrive in the market at different time, they cannot trade with each other.</td></tr></tbody></table></li></ul></li><li><p>Classified by trading mechanism:</p><ul><li><strong>Quote-Driven market</strong>: trade at price quoted by dealer. The counterparty is the dealer e.g. foreign exchange market</li><li><strong>Brokered market</strong>: trade is arranged by broker e.g. block trade(大宗交易;find a buyer and a seller can be difficult)</li><li><strong>Order-driven market</strong>: trades are arranged using rules to match buyer and seller e.g. stock exchange</li></ul></li><li><p>Rules of order driven market:</p><ul><li><p>Order matching rule(成交优先性): highest priced buy orders and lowest priced sell orders are traded first. If buy and sell price are identical, the order with its size(交易数量) displayed is traded first. If orders are both displayed or hide, the order which arrives the exchange earlier is traded first.</p></li><li><p>Trading price rule(决定成交价格):</p><p>Uniform pricing rule: all trades are executed at the same time to maximize trading volume e.g. call market</p><p>Discriminatory pricing rule: 先挂单的受到价格歧视. 例如:9:35有一个limit ask&gt;=100, 9:38有一个limit bid&lt;=105. 这单最后会以100成交因为limit ask先挂单. 如果反过来, 9:35有一个limit bid&lt;=105, 9:38有一个limit ask&gt;=100. 这单最后会以105成交因为limit bid先挂单</p><p>Derivative pricing rule: orders are matched together at a fixed point during the day <strong>at the midpoint between best bid and best ask</strong></p></li></ul></li></ul></li><li><p>Well functioning financial system:</p><ul><li>Complete markets: instruments available to serve purposes of entities e.g. leverage, short-selling</li><li>Operational efficiency: low transaction cost</li><li>Information efficiency: security prices reflect their intrinsic values</li><li>Allocation efficiency: resources can go where they are most valuable e.g. cost portfolio with the highest Sharpe ratio</li></ul></li><li><p>Objectives of market regulation:</p><ul><li>Control fraud</li><li>Promote fairness</li><li>Set mutually benefit standards</li><li><strong>Ensure long-term debts are funded</strong></li></ul></li></ol><h2 id="Security-market-index"><a href="#Security-market-index" class="headerlink" title="Security market index"></a>Security market index</h2><ol><li><p>Security market index basics:</p><ul><li>A hypothetical portfolio of investment holdings that represents a segment of the financial market</li><li>Constituent securities: individual securities included in a security index</li><li>Price return index: reflects <strong>only the prices of constituent securities</strong></li><li>Total return index: reflects not only prices of constituent securities but also dividends reinvestment since inception</li><li>Total return index $\ge$ Price return index</li><li>Rebalancing: adjusting the weights of constituent securities to make it <strong>consistent with the weighting method chosen</strong></li><li>Reconstitution: <strong>change constituent securities in the index</strong> when certain constituent securities no longer meet the selection criteria or cannot reflect changes in the target market.</li><li>How to construct a index:<ul><li>Decide target market</li><li>Decide securities included</li><li>Decide weighting method</li><li>How should index be rebalanced</li><li>How should the selection of securities and weighting method be re-examined?</li></ul></li></ul></li><li><p>Price return and total return:</p><ul><li><p>Price return: a rate of return calculated based on price return index</p></li><li><p>Total return: a rate of return calculated based on total return index</p></li><li><p>Single period return:</p><p>$V_{PRI}$ at the end of year 1 = $V_{PRI}$ at the end of year 0 $\times (1+Price\ return\ in\ year\ 1$)</p></li><li><p>Multiple period return:</p><p>$V_{PRI}$ at the end of year n = $V_{PRI}$ at the end of year 0 $\times (1+PR\  in\ year\ 1$)$\times (1+PR\ in\ year\ 2$)……$\times (1+PR\ in\ year\ n$)</p></li></ul></li><li><p>Price weighted price return index:</p><ul><li><p>The arithmetic average of constituent security prices, done by <strong>buying an equal number of shares of each constituent securities</strong></p></li><li><p>Price return index =$V_{PRI}$= $\frac{\Sigma^{N}<em>{i-1}P</em>{i}}{N}$</p></li><li><p>Price return = $\frac{\Sigma P_{1}-\Sigma P_{0}}{\Sigma P_{0}}$</p></li><li><p>Total return = $\frac{\Sigma P_{1}-\Sigma P_{0}+\Sigma D}{\Sigma P_{0}}$</p></li><li><p>Advantage: simple to calculate</p></li><li><p>Disadvantage:</p><ul><li><p><strong>Highly prices securities have a greater influence on index value</strong></p></li><li><p>Divisor must be <strong>adjusted to keep index unchanged</strong> when a split of stocks occurs</p><p>Example: before split: Stock A, 10 dollar; Stock B, 20 dollar; Stock C, 25 dollar</p><p>​                 before split price return index = $\frac{10+20+25}{3}=18.3$</p><p>​                 After split: Stock A, 5 dollar; Stock B, 20 dollar; Stock C, 25 dollar</p><p>​                 After split price return index = $\frac{5+20+25}{D}=18.3$</p><p>​                 After split divisor = 2.73</p></li></ul></li></ul></li><li><p>Equal weighted price return index:</p><ul><li><p>Each constituent security has an <strong>equal weight in terms of market value</strong>, done by investing equal dollar amount in each stocks</p></li><li><p>Price return index = $V_{PRI} = \frac{N\times amount\ invested}{D}$</p><p>N: number of constituent security</p><p>D: divisor</p></li><li><p>Price return:</p><ul><li><p>HPR = $\frac{P_{1}-P_{0}+D}{P_{0}}$</p></li><li><p>When there is no dividends, HPR = $\frac{P_{1}-P_{0}}{P_{0}}$</p><p>$PR = w_{1}\cdot HPR_{1}+w_{2}\cdot HPR_{2}……w_{n}\cdot HPR_{n}$ or Arithmetic mean of HPRs</p><p>$w_{i}$: the weight in value of security $i$, should be identical for equal weighting index</p></li></ul></li><li><p>Total return:</p><ul><li><p>HPR = $\frac{P_{1}-P_{0}+D}{P_{0}}$</p></li><li><p>$TR = w_{1}\cdot HPR_{1}+w_{2}\cdot HPR_{2}……w_{n}\cdot HPR_{n}$ or Arithmetic mean of HPRs</p><p>$w_{i}$: the weight in value of security $i$, should be identical for equal weighting index</p></li></ul></li><li><p>Advantage: simple to calculate</p></li><li><p>Disadvantage:</p><ul><li>Small cap bias: small cap stocks are over-presented, lead to higher volatility(同样的钱,小盘股可以买很多)</li><li>Require frequent rebalancing of the value weighting</li></ul></li></ul></li><li><p>Market-capitalization weighted price return index:</p><ul><li><p>Weight is determined by dividing market capitalization(市值) of each constituent securities by total market capitalization of the index</p></li><li><p>Price return index: </p><ul><li><p>Value of price return index = $V_{PRI} = \frac{\Sigma ^{N}<em>{i=1}n</em>{i}P_{i}}{D}$ = $\frac{MC}{D}$</p></li><li><p>$n_{i}$: number of units of constituent security $i$ in the market(股份数)</p><p>$P_{i}$: unit price of constituent security $i$</p><p>N: number of constituent security</p><p>D: divisor</p></li><li><p>Example: Stock A, 10 dollar, 1000 shares; Stock B, 20 dollar, 1500 shares; Stock C, 25 dollar, 2000 shares</p><p>$V_{PRI}=\frac{10\times1000+20\times1500+25\times2000}{D}=\frac{90000}{D}$</p><p>If we wish to set the price return index to be 1000, we will set D=90</p><p>Alternatively, if we wish set the price return index to be 100; we will set D=900 </p></li></ul></li><li><p>Price return = $\frac{\Sigma MC_{1}-\Sigma MC_{0}}{\Sigma MC_{0}}$</p><p>$MC_{i}$: market capitalization of all securities in the index at time $i$</p></li><li><p>Total return = $\frac{\Sigma MC_{1}-\Sigma MC_{0}+D}{\Sigma MC_{0}}$</p></li><li><p>Advantage: constituent stock’s weight equals to its actually market fraction</p></li><li><p>Disadvantage: large market capitalization have a greater influence on index value, may lead to momentum tilt(指数被大盘股绑架, 一旦大盘股跌会导致其他小盘股持有者有恐慌)</p></li></ul></li><li><p>Float-adjusted market-capitalization weighted price return index:</p><ul><li>Weight is determined by adjusting market capitalization(市值) of each constituent securities for its market float which is the number of shares available to the investing public(和market-capitalization weighted很类似,这里把不可流动的股票市值剔除掉)</li></ul></li><li><p>Free-float-adjusted market-capitalization weighted price return index:</p><ul><li>Very similar to float-adjusted market-capitalization weighted, further exclude shares not available to foreign investors</li></ul></li><li><p>Fundamentally weighting:</p><ul><li>Uses measures that are <strong>independent of its share price</strong> to determine weight on each constituent security such as book value, cash flow, revenue etc.</li><li>Leads to value tilt(better reflect intrinsic value)</li><li>Leads to contrarian effect(把不合理的market value拉回到intrinsic value附近)</li></ul></li><li><p>Uses of security(equity, fixed income) market index:</p><ul><li>Reflect market performance</li><li>Proxies(测量用的代替物) for measuring and modelling return($\alpha$), systemic risk($\beta$) and risk-adjusted performance(Sharpe ratio)</li><li>Proxies for asset classes in asset allocation models</li><li>Benchmark for active investment portfolio</li><li>Model portfolio for some ETF e.g.上证50ETF使用上证50指数搭建</li></ul></li><li><p>Types of security index:</p><ul><li><p>Broad market index: reflect entire equity market in a country</p></li><li><p>Multi-market index: reflect equity markets in multiple countries</p></li><li><p>Sector index: represents different economic sectors</p></li><li><p>Style index: represents equities classified according to market capitalization, value, growth</p><table><thead><tr><th></th><th>Value</th><th>Growth</th></tr></thead><tbody><tr><td>Large-cap</td><td>Large-cap value</td><td>Large-cap growth</td></tr><tr><td>Small-cap</td><td>Small-cap value</td><td>Small-cap growth</td></tr></tbody></table><p>Large-cap: equity with large market capitalization</p><p>Small-cap: equity with small market capitalization</p><p>Value: low P/E ratio i.e. the share normally have a high value(low risk)</p><p>Growth: high P/E ratio i.e. the share normally have more margin for future growth(high risk)</p></li></ul></li><li><p>Problems with fixed income index:</p><ul><li>Broad universe: there are so many types of fixed income securities, hard to classify</li><li>High turnover: need index reconstruction every time a bond expires</li><li>Dealer markets and illiquidity: fixed-income securities are normally traded in quote-driven market so highly rely on dealers to provide prices or estimate prices by themselves</li></ul></li><li><p>Alternative investment index:</p><ul><li>Commodity(大宗商品) index: consists of future contracts and commodities. Performance of commodity index can be quite different from their underlying performance(期货现货走势差异大)</li><li>Real estate index</li><li>Hedge fund index: only includes hedge fund that are voluntary to provide information so there is a survivorship bias</li></ul></li></ol><h2 id="Market-efficiency"><a href="#Market-efficiency" class="headerlink" title="Market efficiency"></a>Market efficiency</h2><ol><li><p>Market efficiency basics:</p><ul><li>Market value: the price that an asset can currently be bought or sold in the market</li><li>Intrinsic value: the value if an investor completely understand the asset’s investment characteristics</li><li>In an informationally efficient market, asset’s market value <strong>reflect new information rationally and quickly</strong>. Prices only react to new information and unexpected information(市场价值能很好的反应内在价值MV=IV,因为所有信息都被市场价值考虑以内)</li><li>Passive investment(following $\beta$) is preferred in effective market due to lower transaction cost as market value $\approx$ Intrinsic value in effective market. There is less fluctuation so there is very little abnormal excess return($\alpha$).</li><li>Active investment(following $\alpha$) is preferred in ineffective market as market value $\neq$ Intrinsic value so there is a lot of abnormal excess return</li><li>Factors affecting market efficiency:<ul><li>The lager number of participants in the market, the more effective</li><li>Information availability</li><li>Limits of trading: if arbitrage, shorting-selling is not allowed, the market will be less effective</li><li>Transaction cost and information acquisition cost: high cost will make market less effective</li></ul></li></ul></li><li><p>Forms of market efficiency:</p><ul><li><p>Weak-form efficient market hypothesis(弱势有效市场假设):</p><ul><li>Market prices reflect <strong>all historical price and trading volume information</strong></li><li>Technical analysis: use historical trading information to identify recurring patterns to predict future(用历史数据推测未来)</li><li><strong>Investor cannot consistently earn abnormal profit($\alpha$) using technical analysis</strong> as current prices already reflected all historical information. Future prices are only related to future information has nothing to do with historical information.</li></ul></li><li><p>Semi-strong form efficient market hypothesis:</p><ul><li>Market prices reflect <strong>all publicly known and available information</strong>(including historical price and trading volume information)</li><li>Fundamental analysis: use publicly available information to estimate intrinsic value of the asset</li><li><strong>Investor cannot consistently earn abnormal profit($\alpha$) using fundamental analysis</strong> as current prices already reflected all publicly available information. Future prices are only related to new public information has nothing to do with historical information.</li><li>If a market is semi-strong from efficient, it must be weak-form efficient.</li></ul></li><li><p>Strong-form efficient market hypothesis:</p><ul><li>Market prices reflect <strong>both publicly and privately information</strong></li><li><strong>Investor cannot consistently earn abnormal profit($\alpha$) from trading on private information</strong> as current prices already reflected all publicly and privately available information. Future prices are only related to new information has nothing to do with historical private or public information.</li><li>If a market is strong-from efficient, it must be semi-strong form efficient and weak-form efficient and </li></ul></li><li><p>Summary:</p><table><thead><tr><th></th><th>Past market information</th><th>All public information</th><th>Public and private  information</th></tr></thead><tbody><tr><td>Weak-form</td><td>Yes</td><td></td><td></td></tr><tr><td>Semi-strong form</td><td>Yes</td><td>Yes</td><td></td></tr><tr><td>Strong form</td><td>Yes</td><td>Yes</td><td>Yes</td></tr></tbody></table></li></ul></li><li><p>Roles for portfolio manager in efficient market(如果市场已经strong-form efficient了PM仍是有用的):</p><ul><li>Establish portfolio risk/return objectives(提供风险,收益管理方面的建议)</li><li>Portfolio diversification(资产分散化管理)</li><li>Implement asset allocation based risk/return objectives(资产配置)</li><li>Tax minimization</li></ul></li><li><p>Market anomalies(市场异常):</p><ul><li><p>Definition: a change in market price that <strong>cannot be linked to</strong> current relevant information or release of new information </p></li><li><p>Time-series anomalies(跟时间有关的异常):</p><ul><li>January effect(年初效应): stock return in January is significantly higher than the rest of the year. This is due to tax-loss selling(年末许多投资者会低价出售一些亏钱的资产用来抵税,一月在重新买入,过多买入抬高股价) or window dressing(年末对冲基金公布收益,会先把亏钱的股票卖掉来使自己收益变得更好看,年初重新买入,过多买入抬高股价)</li><li>Turn-of-the-month effect(月末效应): returns tend to be higher on the last trading day of the month and first three trading days of the next month</li><li>Day-of-the-week effect: returns on Monday is lower than the other four days</li><li>Weekend effect: return on weekends is low than weekdays</li><li>Holiday effect: return in the day before market holiday tends to be higher</li><li>Market momentum: 一个股票涨,买的投资者更多,涨的更狠,反之亦然</li><li>Overreaction: stock prices will be inflated(depressed) for companies releasing good(bad) information(面对新消息反应过度)</li><li><strong>一个市场若存在time-series anomalies则还没有达到weak efficient market因为time series analysis是有效的</strong></li></ul></li><li><p>Cross-sectional anomalies:</p><ul><li><p>Size effect: small-cap stocks tend to have better performance than large-cap stocks on a risk-adjusted basis</p></li><li><p>Value effect: value stock(low P/E ratio) tends to have better performance than growth(high P/E ratio) stocks</p></li><li><p>Summary:</p></li><li><table><thead><tr><th></th><th>Value</th><th>Growth</th></tr></thead><tbody><tr><td>Large-cap</td><td>Large-cap value</td><td><strong>Large-cap growth(Worst)</strong></td></tr><tr><td>Small-cap</td><td><strong>Small-cap value(Best)</strong></td><td>Small-cap growth</td></tr></tbody></table></li><li><p><strong>一个市场若存在cross-sectional anomalies则还没有达到semi-strong efficient market因为fundamental analysis是有效的</strong></p></li></ul></li><li><p>Other anomalies:</p><ul><li>Closed-end fund discounts: market value of closed-end fund is less than NAV</li><li>Earning surprise: market reaction to unexpected earnings of a company tend to be slow</li><li>Initial public offering: investors able to buy IPO shares tend to earn abnormal profits($\alpha$)</li><li>Economics fundamentals: stock return is related to economics fundamentals(股价和经济基本面紧密相关)</li></ul></li></ul></li><li><p>Behavioral finance(行为金融学):</p><ul><li>Definition: examines investor behavior and how this behavior affects the financial market</li><li>Loss aversion(损失厌恶): <ul><li>Investors dislike losses more than they like comparable gains(如果A没投资,B先赚100后亏100,他们两个人净利润都是0,但B会比A更难受由于loss aversion)</li><li>Loss aversion leads to overreaction anomaly(过度反应异常)</li><li>Loss aversion is <strong>not rational</strong></li></ul></li><li>Risk aversion: if two portfolios have the same expected return, investor with risk aversion tend to pick the one with a smaller standard deviation. Risk aversion is a personal preference and <strong>it is rational</strong>.</li><li>Overconfidence: investors place too much confidence on their ability to process information about security which leads to mispricing</li><li>Representativeness: investors assume good companies are good investment choice</li><li>Gambler’s fallacy(赌徒谬论): recent outcomes don’t affect future probabilities of the same event.</li><li>Mental accounting: investors keep track of gains and losses for different investments in separate mental accounts rather than viewing as a whole portfolio</li><li>Conservatism: investors are slow to react to changes</li><li>Disposition effect(处置效应): investors try to avoid realized loss(不愿意割肉)</li><li>Information cascades(信息瀑布): transmission of information from those acting quickly and their decision affects other investors</li><li>Herding behavior(羊群效应): trading occurs in clusters(聚堆) and is not necessarily driven by information(散户没理由的聚堆买股票) </li></ul></li></ol><h2 id="Overview-of-equity-securities"><a href="#Overview-of-equity-securities" class="headerlink" title="Overview of equity securities"></a>Overview of equity securities</h2><ol><li>Common shares:<ul><li>Represent <strong>ownership</strong> interest in a company</li><li>Residual claim on company’s net asset(<strong>after repaying debt and preferred share</strong>) in liquidation(破产清算时,偿还完债务和优先股股东的净资产归普通股股东)</li><li>The company has no contractually obligation in terms of paying dividends</li><li>Ordinary shareholders participate in the governance process through <strong>voting rights</strong></li><li>Callable common shares: giving the issuing company the option to <strong>buy back shares from investors at a predetermined call price</strong>(对公司有利,因为给了股票增长上限)</li><li>Puttable common shares: giving investors the option to <strong>sell their share back to the issuing company at a predetermined put price</strong>(对投资者有利,因为给了股票下跌下限)</li><li>Risk: puttable preference share &lt; preference share &lt; callable preference share &lt; puttable common share &lt; common share &lt; callable common share</li></ul></li><li>Preference share:<ul><li>Rank above common shares in terms of dividends payment and distribution of the company’s net asset upon liquidation</li><li><strong>Dividend is perpetual and dividend rate is fixed</strong></li><li>The company has no contractually obligation in terms of paying dividends(如果实在经营不善, 优先股股息也可以不付,但如果付了普通股的股息就必须付优先股的股息)</li><li>No voting right</li><li>Cumulative preference shares: unpaid preference dividends in previous periods must be paid in full before paying ordinary dividends</li><li>Participating preference shares: giving preference shareholders the chance to <strong>receive additional dividends</strong> if the company’s profit exceeds a pre-specified level</li><li>Convertible preference shares: <ul><li>Preference shareholders can convert their share into a specified number of ordinary shares</li><li>Convertible preference share is less volatile than ordinary share</li></ul></li></ul></li><li>Voting rights:<ul><li>Proxy voting: assigned a party to vote on behalf of a shareholder</li><li>Statutory voting(法定投票): each voting represents one vote, good for large shareholders</li><li>Cumulative voting: total voting rights = number of shares owned $\times$ number of options, good for small shareholders</li><li>Example: large shareholder owns 600 shares; small shareholder owns 400 shares<ul><li>The company is electing 3 directors from 5 candidates</li><li>Statutory voting: large shareholder have 600 votes and small shareholder have 400 votes</li><li>Cumulative voting: large shareholder have 3 $\times$ 600 = 1800 votes and small shareholder have 3 $\times$ 400 = 1200 votes</li></ul></li><li>Companies may issue shares with same ownership but different voting rights(AB股;同股不同权)</li></ul></li><li>Private equity securities:<ul><li>Not publicly traded in the secondary market and less transparency</li><li>Greater ability to <strong>focus on long-term goals</strong> as there is no public pressure on short-term results</li><li>Greater return for investors once the firm goes public traded</li><li>Types of private equity:<ul><li>Venture capital: invest in early stage company</li><li>Leveraged buyout(LBO): small company uses debt to acquire larger firms</li><li>Private investment in public equity(PIPE): a public company quickly sell ownership to private investors</li></ul></li></ul></li><li>Depository receipts(DR;存托凭证):<ul><li>Represent ownership of a foreign company</li><li>Depository bank buys ordinary shares of a foreign company and deposit these shares abroad. The depository bank then issues equal number of DR at the home country in local currency. Investor who buys DR is equivalent to owning the share of a foreign company</li><li>Sponsored DR: <strong>foreign company has a direct involvement of issuance of DR</strong> and investor who buys DR has the <strong>same right</strong> as direct owner of ordinary share</li><li>Unsponsored DR: depository bank bought foreign share in the secondary market and <strong>foreign company has no direct involvement</strong>. Investor who buys DR has right to receive dividends but <strong>no voting right</strong> which is held by depository bank(issuer of DR)</li><li>Types of DR:<ul><li>Global depository receipts: issued outside the company’s home country and outside US</li><li>American depository receipts: issued in US and traded like common share(非美国公司在美国上市均需要采取发行ADR的方式)</li><li>Global registered shares: common shares that are traded on stock exchanges in different countries in different currencies</li><li>Basket of listed depository receipts: similar to ETF, an investor may use a list of DR to exchange a basket of listed depository receipts and traded it in exchange</li></ul></li></ul></li><li>Roles of equity issuance:<ul><li>Make acquisition</li><li>Provide option based incentive(股票期权激励) to employees</li><li>Finance company’s operating activities</li></ul></li><li>Management actions can directly affect book value of the firm but they can only indirectly affect the market price</li></ol><h2 id="Introduction-to-industry-and-company-analysis"><a href="#Introduction-to-industry-and-company-analysis" class="headerlink" title="Introduction to industry and company analysis"></a>Introduction to industry and company analysis</h2><ol><li><p>Uses of industry analysis:</p><ul><li>Understanding business environment</li><li>Identify active investment opportunity</li><li>Portfolio performance attribution(对组合表现进行分析)</li></ul></li><li><p>Company classification:</p><ul><li><p>Product or services supplied</p><ul><li>A group of company offering similar products and services</li><li>Usually have four layers(由大到小): sector(板块), industry(行业), company(公司)</li></ul></li><li><p>Business cycle sensitivity:</p><ul><li><p>A group of company with similar relative sensitivity to the business cycle(商业周期对公司影响大体类似)</p></li><li><p>Cyclical company: <strong>strong correlated with business cycle(波动很大)</strong></p></li><li><p>Non-cyclical company: <strong>independent of the business cycle(几乎没有波动)</strong></p><p>Non-cyclical companies are normally defensive(provide good or service with stable demand) or growth(demand of the good of service is a lot greater than supply)</p></li></ul></li><li><p>Statistical similarities:</p><ul><li>Relatively high correlation of past securities returns</li><li>Limitation: sometimes result in non-intuitive(不直观的) groups; composition of each group is constantly changing; No guarantee the past correlation will continue in the future; carry inherent dangers of all statistical methods(统计学固有的缺陷)</li></ul></li></ul></li><li><p>Classification system supplier:</p><ul><li>Commercial industry classification system(商业公司的收费数据库)<ul><li>More specific and detailed classification and transparent</li><li>Update quite frequently</li></ul></li><li>Governmental classification system(政府的免费数据库)<ul><li>More broad classification and do not disclose specific information</li><li>Very slow in updating</li></ul></li></ul></li><li><p>Peer group(分类以后属于同一组的公司互为peer group):</p><ul><li>Definition: a group of companies engaged in similar business and performance is influenced by closely related factors</li><li>Steps in setting up peer group:<ul><li>Identity companies in the same industry from classification system</li><li>Add major competitors stated in financial reports</li><li>Review industry publications and include comparable companies</li><li>Confirm companies within the same peer group have similar business activities and cost structure</li></ul></li></ul></li><li><p>Porter’s five forces model(行业内部竞争因素):</p><ul><li>Rivalry among existing competitors(同行竞争)</li><li>Threat of new entrants(新进入者萎谢)</li><li>Threat of substitute products(替代产品威胁)</li><li>Bargaining power of buyers(买家议价能力)</li><li>Bargaining power of suppliers(供应商议价能力)</li></ul><p>这5点均是越低对企业越有利</p></li><li><p>Barrier of entry:</p><ul><li>Determined by capital requirements, intellectual capital(技术资本) and regulations(监管;中国烟草)</li><li>Low barriers lead to more competition and little pricing power(定价力:敢不敢定高价)</li><li>High barrier don’t guarantee large pricing power. This is because:<ul><li>High price will lead to less customers</li><li>Large capital requirements lead to high barrier to exit. Those companies tend to be overcapacity(供过于求)</li></ul></li></ul></li><li><p>Industry concentration(行业集中度):</p><ul><li>Fragmental industries(碎片化行业) tend to be highly competitive</li><li>Concentrated industries do not guarantee pricing power as relative market share has a greater impact on pricing power(行业龙头有更强定价力)</li></ul></li><li><p>Market share stability:</p><ul><li>Affect by barriers of entry, frequency of new product introductions and product differentiation(产品差异化大, market share更稳定)</li><li>Stable market share indicates a less competitive industry vice versa</li></ul></li><li><p>Industry capacity(行业产能):</p><ul><li>Under-capacity leads to high pricing power as demand exceeds supply</li><li>Over-capacity leads to price cutting as supply exceeds demand</li><li>Capacity is fixed for short-term but variable in the long-term(产能需要时间改变)</li><li>Physical capacity: hard to re-deploy(改变用途) e.g.炼铁工厂, 炼油厂</li><li>Non-physical capacity: easy to re-deploy e.g. human capital and financial capital</li></ul></li><li><p>External factors affecting a industry(影响行业外部因素):</p><ul><li>Macroeconomics climate</li><li>Technology innovation</li><li>Demographic influence(人口结构改变) e.g.老龄化使医疗行业发展更好</li><li>Governmental influence</li><li>Social influence(社会习惯)</li></ul></li><li><p>Industry life cycle:</p><ul><li><img src="https://i.loli.net/2020/08/06/WFh1GEZB7V8bR9X.png" alt="Industry_life_cycle.png"></li><li>Embryonic stage(初期阶段):<ul><li>Industry is just beginning to develop</li><li><strong>Slow growth rate in demand</strong> as customers are unfamiliar with the industry </li><li><strong>High prices</strong>: not yet achieves economics of scale and substantial initial investment is needed</li><li>Risk of failure is high</li></ul></li><li>Growth stage(增长阶段, if survived in the growth stage):<ul><li><strong>Rapid growth in demand</strong>: pushed by large amount of new customers</li><li><strong>Falling prices</strong>: economics of scale achieved</li><li><strong>Improved profitability</strong>: due to higher demand and economics of scale</li><li><strong>Relatively low competition</strong>: rapid growth in demand allows company to grow without the need to capture market from competitors(Demand太多supply不足以填补市场所以不需要从竞争对手手中抢夺客户)</li><li><strong>Threat from new entrant is highest</strong> as barrier to entry is not high enough</li></ul></li><li>Shakeout stage(震荡阶段):<ul><li><strong>Slowing growth in demand</strong>: demand approaches market saturation</li><li><strong>Intense competition</strong>: growth depends on market share gains(必须从竞争对手手中抢份额来保证增速)</li><li><strong>Over-capacity</strong>: company’s investment exceeds demand growth</li><li><strong>Declining profitability</strong>: over-capacity so supply exceeds demand</li><li><strong>Increasing failure</strong></li></ul></li><li>Mature stage(成熟阶段):<ul><li><strong>Littre or no growth in demand</strong>: market is saturated and growth is limited to replacement demand and population expansion</li><li><strong>Increase consolidation(并购)</strong>: evolves to oligopoly(进化为寡头) due to M&amp;A</li><li><strong>High barrier to entry</strong>: surviving companies have brand loyalty and effective cost structure</li><li><strong>Stable pricing</strong>: surviving companies try to avoid price wars but periodic wars do occur</li><li>Companies with superior products grow faster than industry average</li></ul></li><li>Declined stage(下降阶段):<ul><li><strong>Negative growth in demand</strong>: decrease in demand due to technological substitution, social changes and global competition</li><li>Decline prices: excess capacity and price wars often happen</li><li>Consolidation: weaker companies exit, merge or re-deploy capital into different industries</li></ul></li><li>Limitation of industry cycle:<ul><li>Evolution of industries don’t always follow a predictable pattern</li><li>External factors will affect the length of each stage or to be skipped</li><li>Life-cycle model tends to be most useful in analyzing during periods of stability</li></ul></li></ul></li><li><p>Firm’s competition strategy:</p><ul><li>Cost leadership: lowest cost of production; lowest selling price; sell enough volume to earn return</li><li>Product or service differentiation: distinctive in terms of type, feature, quality etc. to achieve price premium</li></ul></li></ol><h2 id="Equity-valuation-concepts-and-basic-tools"><a href="#Equity-valuation-concepts-and-basic-tools" class="headerlink" title="Equity valuation: concepts and basic tools"></a>Equity valuation: concepts and basic tools</h2><ol><li><p>Valuation basics:</p><ul><li>Present value models(absolute valuation):<ul><li>Intrinsic value of a security is the present value of future cash flow expected to be received from the security</li><li>Discount cash flow model(DCF)</li><li>Dividends discount model(DDM)</li><li>Free cash flow to equity(FCFE)</li></ul></li><li>Multiplier models(Market multiple models; relative valuation)<ul><li>Share price multiples</li><li>Enterprise value multiples</li></ul></li><li>Asset-based valuation models: Intrinsic value of equity = asset - liability - preference share</li><li>Undervalued: intrinsic value &gt; market value</li><li>Fair valued: intrinsic value = market value  P.S. if IV$\approx$ MV e.g. IV =10, MV = 9.8, it is also fair valued</li><li>Overvalued: intrinsic value &lt; market value</li></ul></li><li><p>Dividends:</p><ul><li><p>Cash dividends: distribute cash to shareholders, typically paid out regularly at known interval</p></li><li><p>Special dividends: not regularly paid to shareholders or as a supplement to cash dividends</p></li><li><p>Stock split(拆股): increase the number of outstanding share with a decrease in share price(e.g. 2-for-1 split; 每一股拆成两股)</p></li><li><p>Reverse stock split: reduce the number of outstanding share with a increase in share price(e.g.1-for-20 reverse stock split; 20股合成1股)</p></li><li><p>Share repurchase:</p><ul><li><p>A transaction that a company uses cash to buy back its own shares</p></li><li><p>Share repurchase is equivalent to cash dividends.</p><p>For example, 10 dollar per share, 1000 share outstanding, equity = 10000</p><p>Issue 1 dollar dividends per share, remaining equity after dividends = 9000</p><p>Repurchase 10% of outstanding shares, remaining equity after repurchase = 9000</p><p>1 dollar dividends per share = 10% repurchase</p></li></ul></li></ul></li><li><p>Key dates:</p><ul><li>Declaration date: the date that the corporate issues a statement declaring a specific dividends</li><li>Ex-dividend date: the first day that share trades without dividends(在这一天或者这一天以后买股票不会收到dividends)</li><li>Holder-of-record date: the date that a shareholder listed in the corporate’s record will deem to have ownership of the upcoming dividends</li><li>Payment date: the date that corporates actually mails out dividends payment</li><li><img src="https://i.loli.net/2020/08/06/HolaxS7eXrCuJF1.png" alt="Dividends_issuance_timetable.png"></li></ul></li><li><p>Dividends discount model:</p><ul><li><p>DDM is the application of the Discount cash flow method</p></li><li><p>Intrinsic value = $\sum_{t=1}^{\infty} \frac{D_{t}}{(1+r)^{t}}$</p><ul><li>Assume the investor is holding the share forever</li><li>$D_{t}$: dividend in year t</li><li>CAPM method is used to find $r$ which is also the minimum require rate of return of investors</li></ul></li><li><p>$D_{t}$ is very hard to predict so we set 4 assumptions to simplify the problem.</p></li><li><p>N holding period:</p><ul><li><p>Intrinsic value$=\frac{D_{1}}{(1+r)^{1}}+\cdots+\frac{D_{n}}{(1+r)^{n}}+\frac{P_{n}}{(1+r)^{n}}$</p><p>Assume the investor will sell the share in year n</p><p>$P_{n}$: the sell price after n years</p></li></ul></li><li><p>Gordan growth model(GGM):</p><ul><li><p>Intrinsic value = $\frac{D_{1}}{(1+r)^{1}}+\frac{D_{2}}{(1+r)^{2}}+\frac{D_{3}}{(1+r)^{3}}+……$ = $\frac{D_{1}}{r-g}=\frac{D_{0}(1+g)}{r-g}$</p><p>Formula is derived using geometric series</p><p>Assume the investor is holding the share forever</p><p>Assume dividends grow at a constant rate so $D_{1}=D_{0}(1+g)$; $D_{2}=D_{1}(1+g)=D_{0}(1+g)^{2}$</p><p>Assume dividends growth rate is less than discounting rate(g&lt;r)</p><p>$g = ROE\times$ Retention rate​</p><p>Retention rate = 1- dividends payout ratio</p><p>ROE = $\frac{NI}{Equity}$</p></li><li><p>Derive: $g = ROE\times$ Retention rate:</p><p>$\Delta NI \cdot Payout\ ratio = \Delta Dividends$</p><p>$\frac{\Delta NI}{NI}= \frac {\Delta Dividends}{Payout\ ratio\times\ Net\ income}$</p><p>$\frac{\Delta NI}{NI}=\frac{\Delta Dividends}{Dividends}=g$</p><hr><p>$\Delta NI=\Delta Equity \times ROE$</p><p>$\frac{\Delta NI}{NI}=\frac{\Delta Equity}{NI}\times \frac{NI}{Equity}$</p><p>$\frac{\Delta NI}{NI}=\frac{\Delta Equity}{Equity}=\frac{\Delta Dividends}{Dividends}=g$</p><hr><p>$\Delta Equity=NI\times$ Retention rate(留在公司的利润以retained earning的方式使Equity增加) </p><p>$\frac{\Delta Equity}{Equity}=\frac{NI}{E}\times$Retention rate</p><p>$g = ROE\times$ Retention rate​(VERY IMPORTANT RESULT)</p></li></ul></li><li><p>Preferred stock valuation:</p><ul><li>Intrinsic value = $\frac{D}{r}$</li><li>It is a special case of GGM with g=0(preference dividend rate doesn’t change)</li></ul></li><li><p>Two-stage DDM models:</p><ul><li><p>Assume the company experiences a initial and finite period of high growth followed by a infinite period of unchanged low growth(刚开始几期增长快,后面无穷期增长慢)</p></li><li><p>Intrinsic value $=(\sum_{t=1}^{n} \frac{D_{0}\left(1+g_{h}\right)^{t}}{(1+r)^{t}})+\frac{V_{n}}{(1+r)^{n}}$</p><p>where $V_{n}=\frac{D_{n+1}}{r-g_{l}}$</p></li><li><p>$\sum_{t=1}^{n} \frac{D_{0}\left(1+g_{h}\right)^{t}}{(1+r)^{t}}$ : discount dividends of the first few period with high growth rate</p></li><li><p>$V_{n}=\frac{D_{n+1}}{r-g_{l}}$: PV of future perpetual dividends low growth rate(GGM) <strong>on year n</strong></p></li><li><p>$\frac{V_{n}}{(1+r)^{n}}$: PV of future perpetual dividends low growth rate(GGM) on year 0(把第n年的价值贴现回第0年)</p></li></ul></li></ul></li><li><p>Free cash flow to equity(FCFE):</p><ul><li>FCFE is the application of the Discount cash flow method</li><li>FCFE is measure of <strong>dividends-paying ability</strong>. It is suitable for non-dividend-paying stock as we cannot use DDM if the company has the ability to pay dividends but not willing to pay dividends</li><li>FCFE = net income + non-cash expense - investment in working capital - fixed capital investments + net borrowing</li><li>Intrinsic value = $\sum_{t=1}^{\infty} \frac{F C F E_{t}}{(1+r)^{t}}$<ul><li>这里假设FCFE全被作为股息用于分红</li><li>$FCFE_{t}$: free cash flow to equity in year t</li><li>CAPM method is used to find $r$ which is also the minimum require rate of return of investors</li></ul></li></ul></li><li><p>Multiplier model:</p><ul><li><p>Price multiple:</p><ul><li>P/E ratio(price earning ratio;市盈率) = $\frac{share\ price}{EPS}$</li><li>P/B ratio(price to book ratio;市净率) = $\frac{share\ price}{book\ value\ of\ equity\ per\ share}$</li><li>P/S ratio(price to sale ratio;市销率) = $\frac{share\ price}{Revenue\ per\ share}$</li><li>P/CF ratio(price to cash flow ratio;市现率) = $\frac{share\ price}{CFO\ or\ FCFE\ per\ share}$</li><li>All these ratios are the smaller the better for a stock</li></ul></li><li><p>Trailing price multiples:</p><ul><li><p>Use trailing or history data to find price multiple</p></li><li><p>Example: </p><p>current share price on 1.1.2020 = 10 dollar </p><p>EPS in 2019 = 1 dollar</p><p>Trailing P/E ratio = 10</p></li></ul></li><li><p>Leading price multiples:</p><ul><li><p>Use leading or forward data to find price multiple</p></li><li><p>Example:</p><p>current share price on 1.4.2020 = 10 dollar </p><p>EPS in the first quarter of 2020 = 0.2 dollar</p><p>Predicted EPS in 2020 = 0.8 dollar</p><p>Trailing P/E ratio = 12.5</p></li><li><p>Example:</p><p>current share price on 1.7.2020 = 10 dollar </p><p>EPS in the first quarter of 2020 = 0.2 dollar</p><p>EPS in the second quarter of 2020 = 0.4 dollar</p><p>Predicted EPS in 2020 = (0.2+0.4)$\times$2= 1.2 dollar</p><p>Trailing P/E ratio = 8.33</p></li></ul></li><li><p>P/E ratio based on fundamentals(Justified leading P/E ratio):</p><ul><li><p>Assume intrinsic value of the stock = market value of the stock</p><p>$MV_{0}$ = $IV_{0}$ = $P_{0}$ = $\frac{D_{1}}{r-g}$</p></li><li><p>Justified P/E ratio = $\frac{P_{0}}{E_{1}}=\frac{\frac{D_{1}}{E_{1}}}{r-g}=\frac{Dividends\ payout\ ratio}{r-g}$</p></li><li><p>P/E ratio is positively proportional to dividends growth rate(g;分母随g的增大而减小,分式增大)</p></li><li><p>P/E ratio is inversely proportional to discounting rate(r;分母随r的增大而增大,分式变小)</p></li><li><p>$g = ROE\times (1-Dividends\ payout\ ratio)$ as dividends payout ratio increase, g decrease. The relationship between P/E ratio and dividends payout ratio is ambiguous(分子变大,分母也变大) </p></li></ul></li><li><p>Advantage of price multiple:</p><ul><li>Allow relative comparison both cross-sectional(同一时间不同行业) and in time series(同一行业不同时间)</li><li>Popular tool for individual investors</li></ul></li><li><p>Disadvantage of price multiple:</p><ul><li>May generate a contradict conclusion with discount cash flow methods</li><li>Different accounting standards will affect results</li><li>The multiples for cyclic companies(affect by business cycle hugely) will be highly affected by the economic climates</li></ul></li></ul></li><li><p>Method of comparable(relative valuation):</p><ul><li>Compare a price multiple to a benchmark to find out whether an asset is fairly valued, undervalued or overvalued</li><li>The choice of benchmark includes: price multiple of a closely similar stock, average price multiple of the industry</li></ul></li><li><p>Enterprise multiple:</p><ul><li><p>Enterprise value:</p><ul><li><p>Enterprise value = <strong>MV</strong> of common stock + <strong>MV</strong> of preferred stock + <strong>MV</strong> of debt - cash and cash equivalents</p><p>USE MARKET VALUE!!!!!</p></li><li><p>In other words, enterprise value = Liability + Equity - cash</p></li><li><p>It is viewed as the cost of takeover. We take away cash as there is no point to takeover cash using cash(收购企业时没有必要把对方现金也收购了)</p></li></ul></li><li><p>Enterprise value multiple = $\frac{Enterprise\ value}{EBITDA}$</p><p>EBITDA is used to remove the effect of capital structure on income</p></li><li><p>Advantage: compare companies with different capital structures</p></li></ul></li><li><p>Asset-based valuation model:</p><ul><li>Market value of equity = market value of asset - market value of liability</li><li>Asset-based valuation is suitable when:<ul><li>Most of the company’s asset is tangible</li><li>There is a existing and clear market value of asset and liability</li><li><strong>Private firms that are not publicly traded so price multiples cannot be used</strong></li><li>The company is in liquidation(破产清算) so DCF methods cannot be used, there will be no future  dividends</li></ul></li><li>Asset-based valuation is not suitable when:<ul><li>The company has major intangible assets off the book(e.g. Goodwill, leadership(马云)). Using asset-based valuation model will under-estimate the company’s value but provides a “floor value”(market price should not be anywhere lower than the floor value)</li></ul></li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;CFA-Equity-investment-Notes&quot;&gt;&lt;a href=&quot;#CFA-Equity-investment-Notes&quot; class=&quot;headerlink&quot; title=&quot;CFA Equity investment Notes&quot;&gt;&lt;/a&gt;CFA Equity investment Notes&lt;/h1&gt;&lt;h2 id=&quot;Market-organization-and-structure&quot;&gt;&lt;a href=&quot;#Market-organization-and-structure&quot; class=&quot;headerlink&quot; title=&quot;Market organization and structure&quot;&gt;&lt;/a&gt;Market organization and structure&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Financial market function:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Achieving entities’(corporates and individuals) needs:&lt;ul&gt;
&lt;li&gt;Saving and borrowing(债权融资)&lt;/li&gt;
&lt;li&gt;Raising entity capital(股权融资)&lt;/li&gt;
&lt;li&gt;Managing risk(derivatives, insurances etc.)&lt;/li&gt;
&lt;li&gt;Exchange assets(currency exchange etc.)&lt;/li&gt;
&lt;li&gt;Information-motivated trading: arbitrage by valuating the intrinsic value(IV) of an asset and identify whether it is overvalued(IV&amp;lt;market value; short position) or undervalued(IV&amp;gt;market value; long position)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Determining equilibrium rates of return(均衡利率): the rate that equates the supply of fund to the demand of fund(当资金的供给等于需求时的利率)&lt;/li&gt;
&lt;li&gt;Capital allocation efficiency(资产合理配置): allocate capital to the most productive places(e.g. highest Sharpe ratio)&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Finance" scheme="https://yuxuanliu.tech/categories/Finance/"/>
    
    
      <category term="CFA" scheme="https://yuxuanliu.tech/tags/CFA/"/>
    
      <category term="Finance" scheme="https://yuxuanliu.tech/tags/Finance/"/>
    
  </entry>
  
  <entry>
    <title>CFA Corporate Finance Notes</title>
    <link href="https://yuxuanliu.tech/CFA_Corporate_Finance/"/>
    <id>https://yuxuanliu.tech/CFA_Corporate_Finance/</id>
    <published>2020-07-21T21:20:16.000Z</published>
    <updated>2020-07-21T14:29:42.491Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CFA-Corporate-Finance-Notes"><a href="#CFA-Corporate-Finance-Notes" class="headerlink" title="CFA Corporate Finance Notes"></a>CFA Corporate Finance Notes</h1><h2 id="Capital-Budgeting"><a href="#Capital-Budgeting" class="headerlink" title="Capital Budgeting"></a>Capital Budgeting</h2><ol><li><p>Capital project: projects where cash flow to the firm will be received over a period more than one year</p></li><li><p>Capital budgeting: </p><ul><li>Definition: process company use for decision making on capital projects(选择最合适capital project的流程)</li><li>Key steps in capital budgeting process:<ul><li>Step1: Generating ideas</li><li>Step2: Analyzing individual project proposals(analyze <strong>after-tax increment cash flow</strong> of a project)</li><li>Step3: Planning the capital budget for the firm(choose project which is most suitable)</li><li>Step4: Monitoring decisions and conducting a post-audit after the project is finished</li></ul></li></ul></li><li><p>Types of ideas(Step1):</p><ul><li>Replacement projects: <ul><li>Projects to maintain the business(是否保留已有生意)</li><li>Projects for cost reduction(是否对已有生意进行一次性投资来降低variable cost)</li></ul></li><li>Expansion projects: 是否复制已有的生意</li><li>New products or services: 是否开展新生意</li><li>Mandatory projects: projects to meet legal requirements</li><li>Other projects: R&amp;D projects etc.</li></ul><a id="more"></a></li><li><p>Principles of capital budgeting(Step2,哪些cash outflow要被考虑):</p><ul><li><p>Step2 aims to find after tax incremental cash flows(因为执行这个项目而产生的税后现金流增加)</p></li><li><p>Include opportunity cost as part of the cash outflow of the new project</p></li><li><p>Include Externalities(外部性) as part of the outflow/inflow of the new project</p><ul><li>Cannibalization(利益侵蚀): cash loss in other projects due to this new project(outflow)</li><li>Synergy(协同效应): extra cash generated in other projects due to this new project(inflow)</li></ul></li><li><p>Do not include sunk cost as part of the cash outflow of the new project</p><p>Sunk cost(沉默成本): cost occurs before the project begin(e.g. consulting etc.) or cost will still occur even though we don’t take the project(在项目开始前产生的费用且无论项目进行或不进行均产生的花费)</p></li><li><p>Don’t include interest cost as it is already considered when discounting future cash</p></li></ul></li><li><p>Conventional cash flow: cash flow changes sign only once</p><p>Unconventional cash flow: cash flow changes sign multiple times</p></li><li><p>Valuation of a single project(Step2):</p><ul><li>Net present value(NPV):<ul><li>NPV =  $CF_{0}+\frac{CF_{1}}{(1+k)}+\frac{CF_{2}}{(1+k)^{2}}……+\frac{CF_{n}}{(1+k)^{n}}$</li></ul></li></ul></li></ol><ul><li><p>Decision rule: accept the project if NPV&gt;0</p><ul><li>Advantage: directly reflect the expected change in firm’s value</li></ul></li><li><p>Disadvantage: Ignore the size of $CF_{0}$. In other words, if two projects have the similar NPV but one has a very large $CF_{0}$. It is less preferable because it might be hard for company to put so much initial investment on a project at a time.</p><ul><li><p>Change is stock price = $\frac{NPV}{Number\ of\ shares}$</p></li><li><p>Internal rate of return(IRR): </p><ul><li>IRR is the discounting rate that makes the NPV = 0(Expected rate of return)</li><li>NPV = 0 = $CF_{0}+\frac{CF_{1}}{(1+IRR)}+\frac{CF_{2}}{(1+IRR)^{2}}……+\frac{CF_{n}}{(1+IRR)^{n}}$</li></ul></li><li><p>Decision rule: accept the project if IRR&gt; Cost of capital</p><ul><li>Advantage: reflect profitability</li><li>Disadvantage: might be multiple IRR or no IRR for non-conventional cash flow; assume every year’s discounting rate = IRR which is unlikely to be the case</li></ul></li><li><p>Payback period(PB):</p><ul><li><p>The number of years to recover the initial investment of the project</p></li><li><p>Payback period = A + $\frac{B}{C}$</p><p>A: the last period with a negative accumulated cash flow</p><p>B: the size of the accumulated cash flow at the end of period A</p><p>C: the size of cash flow during the period after A</p></li><li><p>No decision rule</p></li><li><p>Advantage: simple and reflect liquidity</p></li><li><p>Disadvantage: does not take into account time value of money; ignores cash flow after the payback period</p></li></ul></li><li><p>Discounted payback period:</p><ul><li><p>The number of years required for cumulative discounted cash flow to recover the initial investment of the project</p></li><li><p>Discounted payback period = A + $\frac{B}{C}$</p><p>A: the last period with a negative discounted accumulated cash flow</p><p>B: the size of the discounted accumulated cash flow at the end of period A</p><p>C: the size of the discounted flow during the period after A</p></li><li><p>No decision rule</p></li><li><p>Advantage: simple and reflect liquidity; take into account time value of money</p></li><li><p>Disadvantage: ignores cash flow after the payback period</p></li></ul></li><li><p>Profitability index(PI):</p><ul><li>Indicates the value that company received in exchange for one unit of initial investment</li></ul></li><li><p>Profitability index = $\frac{PV\ of\ future\ cash\ flow}{Initial \ investment(CF_{0})}$ = 1+$\frac{NPV}{Initial \ investment(CF_{0})}$</p><ul><li>Decision rule: accept the project if PI&gt;1</li><li>Advantage: measures profitability; shows the amount of value received per unit of initial investment</li></ul></li><li><p><strong>For a single project, NPV, IRR, PI always give the same accept/reject decision</strong></p><p>e.g. NPV&gt;0 is equivalent to IRR&gt;cost of capital and PI&gt;1</p></li></ul></li></ul><ol start="7"><li>Valuation of interacting projects(Step3, select the most suitable projects):<ul><li>Decision rules for mutual exclusive projects(只可以从一系列项目中选一个):<ul><li>NPV method: choose the one with the highest NPV</li><li>IRR method: choose the one with the highest IRR</li><li>PI method: choose the one with the highest PI</li></ul></li><li>NPV method and IRR method may conflict with each other because of:<ul><li>Pattern of the cash flow(explained below in NPV profile)</li><li>Different assumptions. NPV method assumes the discounting rate = cost of capital during the period. In other words, it can be different from year to year. However, IRR method assumes the discounting rate = IRR which is the same for every year. NPV is closer to the real-world so <strong>NPV method is always chosen when NPV method and IRR method conflicts with each other</strong>.</li></ul></li><li>NPV profile:<ul><li>Independent variable: discounting rate</li><li>Dependent variable: NPV of projects</li><li><img src="https://i.loli.net/2020/07/21/5CKbVSejMpxfd1A.jpg" alt="NPV_profile.jpg"></li><li>For a fixed cash flow, IRR is fixed while NPV of reduces with an increasing discounting rate</li><li>At crossover rate, NPV of project A = NPV of project B</li><li>Interactions with X axis give are IRR of projects</li><li>Interactions with X axis are undiscounted net cash flow</li><li><strong>If discounting rate&lt;crossover rate, NPV method and IRR method always give a conflicting result</strong></li><li><strong>If discounting rate&gt;crossover rate, NPV method and IRR method give the same result</strong></li></ul></li></ul></li></ol><h2 id="Cost-of-Capital"><a href="#Cost-of-Capital" class="headerlink" title="Cost of Capital"></a>Cost of Capital</h2><ol><li><p>Cost of capital: rate of return that supplier of capital requires or opportunity cost of funds for supplier of capital(used as the discounting rate of future cash)</p></li><li><p>Weighted average cost of capital(WACC):</p><ul><li><p>WACC is also referred as Marginal cost of capital(MCC)</p></li><li><p>Source of capital: debt, common(ordinary) equity, preferred stock</p></li><li><p>WACC is the required rate of return investor demands for the <strong>average risk</strong> of the company. It doesn’t represent risk of a specific project in the company</p></li><li><p>WACC = $w_{d}\times k_{d}\times(1-t)+w_{ps}\times k_{ps}+w_{ce}\times k_{ce}$</p><p>$w_{d},w_{ps},w_{ce}$: proportion of debt, preferred stock and common equity <strong>measured at market value(fair value)</strong></p><p>$k_{d}$: rate of return(marginal cost) of debt <strong>before tax</strong></p><p>$k_{ps}$: rate of return(marginal cost) of preferred stock</p><p>$k_{ce}$: : rate of return(marginal cost) of common equity</p><p>$t$: tax rate(Interest can act as <strong>tax shield</strong>)</p></li></ul></li><li><p>Estimate weights($w_{d},w_{ps},w_{ce}$) in WACC:</p><ul><li>If target capital structure(目标资本结构) is available, use this target capital structure directly</li><li>If target capital structure is not available use:<ul><li>Current capital structure instead</li><li>Infer from historical trend in capital structure</li><li>Use averages of comparable companies’ capital structure</li></ul></li></ul></li><li><p>Application of WACC:</p><ul><li><p>Optimal capital budget:</p><ul><li><p>Marginal cost of capital(MCC) increases as the company raises more fund</p></li><li><p>Investment opportunity schedule(IOS): marginal return to a company’s investment</p><p>IOS generally decreases as the company investment more funds as the company will prioritize in investing high return project</p></li><li><p><img src="https://i.loli.net/2020/07/21/E4TCHldjKfIc5Jt.png" alt="Optimal_capital_budget.png"></p><p>When capital raised/investment &lt; Optimal capital budget, return(IOS)&gt;cost(MCC)</p><p>When capital raised/investment &gt; Optimal capital budget, return(IOS)&lt;cost(MCC)</p><p>There is an optimal point at optimal capital budget where return(IOS)=cost(MCC). The company is maximizing its profit at this point</p></li></ul></li><li><p>Representing a project’s risk using WACC:</p><ul><li>WACC is the required rate of return investor demands for the <strong>average risk</strong> of the company. It doesn’t represent risk of a specific project in the company</li><li>We might use WACC as the discounting rate of a specific project but it will be less accurate</li><li>If the project’s risk &gt; average risk, discount rate is underestimated, NPV is overestimated</li><li>If the project’s risk &lt; average risk, discount rate is overestimated, NPV is underestimated</li></ul></li></ul></li><li><p>Cost of debt(finding $k_{d}$):</p><ul><li>Yield to maturity approach(YTM非常类似于实际利率法摊销):<ul><li>$p_{0}= \frac{PMT}{(1+YTM)}+\frac{PMT}{(1+YTM)^{2}}+…….+\frac{PMT}{(1+YTM)^{n}}+\frac{Par}{(1+YTM)^{n}}$</li><li>PMT = Par value $\times$ coupon rate</li><li>In YTM approach, we must know $p_{0}$(fair value of the bond) in order to calculate YTM which is effectively $k_{d}$(cost of debt)</li><li>The after-tax true effective cost of debt = $k_{d}\times(1-t)$ as interest has the tax shield effect</li></ul></li><li>Debt-rating approach:<ul><li>When $p_{0}$(fair value of the bond) is not available, we use the rate of a comparable bond to estimate its $k_{d}$(cost of debt)</li><li>Comparable bond: bond with the same rating and similar maturities(到期日)</li><li>The after-tax true effective cost of debt = $k_{d}\times(1-t)$ as interest has the tax shield effect</li></ul></li></ul></li><li><p>Cost of preferred stock:</p><ul><li><p>Preferred stock has a fixed dividend rate($k_{ps}$)</p></li><li><p>$k_{ps}=\frac{Dividends\ per\ share}{preferred\ stock\ share\ price}$</p><p>Preferred stock share price is measured at fair value/market value</p></li><li><p>Dividends has no effect of tax shield</p></li></ul></li><li><p>Cost of common equity:</p><ul><li><p>Capital asset pricing model(CAPM):</p><ul><li><p>$k_{ce} = rf+\beta(E(R_{m})-rf)$</p><p>rf: risk-free rate</p><p>$\beta$: systemic risk of the <strong>firm’s stock</strong></p><p>$E(R_{m})$: expected return of the <strong>market</strong></p></li></ul></li><li><p>Dividend discount model(DDM):</p><ul><li><p>$k_{ce}=\frac{D_{1}}{P_{0}}+g$</p><p>$D_{1}$: next year’s dividend</p><p>$P_{0}$: current stock price</p><p>$g$: sustainable growth rate=Return of equity $\times$ retention ratio=Return of equity$\times$(1-payout ratio)</p></li><li><p>The DDM is under the assumption that annual dividend increases by $g$ % every year</p><p>e.g. $D_{1} = D_{0}(1+g%)$</p><p>where $D_{1}$ is next year’s dividend ; $D_{0}$ is this year’s dividend</p></li></ul></li><li><p>Bond yield plus risk premium method:</p><ul><li><p>$k_{ce} = k_{d}+risk\ premium$</p><p>$k_{d}$: before-tax cost of debt</p></li><li><p>Risk premium is measured using historical data between return of equity and return of debt</p></li></ul></li></ul></li><li><p>Measurement of $\beta$ in CAPM:</p><ul><li><p>Factors affecting $\beta$ of a company:</p><ul><li>Sales risk: uncertainty of revenue</li><li>Operating risk: fixed cost of operation</li><li>Financial risk: fixed cost of financing(debt interest and lease)</li></ul></li><li><p>For a public traded company:</p><ul><li>Market model regression can be used to find <strong>average $\beta$ of the company</strong></li><li>Return of the stock = $\alpha +\beta \times\ return\ of \ the \ market$</li></ul></li><li><p>For a non-public traded company or a project in a company:</p><ul><li><p>Market model regression approach only give <strong>average $\beta$ of a public traded company</strong></p></li><li><p>Pure-play method is used to find $\beta$ of a project or non-public traded company</p></li><li><p>Step1: Find $\beta_{comp,equity}$ of a comparable company</p><p>Comparable company: same industry, single line of business, similar business risk</p></li><li><p>Step2: Find $\beta_{comp,asset}$</p><p>$\beta_{comp,asset} = \frac{(1-t)D}{(1-t)D+E}\cdot \beta_{comp,debt}+\frac{E}{(1-t)D+E}\cdot \beta_{comp,equity}$</p><p>D: value of existing debt ; E: value of equity</p><p>We assume debt has no risk so $\beta_{comp,debt}$ = 0</p><p><strong>$\beta_{comp,asset} = \frac{E}{(1-t)D+E}\cdot \beta_{comp,equity}$</strong></p></li><li><p>Step3: a comparable company and the project(non-public traded company) have the same risk due to asset so $\beta_{comp,asset}=\beta_{project,asset}$</p></li><li><p>Step4: Find $\beta_{project,equity}$</p><p>$\beta_{project,asset} = \frac{(1-t)D’}{(1-t)D’+E’}\cdot \beta_{comp,debt}+\frac{E’}{(1-t)D’+E’}\cdot \beta_{comp,equity}$</p><p>Similarly, we assume debt has no risk so$\beta_{project,debt} = 0$</p><p>$\beta_{project,asset} = \frac{E’}{(1-t)D’+E’}\beta_{project,equity}$</p></li></ul></li></ul></li><li><p>CAPM in developing country:</p><ul><li><p>CAPM has a extra term(Country risk premium) for companies in developing country(只要公司在发展中国家就需要多加一项,无论这个公司是在做发达国家业务还是发展中国家业务)</p></li><li><p>$k_{ce} = rf + \beta \cdot(E(R_{m})-rf+CRP)$</p></li><li><p>CRP = sovereign yield spread $\times\frac{\sigma \ of\ equity\ index\ of\ developing\ country}{\sigma\ of\ sovereign\ bond\ market\ in\ terms\ of\ the\ developed\ country\ currency}$</p><p>Sovereign yield spread(主权利差) = interest rate of government bond in developing country - interest rate of government bond in developed country</p></li></ul></li><li><p>Break point of WACC(marginal cost of capital):</p><ul><li><p>In reality WACC increases with amount of capital raises. However, the curve is unlikely to be a smooth line. 因为融资是一笔一笔融的,对于一笔融资它的成本是固定的,下一笔会有一个上升</p></li><li><p><img src="https://i.loli.net/2020/07/21/P7tcSlFmOHNIGbu.jpg" alt="Break_point.jpg"></p><p>Break point: value at which WACC changes or cost of one source of capital changes</p></li></ul></li><li><p>Flotation cost(发行成本):</p><ul><li>Fee changed by investment bankers or brokers when raises capital</li><li>Flotation cost for debt and preferred stock: normally quite small, not significant</li><li>Flotation cost for ordinary equity: usually significant, should be deduct as flotation cost(E) as initial cash outflow of the project(L)</li></ul></li></ol><h2 id="Measures-of-Leverage"><a href="#Measures-of-Leverage" class="headerlink" title="Measures of Leverage"></a>Measures of Leverage</h2><ol><li><p>Leverage basics:</p><ul><li>Definition: a change in one variable leads to greater change in another variable due to <strong>fixed cost</strong></li><li>Types of leverage:<ul><li>Operating leverage: created by operation fixed charge</li><li>Financial leverage: created by financial fixed charge</li></ul></li><li>Leverage increases volatility of company’s earning. It also increases the <strong>risk</strong> of creditor(EBITA) and shareholders(Net income)</li></ul></li><li><p>Types of risk:</p><ul><li>Business risk: associated with operating earning<ul><li>Sales risk: uncertainty of revenue due to external factor</li><li>Operating risk: due to operating fixed cost(e.g. depreciation)</li></ul></li><li>Financial risk: due to financial fixed cost(e.g. interest, financial lease)</li><li><strong>Fixed cost leads to leverage and risk</strong></li><li><strong>Dividends does not affect risk as it has nothing to do with fixed cost!!!</strong></li></ul></li><li><p>Measurements of leverage:</p><ul><li><p>Degree of operating leverage(DOL,经营杠杆系数):</p><ul><li><p>A measure of sensitivity of operating income(EBIT) against revenue(EBIT变化率是Revenue变化率的几倍?)</p></li><li><p>DOL  = $\frac{\frac{\Delta EBIT}{EBIT}}{\frac{\Delta Revenue}{Revenue}}=\frac{Q(P-V)}{Q(P-V)-F}=\frac{EBIT+F}{EBIT}$</p><p>Q: quantity sold</p><p>P: unit price </p><p>V: variable cost</p><p>F: fixed cost</p></li><li><p>DOL = 1 when there is no fixed cost</p></li><li><p>DOL is measured relative to a standard quantity sold($Q_{0}$). This leads to a standard revenue = $Q_{0}\cdot P$ and a standard EBIT</p></li><li><p>We may draw a diagram of DOL against $Q_{0}$ with P, V, F fixed</p><p><img src="https://i.loli.net/2020/07/21/Dm8Yuk3PCFKJLVz.png" alt="Degree_of_operating_leverage.png"></p><p>EBIT(Operating income) = Q(P-V) - F</p><p>When EBIT is negative, DOL is negative</p><p>DOL is undefined when EBIT=0. It is due to the denominator = 0</p><p>DOL gradually reduces to 1 as EBIT increases to infinity</p></li></ul></li><li><p>Degree of Financial leverage(DFL,财务杠杆系数):</p><ul><li>A measure of sensitivity of net income against operating income or EBIT(net income变化率是Operating income or EBIT变化率的几倍?)</li><li>DFL = $\frac{\frac{\Delta Net\ income}{Net\ income}}{\frac{\Delta EBIT}{EBIT}} = \frac{EBIT}{EBIT-Interest}$</li><li>When interest&gt;0, DFL is always greater than 1</li></ul></li><li><p>Degree of total leverage(DTL,总杠杆系数)</p><ul><li>A measure of sensitivity of net income against revenue(net income变化率是revenue变化率的几倍?)</li><li>DTL = $\frac{\frac{\Delta Net\ income}{Net\ income}}{\frac{\Delta Revenue}{Revenue}}=\frac{\frac{\Delta EBIT}{EBIT}}{\frac{\Delta Revenue}{Revenue}} \times \frac{\frac{\Delta Net\ income}{Net\ income}}{\frac{\Delta EBIT}{EBIT}}$= DOL $\times$ DFL = $\frac{Q(P-V)}{Q(P-V)-F-Interest}$</li></ul></li></ul></li><li><p>Breakeven point: quantity of sales at which net income is zero</p><p>Quantity of breakeven = $Q_{be} = \frac{Total\ Fixed\ cost}{P-V}$ = $ \frac{Operating\ Fixed\ cost+Financial\ Fixed\ cost}{P-V}$ </p></li><li><p>Operating breakeven point: quantity of sales at which EBIT(operating income) is zero</p><p>Quantity of operating breakeven = $Q_{obe}=\frac{Operating\ fixed\ cost}{P-V}$</p></li></ol><h2 id="Working-Capital-Management"><a href="#Working-Capital-Management" class="headerlink" title="Working Capital Management"></a>Working Capital Management</h2><ol><li><p>Liquidity basics:</p><ul><li>Working capital = Current asset - Current liability</li><li>Sources of liquidity(meet company’s short-term debt):<ul><li>Primary sources: cash, trade credit(可以欠供应商的钱), short-term investment, bank lines of credit(授信额度)</li><li>Secondary sources: will change the company’s financial and operating position including: negotiating debt contract(影响未来信誉), selling fixed asset(影响经营活动), filling for bankruptcy protection(经营活动中止)</li></ul></li><li>Drags and pulls on liquidity(<strong>negative effects on cash flow</strong>):<ul><li>Drags on liquidity: delay or reduced inflow; increased borrowing cost</li><li>Pulls on liquidity: accelerated cash outflow</li></ul></li></ul></li><li><p>Liquidity management: ability to generate cash when and where is needed</p><ul><li><p>Management of cash:</p><ul><li>Ensure net daily cash to be positive</li><li>Invest excess cash in short-term securities</li></ul></li><li><p>Short-term securities yield(rate):</p><ul><li>Discount basis yield = $\frac{Face\ value-Price}{Face\ value}\times \frac{360}{Days}$ </li><li>Money market yield = $\frac{Face\ value-Price}{Price}\times \frac{360}{Days}$</li><li>Bond equivalent yield = $\frac{Face\ value-Price}{Price}\times \frac{365}{Days}$</li><li>Bond equivalent yield&gt;Money market yield&gt;Discount basis yield as price &lt; face value</li></ul></li><li><p>Management of account receivable:</p><ul><li>A ineffective credit management (Too much account receivable) will lead to bad debts</li><li>A strict credit management(Too little account receivable) will lead to less revenue</li><li>Approaches to evaluate(评估) management: receivable turnover ratio, account receivable aging schedule(账龄分析, e.g. 90天内收回80%,180天内收回90%…….)</li></ul></li><li><p>Management of inventory:</p><ul><li>Too low inventory results in lose of sale</li><li>Too high inventory results in high carrying cost</li><li>Approaches to evaluate management: inventory turnover ratio, compare with historical performance or other comparable companies</li></ul></li><li><p>Management of account payable:</p><ul><li>Paying too early results in opportunity cost unless there is a <strong>trade discount</strong></li><li>Paying too late affects the company’s credit record</li><li>Approaches to evaluate management: payable turnover ratio, compare with historical performance or other comparable companies</li></ul></li><li><p>Trade discount:</p><ul><li><p>A company may receive discount for paying account payable earlier.</p></li><li><p>e.g. <strong>2/10 net 50</strong>: net amount of account payable must be paid within 50 days but the company will receiver a 2% discount if it is paid within 10 days</p></li><li><p>Cost of trade credit: <strong>return of the company by taking the option of paying earlier</strong></p><p>e.g. Option 1: paying 98 dollar at day 10 so the company is generating 2 dollar in the next 40 days using the 98 dollar principal</p><p>Option 2: paying 100 dollar at day 50</p><p>Return of option 1: $\frac{2}{98}$</p><p>Cost of trade credit(Annualized return of option 1) = $^{\frac{40}{365}}\sqrt{(1+\frac{2}{98})}-1 = (1+\frac{2}{98})^{\frac{365}{40}}-1$</p><p>More general form = $(1+\frac{Percentage\ of\ discount}{1- Percentage\ of\ discount})^{\frac{365}{days\ of\ holding}}$ </p></li><li><p>If cost of trade credit &gt; short-term investment rate, take option 1</p></li><li><p>If cost of trade credit &lt; short-term investment rate, take option 2</p></li></ul></li><li><p>Management of short-term Financing:</p><ul><li>sources: uncommitted lines of credit(不承诺借款额), committed lines of credit(承诺借款额), revolving lines of credit(循环借款), collateralized borrowing(抵押贷款), banker’s acceptances(承兑汇票), factoring(应收账款打包出售), commercial paper(商业票据)</li></ul></li></ul></li></ol><h2 id="Introduction-to-Corporate-Governance"><a href="#Introduction-to-Corporate-Governance" class="headerlink" title="Introduction to Corporate Governance"></a>Introduction to Corporate Governance</h2><ol><li><p>Internal structure of a corporate:</p><ul><li>Board of director make broad future plans and employ senior members of the corporate e.g. CEO, CFO to pursuit those plans in more detail. Board of director do not necessarily get involved in the day to day running of the corporate</li><li>Senior members of the company are involved in the day to day running of the corporate and work with junior level employee to generate profit</li></ul></li><li><p>Corporate governance basics:</p><ul><li>Definition of corporate governance: <ul><li>System of internal control and procedures that a company is managed. </li><li>It defines rights, roles and responsibilities. </li><li>It also minimize and manage conflicting interests between insiders and external shareholders</li></ul></li><li>Corporate governance theories:<ul><li>Shareholder theory: corporate’s most important duty is to maximize shareholder’s interests</li><li>Stakeholder theory: corporate should focus on interests of not only shareholders, but also customers, suppliers, employees and others who have interest in the company(平衡相关方利益)</li></ul></li></ul></li><li><p>Stakeholders(利益相关方) group:</p><ul><li><p>Internal group: <strong>shareholders</strong>, <strong>board of directors</strong>, managers and employees</p></li><li><p>External group: <strong>creditors</strong>, customers, suppliers, Governments/regulatory institutions</p></li><li><p>Shareholders: </p><ul><li>Focus on maximize profitability and owner’s equity of the company</li><li>Controlling shareholders: owning over 50% of share</li><li>Minority shareholders: owning less than 50% of share</li></ul></li><li><p>Board of directors:</p><ul><li><p>Elected by shareholders to protect shareholder’s interest</p></li><li><p>Provide strategic direction, serves as link between shareholders and managers, acts as the shareholders monitoring tool within company</p></li><li><p>One-tier structure: </p><p>Executive director: involved in the daily running of the company, act like a senior manager</p><p>Non-executive director: not involved in the daily running of the company</p></li><li><p>Two-tier structure:</p><p>Management board: made up of executive directors, involved in daily running of company</p><p>Supervisory board(监事会): made up of non-executive directors, responsible of checking management board’s work and performance</p></li><li><p>Committees with in board of directors: Audit committee, Governance committee(监督日常运营), Remuneration committee, Nomination committee(提名潜在未来的董事), risk committee, investment committee</p></li></ul></li><li><p>Creditors:</p><ul><li>Focus on stability in company operations and performance</li><li>Lower risk tolerate than shareholders</li></ul></li></ul></li><li><p>Stakeholders management:</p><ul><li>Annual general meeting(AGM):<ul><li>Functions: elect of directors, approve financial statements, vote on the remuneration(薪酬) of the board and senior managers, appoint external auditor, discharge directors</li><li>Simple majority of votes(&gt;50%)</li></ul></li><li>Extraordinary general meeting(EGM):<ul><li>Functions: mergers and acquisitions decision, amendment of company’s bylaw(条款), sale of significant corporate assets or businesses</li><li>Supermajority of votes(&gt;67% or 75%)</li></ul></li><li>Mechanisms of ensuring effective stakeholders management:<ul><li>General meeting</li><li>Board of director</li><li>Internal audit and external audit</li><li>Financial reporting with transparency</li><li>Polices against related-party transaction(投票时排除有相关利益的董事)</li><li>Remuneration policies: align interests of managers with shareholders by including a variable component(激励奖金) and claw back provision(若经理犯错可以追回奖金)</li><li>Contractual(抵押) agreements with creditors</li><li>Employee law and contracts</li><li>Contract with customers and suppliers</li><li>Laws and regulations</li></ul></li></ul></li><li><p>Relationship between stakeholders:</p><ul><li>Principal-agent relationship(委托代理关系):<ul><li>Shareholders vs. Manager/BoD: information asymmetry as shareholders not involved in daily running of company</li><li>Controlling shareholders vs. Minority shareholders: controlling shareholders may make decision based on their own benefits but not minority shareholders e.g. takeover transaction, related-party transaction(doing business with someone controlling shareholders know), dual-class structure(AB股,同股不同权)</li><li>BoD vs. Manager: information asymmetry as manager is more involved in daily running</li><li>Shareholder vs. Creditor: shareholders have higher risk tolerance than creditors</li></ul></li><li>Other relationship:<ul><li>Customers vs. Shareholders: customers want better service with low cost but shareholders want high profitability</li><li>Shareholders vs. Government/regulators: legal requirement introduces higher cost</li></ul></li></ul></li><li><p>Analyst considerations:</p><ul><li>Factors affecting stakeholders relationship:<ul><li>Market factors: engagement, activism, competition</li><li>Non-market: legal environment, media </li></ul></li><li>Factors related to analysis:<ul><li>Economic ownership and voting control</li><li>Board of directors performance</li><li>Interests alignment between shareholders and managers</li><li>Investors of the company: cross-shareholding(takeover defense), affiliated shareholders(protect against hostile takeover)</li><li>Strength of shareholder’s rights</li><li>Management of long-term risk</li></ul></li></ul></li></ol><h2 id="ESG-considerations"><a href="#ESG-considerations" class="headerlink" title="ESG considerations"></a>ESG considerations</h2><ol><li>ESG investing: practice of considering environmental, social and governance factors in investment process</li><li>ESG investment implementation methods:<ul><li>Negative screening: 拒绝投资非ESG企业(如:烟草,酒精)</li><li>Positive screening: focus on investment with favorable ESG factors</li><li>Thematic investing: focus on a specific theme related to ESG e.g. clean energy, green technology</li><li>Full integration: include ESG factor premium into stock valuation</li><li>Engagement/Active ownership: use shareholder power to push ESG projects in the company</li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;CFA-Corporate-Finance-Notes&quot;&gt;&lt;a href=&quot;#CFA-Corporate-Finance-Notes&quot; class=&quot;headerlink&quot; title=&quot;CFA Corporate Finance Notes&quot;&gt;&lt;/a&gt;CFA Corporate Finance Notes&lt;/h1&gt;&lt;h2 id=&quot;Capital-Budgeting&quot;&gt;&lt;a href=&quot;#Capital-Budgeting&quot; class=&quot;headerlink&quot; title=&quot;Capital Budgeting&quot;&gt;&lt;/a&gt;Capital Budgeting&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Capital project: projects where cash flow to the firm will be received over a period more than one year&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Capital budgeting: &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Definition: process company use for decision making on capital projects(选择最合适capital project的流程)&lt;/li&gt;
&lt;li&gt;Key steps in capital budgeting process:&lt;ul&gt;
&lt;li&gt;Step1: Generating ideas&lt;/li&gt;
&lt;li&gt;Step2: Analyzing individual project proposals(analyze &lt;strong&gt;after-tax increment cash flow&lt;/strong&gt; of a project)&lt;/li&gt;
&lt;li&gt;Step3: Planning the capital budget for the firm(choose project which is most suitable)&lt;/li&gt;
&lt;li&gt;Step4: Monitoring decisions and conducting a post-audit after the project is finished&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Types of ideas(Step1):&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Replacement projects: &lt;ul&gt;
&lt;li&gt;Projects to maintain the business(是否保留已有生意)&lt;/li&gt;
&lt;li&gt;Projects for cost reduction(是否对已有生意进行一次性投资来降低variable cost)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Expansion projects: 是否复制已有的生意&lt;/li&gt;
&lt;li&gt;New products or services: 是否开展新生意&lt;/li&gt;
&lt;li&gt;Mandatory projects: projects to meet legal requirements&lt;/li&gt;
&lt;li&gt;Other projects: R&amp;amp;D projects etc.&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Finance" scheme="https://yuxuanliu.tech/categories/Finance/"/>
    
    
      <category term="CFA" scheme="https://yuxuanliu.tech/tags/CFA/"/>
    
      <category term="Finance" scheme="https://yuxuanliu.tech/tags/Finance/"/>
    
  </entry>
  
  <entry>
    <title>CFA Financial reporting &amp; Analysis Notes</title>
    <link href="https://yuxuanliu.tech/CFA_Financial_reporting_analysis/"/>
    <id>https://yuxuanliu.tech/CFA_Financial_reporting_analysis/</id>
    <published>2020-07-14T21:46:19.000Z</published>
    <updated>2020-07-14T14:50:29.853Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Introduction-to-Financial-Statement-Analysis"><a href="#Introduction-to-Financial-Statement-Analysis" class="headerlink" title="Introduction to Financial Statement Analysis"></a>Introduction to Financial Statement Analysis</h2><ol><li><p>Users of financial report:</p><p><img src="https://i.loli.net/2020/07/14/NzCsMRJXqwSDn4a.png" alt="Report_user.png"></p></li><li><p>Information available for analysis:</p><p><img src="https://i.loli.net/2020/07/14/GcmoNlsvytPd1zZ.png" alt="Information_for_analysis.png"></p><ul><li>Financial statement is part of Financial report</li><li>Footnotes: 披露会计方法(e.g. FIFO, LIFO), 折旧方法, 表中数值的计算过程</li><li>MD&amp;A: past performance, future outlook, off-balance-sheet obligations(表外负债:不太可能产生的负债所以不会被计入BS), MD&amp;A don’t need to be audited</li><li>Audit: provide opinion on <strong>financial statements</strong> and internal controls(内控)<ul><li>Unqualified opinion: a true and fair view</li><li>Qualified opinion: make some errors against accounting principal</li><li>Adverse opinion(否定意见): not present a fair view</li><li>Disclaimer of opinion(无法表达意见): scope limitation(not enough information provided)</li></ul></li></ul><a id="more"></a></li><li><p>Some basic relationships:</p><ul><li>Assets = Liabilities + Owner’s Equity</li><li>Net income - Dividends declared = $\Delta$Retained earnings</li><li>Retained earnings(start of the year) + $\Delta$Retained earnings = Retained earnings(end of the year)</li><li>Equity = Capital(股本) + Retained earning + Accumulated other comprehensive income(AOCI)</li></ul></li></ol><h2 id="Financial-Reporting-Standards"><a href="#Financial-Reporting-Standards" class="headerlink" title="Financial Reporting Standards"></a>Financial Reporting Standards</h2><ol><li>Financial standard-setting bodies(有规则制定权无执法权):<ul><li>Financial Accounting Standards Board(FASB): <strong>U.S.GAAP</strong></li><li>International Accounting Standards Board(IASB): <strong>IFRS</strong></li></ul></li><li>Regulatory bodies(无规则制定权有执法权):<ul><li>Securities and Exchange Commission(SEC), IOSCO(国际证监会)</li><li>Duties: protect investors, ensure markets are fair, efficient, transparent, reduce systemic risk</li></ul></li><li>SEC forms:<ul><li>S-1: 招股说明书</li><li>DEF-14A: 股东会投票委托代理说明</li><li>8-K: 重大事项报告</li><li>10-K: 企业年报</li><li>10-Q: 季度报告</li><li>144: 限售股解禁</li></ul></li><li>IFRS framework:<ul><li>Two fundamental characteristics:<ul><li>Relevance</li><li>Faithful representation</li></ul></li><li>Four enhancement characteristics:<ul><li>Comparability: reports are in consistent manner for easy comparison</li><li>Verifiability: third party can use same method to get same results in the report</li><li>Timeliness(及时性)</li><li>Understandability(文字通俗易懂)</li></ul></li></ul></li><li>Comprehensive income:<ul><li>Comprehensive income = Net income + Other comprehensive income(OCI)</li><li>The following items must be put into OCI:<ul><li>Foreign currency translation gain/loss</li><li>Unrealised gain/loss from available-for-sale financial assets</li><li>Revaluation surplus for long-lived asset</li></ul></li><li>Net income is the bottom line of Income statement, OCI is added to <strong>Net income</strong> for <strong>Comprehensive income</strong> which is the bottom line of comprehensive income statement</li><li>Net income is transferred to Balance sheet through Retained earnings while OCI is transferred through Accumulated other comprehensive income(AOCI) </li></ul></li><li>General features of financial statements:<ul><li>No offsetting(e.g. Asset &amp; Liability can’t offset to give the net value)</li><li>Going concern basis(永续经营)</li><li>Accrual basis of accounting(权责发生制)</li></ul></li><li>Some useful terms:<ul><li>Unearned revenue(提前收到现金) CL</li><li>Prepaid expense(提前支付现金) CA</li><li>Unbilled revenue(延迟收到现金) CA</li><li>Accrued expense(延迟支付现金) CL</li></ul></li></ol><h2 id="Understanding-Income-Statements"><a href="#Understanding-Income-Statements" class="headerlink" title="Understanding Income Statements"></a>Understanding Income Statements</h2><ol><li><p>Detailed Income statements:</p><table><thead><tr><th>Net revenue</th></tr></thead><tbody><tr><td>- Cost of Good Sold(COGS)</td></tr><tr><td>= Gross Profit</td></tr><tr><td>- Selling, General &amp; Administrative expense(SG&amp;A)</td></tr><tr><td>= Operating income</td></tr><tr><td>+/- Other income(expense)</td></tr><tr><td>+/- Gain(Loss)</td></tr><tr><td>+/- Unusual items</td></tr><tr><td>= Earning before interest and tax(EBIT)</td></tr><tr><td>- Interest expense</td></tr><tr><td>= Earning before tax(EBT)</td></tr><tr><td>- Tax expense</td></tr><tr><td>= Net income from continued operation</td></tr><tr><td>+/- Gain(Loss) from discontinued operation</td></tr><tr><td>=Net income</td></tr></tbody></table></li><li><p>Gain/Loss: income/expenditure not related to daily activities e.g.机械加工公司炒股获利</p></li><li><p>Non-recurring item: Impairments, gain/loss from the sale of assets</p></li><li><p>Discontinued operation: </p><ul><li>要把<strong>确定要被出售的业务</strong>的日常运营税后利润/损失单独列在EBT之后</li><li>在计划出售日和实际出售日期间日常运营产生的利润/损失记为 Gain/Loss from discontinued operation</li><li>实际出售日当天非常容易产生Gain/Loss, 这部分要被记为 Non-recurring item because it is gain/loss from the sale of assets</li></ul></li><li><ul><li>Aggressive accounting: earlier revenue recognition, later expense recognition</li><li>Conservative accounting: later revenue recognition, earlier expense recognition</li><li>Both aggressive accounting and conservation accounting are biased. Accountant should find a compromised position between two.</li></ul></li><li><p>Five steps in recognizing revenue:</p><ul><li>Contents:<ul><li>识别合同内容</li><li>识别履约义务</li><li>确定交易价格</li><li>将交易价格分派到每项履约义务中</li><li>每完成一项履约义务,确认一笔收入</li></ul></li><li>A few notes:<ul><li>如果一项义务有自己的作用且可以与其他义务进行区分,那么这项义务就是独立的</li><li>匹配性原则:当确认了合同的一笔收入,其对应的支出也应该同时被确认</li><li>谨慎性原则:如果合同规定了奖金,必须非常有信心达到奖金要求时才可以将金额确认</li><li>如果中途对合同进行更改,如果合同提供的服务和之前一样那么就是对旧合同的更新(需要追溯调整)否则就是一个新合同</li><li>对于中间商(e.g.去哪儿),利润表只可将该公司的服务费记为营收而不可以用(用户总付款-服务成本)这种记账方法来使营收看起来很高,因为中间商没有承担服务风险且没有自由裁量权(自主定价)</li></ul></li></ul></li><li><p>Earnings per share(EPS):</p><ul><li><p>Basic EPS:</p><ul><li>$\frac{NI-Preference\ dividence}{Weighted \ number \ of \ common \ share \ outstanding}$</li><li>本质是每股流通在外的普通股对应的利润(回购的普通股不算流通)</li><li>Stock split(拆股)/dividend(增发)/merge(并股)需要对过去进行追溯调整</li><li>所有追溯调整完成后, new issue and repurchase is weighted by time</li><li>计算时应画时间轴来辅助理解</li></ul></li><li><p>Diluted EPS:</p><ul><li><p>是一个假想中的参数,如果公司在年底有convertible preferred stock(可转换优先股), convertible debt(可转债), stock options(期权),这些产品可能会在未来转换为普通股从而影响basic EPS. Diluted EPS就是假设这些产品均转为普通股时的EPS(If diluted EPS is greater than basic EPS, diluted EPS = basic EPS)</p></li><li><p>Convertible preferred stock:</p><p>$$\frac{NI-Total\ preference\ dividence+Dividence\ of\ converted\ preference\ share}{Weighted \ number \ of \ common \ share \ outstanding+Shares\ from\  converted\ preference\ share}$$</p></li><li><p>Convertible debt:</p><p>$$\frac{NI-Total\ preference\ dividence+Convertible\ debt\ interest(1-t)}{Weighted \ number \ of \ common \ share \ outstanding+Shares\  from\ converted\ debt}$$</p><p>where $t$ is the tax rate </p></li><li><p>Options:</p><p>$$\frac{NI-Total\ preference\ dividence}{Weighted \ number \ of \ common \ share \ outstanding+\Delta}$$</p><p>$\Delta$=Net change in ordinary share due to outstanding option=期权规定回购股数-回购数</p><p>如果行使期权,股东必须付款以规定价格购买股票,这部分现金被公司用来以全年平均股价回购股票来分发给行使期权者,但回购数通常小于期权规定股数(因为期权规定单价低),两者差通过发行新普通股来补齐即分母中的$\Delta$</p></li></ul></li></ul></li><li><p>Common-size analysis: 把报表中的每一项以百分比表示(e.g.把IS中每一项除以Revenue)</p></li></ol><h2 id="Understanding-Balance-Sheets"><a href="#Understanding-Balance-Sheets" class="headerlink" title="Understanding Balance Sheets"></a>Understanding Balance Sheets</h2><ol><li>Asset:<ul><li>Current asset: can be realized in cash within one year or one operating cycle whichever is greater</li><li>Non-current asset: cannot be realized in cash within one year or one operating cycle<ul><li>Property, plant and equipment(PP&amp;E)</li><li>Intangible asset: patents, copyright, goodwill(no amortization)</li><li>Intangible asset except for goodwill must be amortized(摊销)</li></ul></li></ul></li><li>Measurement of financial asset(计量属性):<ul><li>Historical cost: amount originally paid</li><li>Amortized cost: adjusted bond issued at premium/discount back to face value</li><li>Current cost: amount need to pay today for the same asset</li><li>Realizable cost: price at which the asset can be sold today</li><li>Fair value(公允价值): use market value when available. Otherwise, use market value of a similar object. If market value of a similar object is still unavailable, use an appropriate valuation method(e.g. DCF)</li></ul></li><li><ul><li>Liquidity: short-term debt repayment ability</li><li>Solvency: long-term debt repayment ability</li></ul></li><li>Financial asset:<ul><li>Classification:<ul><li>Held-to-maturity: 有意愿持有到期(通常为债券)</li><li>Trading security: 以短期获利为目的而持有</li><li>Available-for-sale: 不满足以上两项定义的其他金融资产</li></ul></li><li>Held-to-maturity:<ul><li>Measurement: Amortized cost(实际利率发摊销)</li><li>Unrealized G/L: N/A(not affected by market value as we are holding it to maturity)</li><li>Realized G/L: Income statement</li></ul></li><li>Trading security:<ul><li>Measurement: fair value</li><li>Unrealized G/L: Income statement</li><li>Realized G/L: Income statement</li></ul></li><li>Available-for-sale:<ul><li>Measurement: fair value</li><li>Unrealized G/L: Other comprehensive income(OCI)</li><li>Realized G/L: Income statement</li></ul></li></ul></li></ol><h2 id="Understanding-Cash-Flow-Statements"><a href="#Understanding-Cash-Flow-Statements" class="headerlink" title="Understanding Cash Flow Statements"></a>Understanding Cash Flow Statements</h2><ol><li><p>Classification of cash flow:</p><ul><li>Cash flow from operating activities(CFO): cash flow from day-to-day activities</li><li>Cash flow from investing activities(CFI): cash flow from purchasing and selling LTA and <strong>investing</strong></li><li>Cash flow from financing activities(CFF): cash flow from obtaining or repaying capital(融资活动)</li></ul></li><li><p>GAAP standard:</p><ul><li>CFO:<ul><li>Cash received/paid for daily operation</li><li><strong>Interest received/paid</strong></li><li><strong>Dividend received</strong> </li><li>Sale/acquisition of trading security</li></ul></li><li>CFI:<ul><li>Sale/acquisition of PP&amp;E, intangible fixed asset</li><li>Sale/acquisition of financial assets other than trading security</li><li>Loan made to others(作为投资者进行投资)</li><li>Principal received from others(作为投资者收回本金)</li></ul></li><li>CFF:<ul><li>Principal received from issued debt(作为融资方贷款)</li><li>Principal repayment for a debt(作为融资方还款)</li><li>Issue/repurchase of share</li><li><strong>Dividends paid</strong></li></ul></li></ul></li><li><p>GAAP vs IFRS:</p><table><thead><tr><th></th><th>GAAP</th><th>IFRS</th></tr></thead><tbody><tr><td>Interest received</td><td>CFO</td><td>CFO or CFI</td></tr><tr><td>Interest paid</td><td>CFO</td><td>CFO or CFF</td></tr><tr><td>Dividends paid</td><td>CFF</td><td>CFO or CFF</td></tr><tr><td>Dividends received</td><td>CFO</td><td>CFO or CFI</td></tr><tr><td>Tax paid</td><td>CFO</td><td>CFO, CFI or CFF</td></tr></tbody></table></li><li><p>CFO calculation:</p><ul><li><p>Direct method: starting from the top of Income statement</p><ul><li>Beginning inventory + <strong>purchase</strong>(Unknown) - COGS = Ending inventory</li><li>Beginning account payable + purchase - closing account payable = <strong>Cash paid to supplier</strong>(Unknown)</li></ul></li><li><p>Indirect method: starting from Net income</p><table><thead><tr><th>Net income</th></tr></thead><tbody><tr><td>+ Non cash expenditure(e.g. depreciation, amortization)</td></tr><tr><td>+/- Non operating item(e.g. gain from selling the old machine, should be CFI)</td></tr><tr><td>- Increase in current assets</td></tr><tr><td>+ Increase in current liabilities</td></tr><tr><td>= CFO</td></tr></tbody></table></li></ul></li><li><p>CFI calculation:</p><ul><li>CFI = inflow - outflow</li><li>Inflow(selling price) - NBV = Gain/Loss</li><li>Historical cost(year start) + purchase - historical cost of asset sold = historical cost(year end)</li><li>Accumulated depreciation(year start) + depreciation during the year - accumulated depreciation of the asset sold = Accumulated depreciation(year end)</li></ul></li><li><p>CFF calculation:</p><ul><li>RE year end = RE year start + Net income - Dividends declared(Unknown)</li><li>Dividends payable year start+ Dividends declared - Dividends paid(Unknown) = Dividends payable year end</li></ul></li><li><p>Significance of cash flow:</p><ul><li>CFO: an indication of <strong>earning quality(主营业务现金流更稳定容易持续)</strong></li><li>CFI: an indication of growth</li><li>CFF: the nature of company’s capital source</li></ul></li><li><p>Free cash flow(only need to remember formulae):</p><ul><li><p>Definition: cash flow available for distribution after fulfilling obligations and without impacting future growth plans</p></li><li><p>Free cash flow to firm(FCFF) = <strong>[NI + Non-cash charge - Working capital investment]</strong> - Fixed capital investment+ Interest expense$\times$(1-tax rate) = <strong>CFO</strong> - Fixed capital investment + Interest expense$\times$(1-tax rate)</p><p>where working capital investment = $\Delta$current asset - $\Delta$current liability</p></li><li><p>Free cash flow to equity(FCFE) = FCFF - Interest expense$\times$(1-tax rate) + Net debt borrowing</p><p>= CFO - Fixed capital investment + Net debt borrowing</p></li></ul></li></ol><h2 id="Financial-Analysis-Techniques"><a href="#Financial-Analysis-Techniques" class="headerlink" title="Financial Analysis Techniques"></a>Financial Analysis Techniques</h2><ol><li><p>Activity ratio(经营效率或周转率): indicates efficiency in using assets to generate revenue</p><ul><li><p><strong>Average is found using</strong> $\frac{Year\ start\ value\ +\ Year\ end\ value}{2}$</p></li><li><p>Inventory turnover = $\frac{COGS}{Average\ inventory}$ 越大越好</p></li><li><p>Days of inventory on hand(DOH) = $\frac{365}{Inventory\ turnover}$ 越小越好</p></li><li><p>Receivable turnover = $\frac{Revenue}{Average \ receivable}$ 越大越好</p></li><li><p>Days of sale outstanding(DSO) = $\frac{365}{Receivable \ turnover}$  越小越好</p></li><li><p>Payable turnover = $\frac{Purchase}{Average\ payable}$ 越小越好</p></li><li><p>Number of days of payable = $\frac{365}{Payable \ turnover}$ 越大越好</p></li><li><p>Total asset turnover = $\frac{Revenue}{Avarage\ total\ assets}$ 越大越好</p></li><li><p>Fixed asset turnover = $\frac{Revenue}{Avarage\ NBV\ of \ fixed\  assets}$ 越大越好</p></li><li><p>Working capital turnover = $\frac{Revenue}{Average\ working\ capital}$ 越大越好</p><p>where working capital = current asset - current liability</p></li><li><p>Operating cycle = DOH + DSO(从存货入库到全部卖出收到现金) 越小越好</p></li><li><p>Cash conversion cycle = DOH + DSO - Number of days of payable(现金收回周期) 越小越好</p></li></ul></li><li><p>Liquidity ratio(流动性): indicates ability to meet short-term debt obligations</p><ul><li>Current ratio = $\frac{Current\ asset}{Current \ liability}$</li><li>Quick ratio(Acid-test ratio) = $\frac{Cash+Short\ term\ marketable\ security+Account\ receivable}{Current\ liability}$ 只保留易变现的CA</li><li>Cash ratio = $\frac{Cash+Short\ term\ marketable\ security}{Current\ liability}$只保留非常容易变现的CA</li><li>Defensive ratio = $\frac{Cash+Short\ term\ marketable\ security+Account\ receivable}{Daily\ cash\ expenditure}$ 易变现的CA够用多少天</li></ul></li><li><p>Solvency ratio(偿付能力): indicates ability to meet long-term debt obligations and its <strong>capital structure</strong></p><ul><li>Total debt is the sum of interest-bearing short-term liability and long-term debt</li><li>Debt-to-equity ratio = $\frac{Total\ debt}{Total\ shareholder’s \ equity}$</li><li>Debt-to-capital ratio = $\frac{Total\ debt}{Total \ capital}$ = $\frac{Total\ debt}{Total\ debt +Total \ shareholder’s \ equity}$</li><li>Debt-to-asset ratio = $\frac{Total\ debt}{Total\ assets}$</li><li>Debt-to-EBITDA ratio = $\frac {Total\ debt}{EBITDA}$</li><li>Financial leverage(杠杆率) = $\frac{Total\ asset}{Total \ shareholder’s \ equity}$</li><li>Interest coverage = $\frac{EBIT}{Interest}$</li><li>Fixed charge coverage = $\frac{EBIT+Lease\ payment}{Interest+\ Lease\ payment}$</li></ul></li><li><p>Profitability ratio(盈利能力): indicates ability to generate profit</p><ul><li><p>Gross profit margin = $\frac{Gross\ profit}{Net\ revenue}$</p></li><li><p>Operating profit margin = $\frac{Operating\ profit}{Net\ revenue}$</p></li><li><p>Pretax margin = $\frac{EBT}{Net\ revenue}$</p></li><li><p>Net profit margin = $\frac{Net\ income}{Net\ revenue}$</p></li><li><p>Return on asset(ROA) by definition = $\frac{NI}{Average\ total\ asset}$</p><p>Return on asset(ROA) for analysts = $\frac{NI+Interest(1-tax\ rate)}{Average\ total\ asset}$ </p><p>Use the ROA by definition formula unless specified user is an analyst</p></li><li><p>Operating ROA = $\frac{Operating \ profit}{Average\ total\ asset}$</p></li><li><p>Return on equity(ROE) = $\frac{NI}{Average\ total\ equity}$</p></li></ul></li><li><p>DuPont analysis:</p><ul><li><p>Two-part approach: ROE = $\frac{NI}{Equity}$=$\frac{NI}{Asset}\cdot \frac{Asset}{Equity}$= ROA$\times$ Financial leverage ratio</p><p>Financial leverage 对ROA有放大作用</p></li><li><p>Three-part approach: ROE = $\frac{NI}{Equity}$ = $\frac{NI}{Revenue}\cdot \frac{Revenue}{Asset}\cdot \frac{Asset}{Equity}$ = Net profit margin$\times$ Asset turnover$\times$ Financial leverage ratio</p></li><li><p>Five-part approach: ROE = $\frac{NI}{Equity}$= $\frac{NI}{EBT}\cdot \frac{EBT}{EBIT}\cdot \frac{EBIT}{revenue}\cdot \frac{revenue}{asset}\cdot \frac{asset}{Equity}$ = Tax burden$\times$ Interest burden$\times$ EBIT margin$\times$ Asset turnover $\times$ Financial leverage ratio</p><p>where Tax burden = $\frac{NI}{EBT}$=$\frac{EBT- tax}{EBT}$1 - tax rate</p><p>​            Interest burden = $\frac{EBT}{EBIT}$= $\frac{EBIT-Interest}{EBIT}$ = 1-$\frac{1}{Interest\ coverage}$  </p></li></ul></li><li><p>Equity analysis:</p><ul><li>Dividends payout ratio = $\frac{Dividends}{Net income}$</li><li>Retention rate(利润留存率) = 1 - Dividends payout ratio</li><li>Sustainable growth rate(可持续增长率) = ROE$\times$ Retention ratio</li></ul></li><li><p>Segment reporting: a company must disclose information in footnotes about any operating segment which constitutes 10% or more of the company’s revenue, profit or asset.</p></li></ol><h2 id="Inventories"><a href="#Inventories" class="headerlink" title="Inventories"></a>Inventories</h2><ol><li><p>Inventory cost recognition(historical cost):</p><ul><li>费用是否可以资本化记为asset取决于这个花费是否是存货达到可出售状态的必要花费</li><li>Purchases cost(includes tax, transport insurance etc.) &amp; conversion cost(direct labor, fixed and variable overhead cost) can be capitalized as asset</li><li>Abnormal waste, storage cost(unless required as part of production), administrative overhead and selling cost can’t be capitalized, instead they are recorded as expense</li></ul></li><li><p>Valuation method:</p><ul><li>如果我们卖出了一部分Inventory, 如何确定将这部分应转入COGS的货物的价值?</li><li>Under IFRS:<ul><li>Specific identification(most accurate but not always possible)</li><li>FIFO</li><li>Weighted average cost</li></ul></li><li>Under GAAP:<ul><li>Specific identification(most accurate but not always possible)</li><li>FIFO</li><li>LIFO</li><li>Weighted average cost</li></ul></li><li>FIFO gives a more accurate Inventory balance sheet reading(留在仓库里存货的价格比较新,更贴近当前日期) while LIFO gives a more accurate Income statement reading(卖出的存货价格比较新) as cost of Inventory is constantly changing.</li><li><strong>Weighted average cost is always between FIFO cost &amp; LIFO cost</strong></li></ul></li><li><p>Impact of valuation method:</p><ul><li><p>Assume unit price of Inventory is rising(very likely to happen in real-world)</p><table><thead><tr><th>LIFO</th><th>FIFO</th></tr></thead><tbody><tr><td>Higher COGS</td><td>Lower COGS</td></tr><tr><td>Lower EBIT</td><td>Higher EBIT</td></tr><tr><td>Lower Tax</td><td>Higher Tax</td></tr><tr><td>Lower Net income</td><td>Higher Net income</td></tr><tr><td>Lower Inventory book value</td><td>Higher Inventory book value</td></tr><tr><td>Lower Working capital</td><td>Higher Working capital</td></tr><tr><td>Higher CFO(less tax paid)</td><td>Lower CFO(more tax paid)</td></tr></tbody></table><ul><li>Working capital = CA - CL</li><li>Cash received from selling is the same for LIFO &amp; FIFO while FIFO pays more tax so it has lower CFO</li><li>Accounting ratio can be tested in conjugate with valuation method</li></ul></li></ul></li><li><p>Periodic &amp; perpetual assumption:</p><ul><li>如何确认库存中Inventory的总价?</li><li>Periodic inventory system(实地盘存制度):<ul><li>全年记录purchase, 在年末数一下库存数,用FIFO,LIFO etc. 算出 Year end inventory, 然后使用 Year start inventory + purchase - COGS(Unknown) = Year end inventory 求出全年的COGS</li><li>Only end of the year Inventory can be found</li></ul></li><li>Perpetual inventory system(永续盘存制度)<ul><li>全年记录每一次入库$purchase_{i}$, 某一时间点purchase是之前所有$purhcase_{i}$之和; 每出库一次用FIFO,LIFO etc. 算出这次出库的$COGS_{i}$, 全年某一时间点的COGS是之前所有$COGS_{i}$之和, 使用 Year start inventory + purchase - COGS =  Inventory at any time of the year(Unknown)</li><li>Inventory at any time of the year can be found but require more work</li></ul></li><li><strong>Under FIFO, we always get the same COGS &amp; Inventory at the end of the year for Periodic inventory system and perpetual inventory system</strong></li></ul></li><li><p>Impairment of inventory:</p><ul><li><p>Under IFRS:</p><ul><li>Net realizable value(NRV) = selling price - selling cost</li><li>If book value &gt; NRV, book value of inventory is written down to NRV with a loss recognized in the Income statement</li><li>Can be written up once NRV&gt;book value, but limited to the original cost of inventory(减值可逆)</li></ul></li><li><p>Under GAAP:</p><ul><li><p>Replacement cost: the cost of manufacture the same inventory today</p></li><li><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td><td>If replacement cost&gt;NRV, <strong>market = NRV</strong></td></tr><tr><td>NRV</td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td>If NRV-profit margin&lt;replacement cost&lt;NRV, <strong>market = replacement cost</strong></td></tr><tr><td></td><td></td></tr><tr><td>NRV - profit margin</td><td></td></tr><tr><td></td><td>If replacement cost&lt;NRV- profit margin, <strong>market = NRV - profit margin</strong></td></tr><tr><td></td><td></td></tr></tbody></table></li><li><p>If market&lt;book value, book value of inventory is written down to market with a loss recognized in the Income statement</p></li><li><p>GAAP中减值不可逆</p></li></ul></li></ul></li><li><p>For inventory with an active market it’s possible to record its book value using NRV. A gain or loss is recognized every time there is a change in NRV. It is very different from recoding book value using historical cost as there will be no impairment.</p></li><li><p>LIFO reserve(后进先出储备):</p><ul><li><p>By definition: <strong>FIFO inventory - LIFO inventory = LIFO reserve</strong> = $\Delta$<strong>inventory</strong></p></li><li><p>Opening$<em>{FIFO}$ + Purchase - COGS$</em>{FIFO}$ = Closing$_{FIFO}$………(1)</p><p>Opening$<em>{LIFO}$ + Purchase - COGS$</em>{LIFO}$ = Closing$_{LIFO}$……….(2)</p><p>(1) - (2) = Opening LIFO reserve +COGS$<em>{LIFO}$ - COGS$</em>{FIFO}$ = Closing LIFO reserve</p><p>​             = -<strong>$\Delta$LIFO reserve =  COGS$<em>{FIFO}$ -  COGS$</em>{LIFO}$ = $\Delta$COGS</strong></p></li><li><p><strong>NI$<em>{FIFO}$ = NI$</em>{LIFO}$ + $\Delta$LIFO reserve(1-tax rate)</strong></p></li><li><p><strong>RE$<em>{FIFO}$ = RE$</em>{LIFO}$ + $\Delta$LIFO reserve(1-tax rate)</strong></p></li><li><p><strong>Cash$<em>{FIFO}$ = Cash$</em>{LIFO}$ - $\Delta$LIFO reserve(tax rate)</strong></p></li></ul></li><li><p>LIFO liquidation(后进先出储备):</p><ul><li>In normal situation, $\Delta$LIFO reserve &gt; 0 as unit price of inventory is going up and volume of purchase is going up</li><li>There are two scenarios that  $\Delta$LIFO reserve &lt; 0:<ul><li>Unit price is dropping</li><li>Volume of purchase &lt;  Volume of sale. More specifically, the unit price is going <strong>up</strong> but there is less units of inventory in the warehouse. We call this scenario <strong>LIFO liquidation</strong></li></ul></li><li>During LIFO liquidation, $\Delta$LIFO reserve &lt; 0 so COGS$<em>{FIFO}$ &gt; COGS$</em>{LIFO}$. If we are recoding under LIFO, we will observe a drop in COGS$_{LIFO}$ which contradicts with the fact that unit price of inventory is rising. This will result in a higher profit margin and higher tax. However, the high profit margin is not sustainable as the unit price is actually rising. As an analyst, it is necessary to adjust Income statement to better reflect the company’s profitability.</li></ul></li></ol><h2 id="Long-Lived-Non-current-Assets"><a href="#Long-Lived-Non-current-Assets" class="headerlink" title="Long-Lived(Non-current) Assets"></a>Long-Lived(Non-current) Assets</h2><ol><li><p>Capitalizing(资本化) &amp; Expensing(费用化):</p><ul><li>Capitalizing(has future economic benefit)<ul><li>Expenditure can be capitalized as asset on Balance sheet(e.g. purchase of inventory)</li><li>Asset capitalized today will be transferred to Income statement as depreciation in the future</li><li>Cash outflow is classified as CFI</li></ul></li><li>Expensing(has no future economic benefit):<ul><li>Expenditure is transferred to Income statement today</li><li>Cash outflow is classified as CFO</li></ul></li></ul></li><li><p>Cost of tangible asset:</p><ul><li>How to determine the historical cost of a tangible asset?<ul><li>Costs <strong>necessary for the machine to be ready</strong> can be capitalized(purchase, tax, insurance, delivery, installation, testing etc.)</li><li>Costs on improving efficiency of machine can be capitalized(asset enhancement cost)</li><li>Other costs without future benefit are expense(depreciation, repair(恢复原状而不是提高效率), staff training etc.) </li></ul></li><li>Interest incurred due to the acquisition of tangible asset is capitalized as part of the book value of tangible asset and is a CFI out. As an analyst it is worth to treat this interest the same as interests on ordinary activities(expensing, CFO) to better reflect interest coverage ratio</li></ul></li><li><p>Tangible asset depreciation:</p><ul><li><p>Residual value: </p><ul><li>value of the asset in the market when useful life is reached</li><li>Under IFRS, residual value is allowed to adjust either upward or downward</li><li>Under GAAP, residual value is only allowed to adjust only downward</li></ul></li><li><p>Straight-line method:</p><p>Depreciation expense = $\frac{cost-residual\ value}{useful\ life}$</p><p>If cost(carrying value), residual value or useful life changes, future depreciation must be re-calculated but no backward adjustment is needed</p></li><li><p>Accelerated depreciation:</p><p>Depreciation expense = $\frac{2}{usefjul\ life}\times$(original cost - accumulated depreciation) ​=$\frac{2}{usefjul\ life}\times$NBV</p><p>More depreciation in earlier years and less in later years</p></li><li><p>Units of production:</p><p>Depreciation expense = $\frac{original\ cost-residual\ value}{capacity\ during\ useful\ life}\times$actual output in current period</p></li><li><p>Depreciation expense is allocated in COGS and SG&amp;A so it won’t be shown as a separated item on the Balance sheet</p></li></ul></li><li><p>Cost of intangible asset:</p><ul><li><p>Research cost is classified as expenditure under both GAAP &amp; IFRS</p></li><li><p>Development cost:</p><ul><li><p>IFRS: classified as expenditure unless <strong>technical feasibility is verified</strong></p></li><li><p>GAAP: classified as expenditure unless the cost is due to <strong>software development</strong>. </p><p>More specifically, cost of <strong>software for sale</strong> should be classified as expense until <strong>technical feasibility is verified</strong> and subsequent cost can be capitalized. Cost of software for own use can be capitalized if the <strong>project will be completed and use as intended</strong></p></li></ul></li><li><p>Goodwill = total cost of purchase - fair value of the target company’s net identifiable asset</p><ul><li><p>Net identifiable asset = fair value of identifiable assets - fair value of liabilities - contingent liabilities(或有负债)</p></li><li><p>If the target company company already has a goodwill item before purchase, it must be cleared to zero before calculating net identifiable asset</p></li><li><p>No amortization</p></li></ul></li></ul></li><li><p>Intangible asset amortization</p><ul><li>With a finite useful life:<ul><li>Amortized over useful life</li></ul></li><li>With a indefinite useful life:<ul><li>No amortization e.g. Goodwill</li><li>Must conduct impairment test at least annually</li></ul></li></ul></li><li><p>Impairment of long-lived assets:</p><ul><li>Long-lived asset is classified into <strong>held for use</strong> and <strong>held for sale</strong>.</li><li>Held for use under IFRS:<ul><li>Net book value(NBV) = cost - past impairment - accumulated depreciation</li><li>Net realistic value(NRV) = fair value - cost of sale</li><li>Value in use = PV of future cash flow</li><li>Recoverable amount is the higher of NRV and value in use</li><li>If NBV &gt; Recoverable amount, NBV after impairment = recoverable amount and a loss due to impairment is recorded in the income statement</li><li>Impairment loss can be revered but limited to previously accumulated impairment amount</li></ul></li><li>Held for use under GAAP:<ul><li>If NBV &gt; undiscounted future cash flow generated by the asset, NBV after impairment = fair market value(or PV of future cash when market value is not available) </li><li>Impairment loss cannot be reversed</li></ul></li><li>Held for sale:<ul><li>Held for sale asset can be re-classified from held for use asset.</li><li>An impairment test is conducted on the day of re-classification. If NBV &gt; NRV,  NBV after impairment = NRV and a loss is recognized</li><li>No further depreciation after re-classification</li><li>Impairment can be recovered under both IFRS &amp; GAAP but limited to previously accumulated impairment amount limited to previously accumulated impairment amount</li></ul></li></ul></li><li><p>Measurement of long-lived asset:</p><ul><li><p>Historical cost model(used above, under GAAP &amp; IFRS)</p></li><li><p>Fair value model(on investment property under IFRS only): </p><ul><li><p>Investment property: hold for earning rent and capital appreciation</p></li><li><p>Any change in fair value is recognized as gain/loss in the Income statement</p></li><li><p><strong>No depreciation</strong> on assets</p></li></ul></li><li><p>Revaluation model(Under IFRS only):</p><ul><li>Fair value on the day of revaluation is recorded as the revaluated cost, accumulated depreciation is cleared to zero</li><li>Assets depreciation in future years is updated based on the revaluated cost</li><li>Loss/gain is recognized based on the difference between NBV and fair value</li><li>If a gain is recognized, it should be recorded as OCI. If there is subsequent loss, OCI must be written-off to zero before recording loss in the income statement.</li><li>If a loss is recognized, it should be recorded as loss in the income statement. If there is subsequent gain, income statement loss must be written off to zero before gain is recorded on OCI</li><li>If there is still gain remaining in OCI when assets are sold, it is transferred to Retained earning directly without affecting Net income</li></ul></li></ul></li><li><p>Exchange of long-lived asset:</p><ul><li><p>Cost is recorded at the <strong>fair value of the asset it gives up</strong>.</p></li><li><p>Example:</p><table><thead><tr><th></th><th>NBV</th><th>Fair value</th></tr></thead><tbody><tr><td>A</td><td>10</td><td>15</td></tr><tr><td>B</td><td>9</td><td>14</td></tr></tbody></table><p>Asset <strong>A</strong> is used an asset with NBV = 10, Fair value = 15 to exchange asset <strong>B</strong> with NBV = 9, Fair value = 14.</p><ul><li><p>For the new owner of B, its NBV is recorded as the fair value of A so 15 and a gain of 5 is recognized</p></li><li><p>For the new owner of A, its NBV is recorded as the fair value of B so 14 and a gain of 5 is recognized</p></li></ul></li></ul></li></ol><h1 id="Income-Taxes"><a href="#Income-Taxes" class="headerlink" title="Income Taxes"></a>Income Taxes</h1><ol><li><p>Tax basics:</p><ul><li><p>Income statement is different from Tax return(纳税申报表)</p><table><thead><tr><th>Income statement</th><th>Tax return</th></tr></thead><tbody><tr><td>Revenue</td><td>Taxable revenue</td></tr><tr><td>- Expense</td><td>- Deductive expense</td></tr><tr><td>= EBT</td><td>= Taxable income</td></tr><tr><td>- Tax expense</td><td>Tax payable</td></tr><tr><td>= Net income</td><td></td></tr></tbody></table></li><li><p>Tax return follows cash. For example, tax must be paid even though cash is from prepaid revenue. Tax is only deductive when purchase due is paid with cash</p></li></ul></li><li><p>Deferred tax items:</p><ul><li><p>Taxable income and EBT may be different and difference can either be temporary(will be written-off in the future) or permanent</p></li><li><p>Temporary difference leads to deferred tax liability(DTL) and deferred tax asset(DTA). DTL, DTA will be written-off to zero in the end as difference is temporary</p></li><li><p>Permanent difference does not create DTL or DTA</p></li><li><p>DTL: </p><ul><li>More tax is paid today and less needs to be paid in the future. </li><li>$\Delta$DTL = 应纳税所得额差异(Taxable income比EBT少的部分)$\times$ future tax rate</li></ul></li><li><p>DTA:</p><ul><li>Less tax is paid today and more needs to be paid in the future</li><li>$\Delta$DTA = 可以扣所得额差异(Taxable income比EBT多的部分)$\times$ future tax rate</li></ul></li></ul></li><li><p>Two very important formulae </p><ul><li>Tax payable = Taxable income $\times$ Current tax rate      纳税申报表项目</li><li>Tax expense = tax payable + $\Delta$DTL - $\Delta$DTA   损益表项目</li></ul></li><li><p>Tax rate:</p><ul><li><p>Statutory tax rate(法定税率):</p><p>Tax payable = Taxable income $\times$ Current statutory rate</p></li><li><p>Effective tax rate:</p><p>Tax expense = EBT $\times$ Effective rate</p><p>where Tax expense = tax payable + $\Delta$DTL - $\Delta$DTA</p></li><li><p>Statutory tax rate = Effective tax rate when there is <strong>no permanent difference</strong></p></li></ul></li><li><p>Tax base(计税基础) &amp; Carrying value(账面价值):</p><ul><li>Carrying value is the same as net book value</li><li>可抵扣taxable income(未来少交税)可以由以下几个原因产生:<ul><li>现金流出(消费)可以抵扣taxable income</li><li>不需要交税的现金流入,例如别人还钱,有现金流入但不需要交税</li><li>现在多交税(DTA),可以抵扣未来的税</li></ul></li><li>Tax base of asset: 在未来可以抵扣taxable income的部分(在税务机关眼中值多少钱)</li><li>Tax base of liability: 在未来不可以抵扣应税收入的部分<ul><li>例子: 预收账款, 现金提前流入而利润未计入损益表, 提前交税, 均可以在未来抵扣taxable income所以tax base = 0</li><li>例子: 应付账款, 现金未流出, 当未来现金流出时均可以抵扣taxable income所以tax base = 0</li></ul></li><li>If there is a temporary difference, carrying value and tax base will be different</li></ul></li><li><p>A very important table: whether DTL or DTA is formed can be determined form this table</p><table><thead><tr><th></th><th>Carrying value &gt; Tax base</th><th>Carrying value  &lt; Tax base</th></tr></thead><tbody><tr><td>Asset</td><td>DTL (1)</td><td>DTA (3)</td></tr><tr><td>Liability</td><td>DTA (2)</td><td>DTL (4)</td></tr></tbody></table><p>(1): Tax base of an asset is small so less can be deductive in the future. More tax needs to be paid in the future so DTL is formed</p><p>(2): Tax base of an liability is small so less cannot be deductive in the future. More can be deductive in the future. Less tax needs to be paid in the future so DTA is formed</p><p>(3): Tax base of an asset is large so more can be deductive in the future. Less tax needs to be paid in the future so DTA is formed</p><p>(4): Tax base of an liability is large so more cannot be deductive in the future. Less can be deductive in the future. More tax needs to be paid in the future so DTL is formed</p></li><li><p>Summary of finding DTL and DTA:</p><ul><li>$\Delta$DTL/DTA = Difference between taxable income and EBT $\times$ future tax rate</li><li>DTL/DTA = Difference between carrying value and tax base $\times$ future tax rate</li><li>If a company makes a loss this year, a $\Delta$DTA= loss $\times$ future tax rate is formed to deduct future tax</li></ul></li><li><p>Change in statutory tax rate:</p><ul><li>Current tax rate is used when calculating Tax payable = Taxable income $\times$ current statutory tax rate</li><li>If there is a change in statutory rate in the future, future tax rate is used when calculating DTL, DTA, $\Delta$DTL, $\Delta$DTA</li><li>A change is DTL, DTA may be due to:<ul><li>Difference between carrying value and tax base changes while future tax rate stays unchanged</li><li>Difference between carrying value and tax base stays unchanged while future tax rate changes</li></ul></li><li>If there is an announcement of future change in statutory tax rate this year:<ul><li>Historical DTL must be adjusted which contributes part of $\Delta$DTL/DTA. Difference between EBT and Taxable income contributes to the other part of $\Delta$DTL/DTA</li><li>Another simpler way is using the difference between tax base and carrying value times future statutory rate so no need to worry about two components of $\Delta$DTL/DTA as we can find new DTL/DTA directly</li></ul></li></ul></li><li><p>Impairment of DTA:</p><ul><li>If there is a DTA, we can pay less tax in the future but it is on top of the company is generating profit. If the company is making a loss, no tax needs to be paid. DTA becomes unlikely to be written off to zero and it might lose its value so we need to consider impairment(Valuation allowance).</li><li>Net DTA = DTA - Valuation allowance with a tax expense generated</li><li>Valuation allowance may be reversed when future earning ability is expected to increase</li></ul></li><li><p>Classification of DTA and DTL:</p><ul><li>Under GAAP: either current or non-current based on when will be reversed</li><li>Under IFRS: non current</li></ul></li></ol><h2 id="Non-Current-Long-term-Liabilities"><a href="#Non-Current-Long-term-Liabilities" class="headerlink" title="Non-Current(Long-term) Liabilities"></a>Non-Current(Long-term) Liabilities</h2><ol><li><p>Bond basics:</p><ul><li><p>Bond is recorded using amortized cost</p></li><li><p>Face value(par value): amount that bondholder will receive at maturity</p></li><li><p>Coupon payment = Face value $\times$ Coupon rate</p></li><li><p>Effective rate of interest(ER): the discounting rate which equals issue price of bond and PV of future cash flow; Issue price = $\frac{Interest}{(1+ER)}+\frac{Interest}{(1+ER)^{2}}……+\frac{Face\ value+Interest}{(1+ER)^{n}}$</p><p>ER also equals <strong>market rate</strong> which is the rate of other bonds in the market with same risk</p></li><li><p>Interest expense = Amortized cost at the start of the period $\times$ ER</p></li><li><p>If market rate = coupon rate, issue price = par value. The bond is a par bond</p></li><li><p>If market rate &gt; coupon rate, issue price &lt; par value. The bond is a discount bond</p></li><li><p>If market rate &lt; coupon rate, issue price &gt; par value. The bond is a premium bond</p></li><li><p>Zero-coupon bond(零息债券): a bond with no interest, always issue at discount</p></li><li><p>Debt covenants: restriction imposed on the bond issuer to protect lender e.g. must make principal and interest payment in time; maintain a specified liquidity ratio</p></li></ul></li><li><p>Bond amortization:</p><ul><li><p>Interest expense = Amortized cost at the start of the period $\times$ ER</p></li><li><p>$\Delta$ = Interest expense - Coupon payment</p><p>$\Delta$ is used to amortized book value of the bond(实际利率法摊销)</p></li><li><p>Amortized cost at The start of the period + $\Delta$ = Amortized cost at The end of the period</p></li><li><p>In order to find the amortized cost at a specific year, there are two methods:</p><ul><li>Do calculation to find amortized cost in all previous years as well as the specified year</li><li><strong>Use calculator to find PV of future cash flow with the discounting rate = market rate</strong></li></ul></li></ul></li><li><p>Features of bond:</p><ul><li>For a discount bond, its interest expense increases with time and increases faster and faster</li><li>For a premium bond, its interest expense decreases with time and decreases faster and faster</li><li>If the market rate changes after bond issuance, we neglect the change and still use the market rate at issuance.</li></ul></li><li><p>Cash flow related to bond:</p><ul><li><p>Under GAAP:</p><ul><li>Interest payment: CFO</li><li>Principal payment: CFF</li></ul></li><li><p>Under IFRS:</p><ul><li>Interest payment: CFO or CFF</li><li>Principal payment: CFF</li></ul></li><li><p>As an analyst, we should not treat coupon payment as CFO because $\Delta$ = Interest expense - Coupon payment so interest expense is the true CFO cash out flow due to interest and $\Delta$ is a CFF item due to amortization</p><p>For example, If coupon payment = $100 CFO out flow. As an analyst, $100 CFO out flow must be split into $110 interest expense(CFO out flow) and $10 amortization(CFF inflow). The net cash flow stays unchanged</p></li></ul></li><li><p>Issuance cost(发行成本):</p><ul><li><p>Under GAAP: issuance cost is capitalized as asset and allocate to IS over the bond term</p></li><li><p>Under IFRS:</p><ul><li><p>Initial bond liability is reduced by the amount of issuance cost, effective rate(market rate) is adjusted.</p></li><li><p>Example: A bond with par value = 1000, coupon rate = 10%, market rate = 8%, <strong>issuance cost = 100</strong>, principal is paid in 3 years</p><p>PV of future cash flow = 1052 so a bond item is recorded as liability on BS and we get 1052 cash</p><p>However, there is a issuance cost of 100, we actually get 952 cash so we can only record the bond item as 952 and adjust effective rate $952 = \frac{100}{(1+ER)}+\frac{100}{(1+ER)^{2}}+\frac{1100}{(1+ER)^{3}}$ so ER = 12% which is higher than the original market rate due to the issuance cost</p></li></ul></li></ul></li><li><p>Derecognition of bond(提前终结债券):</p><ul><li>The bond issuer may redeem bond before maturity by buying bond from bond holder at repurchase price</li><li>Gain or loss due to repurchase under GAAP = Amortized cost - repurchase price - unamortized issuance cost</li></ul></li><li><p>Lease basics:</p><ul><li>Lessor(出租人): the owner of the asset</li><li>Lessee(承租人): use the asset for a specified period of time and pay rent</li><li>Operating lease: asset is still owned by lessor and rent is paid for right of use</li><li>Finance lease: lessee purchase an asset with debt(借钱买资产,所有权发生转移)</li><li>Principal of classification of financial lease:<ul><li>Transfer of ownership of asset</li><li>Covers major part of the asset’s useful life</li><li>PV of lease payment equal or exceed fair value of the asset</li><li>No longer useful to lessor after the lease ends</li><li>Other types of lease should be classified as operating lease</li></ul></li></ul></li><li><p>Accounting for lessee:</p><ul><li><p>Under IFRS:</p><ul><li>Only financial lease is allowed</li><li>Simplified operating lease can be used when there is a short-term lease or lease asset is at low value</li></ul></li><li><p>Under GAAP:</p><ul><li>Both financial lease and operating lease are allowed</li><li>Simplified operating lease can be used when there is a short term lease</li></ul></li><li><p>Simplified operating lease under IFRS &amp; GAAP:</p><ul><li>Nothing is recorded at the start of the lease</li><li>A <strong>CFO outflow(L)</strong> and a <strong>lease payment(E)</strong> expenditure is recorded when there is a payment</li><li>No depreciation</li></ul></li><li><p>Operating lease under GAAP:</p><ul><li><p>PV of future lease payment = X</p></li><li><p>A <strong>Lease liability(L)</strong>=X and a <strong>Right of use(A)</strong>=X are recorded at the start of the lease</p></li><li><p>A <strong>CFO outflow(L)</strong> and a <strong>lease payment(E)</strong> expenditure is recorded when there is a payment</p></li><li><p>Lease liability and Right of use are amortized by equal amount</p><p>Amortization = lease liability at the start of the period $\times$ Interest rate - Lease payment</p></li><li><p>No depreciation</p></li></ul></li><li><p>Financial lease under GAAP &amp; IFRS:</p><ul><li>PV of future lease payment = X</li><li>A <strong>Lease liability(L)</strong>=X and a <strong>Right of use(A)</strong>=X are recorded at the start of the lease</li><li>Depreciation of Right of use is calculated every year </li><li>A cash outflow(L) of Y is paid every year</li><li>Interest due to lease liability(E) = lease liability at the start of the period $\times$ Interest rate = Z which is the CFO outflow(L)</li><li>Reminder cash outflow(L) = Y-Z is used to amortize lease liability(A) so it is CFF</li></ul></li><li><p>Summary:</p><ul><li><p>Total cash outflow/expense for all the above methods are the same</p></li><li><p>Treatment for lease payment at the start of the year and at the end of the year will be slightly different</p></li><li><p>Interest cost in Financial lease decreases every year and decreases faster and faster</p><p>CFO in Financial lease decreases every year and decreases faster and faster</p><p>CFF in Financial lease increases every year and increases faster and faster</p></li></ul></li></ul></li><li><p>Accounting for lessor:</p><ul><li>Under IFRS: Financial lease and operating lease are allowed</li><li>Under GAAP: <ul><li>Financial lease and operating lease are allowed but financial lease is further split into <strong>sales-type</strong> and <strong>direct finance</strong></li><li>If lease payments are very likely to be collected and met criteria for Financial lease, it is sales-type</li><li>If the lease doesn’t meet the criteria for sales-type. Then, if there is either a <strong>third-party guaranteed residual value</strong> or <strong>future lease will cover asset’s cost</strong>, it is a direct financing lease</li><li>If none of these are met, it is an Operating lease</li></ul></li><li>Operating lease under IFRS &amp; GAAP:<ul><li>Nothing is recorded at the start of lease</li><li>A <strong>CFO inflow(A)</strong> and a <strong>Lease revenue(R)</strong> receipt is recorded when there is a payment</li><li>Depreciation of the Lease asset is also recorded every year</li></ul></li><li>Financial lease under IFRS &amp; Sales-type lease under GAAP:<ul><li>PV of future lease receipts = X</li><li>A <strong>Investment in lease(A)</strong>=X and a <strong>Lease revenue(R)</strong>=X are recorded at the start of the lease</li><li>Book value of the lease asset = Y</li><li>A <strong>Asset</strong> reduces by Y and a <strong>COGS(E)</strong>=Y are recorded at the start of the lease</li><li>A cash inflow(A) of Z is received every year</li><li>Interest received due to Investment in lease(R) = Investment in lease at the start of the period $\times$ Interest rate = M which is the CFO inflow(A)</li><li>Reminder cash inflow(A) = Z-M is used to amortize Investment in lease(L) so it is CFI(本质上是还钱)</li><li>No depreciation</li></ul></li><li>Direct financing lease under GAAP:<ul><li>PV of future lease receipts = X</li><li>A <strong>Investment in lease(A)</strong>=X and  <strong>Asset</strong> reduces by X are recorded at the start of the lease</li><li>A cash inflow(A) of Z is received every year</li><li>Interest received due to Investment in lease(R) = Investment in lease at the start of the period $\times$ Interest rate = M which is the CFO inflow(A)</li><li>Reminder cash inflow(L) = Z-M is used to amortized Investment in lease(L) so it is <strong>CFI</strong>(本质上是别人还钱)</li><li>No depreciation</li></ul></li></ul></li><li><p>Pension plan:</p><ul><li>Defined contribution plan(DC plan):<ul><li>Employer’s responsibility is to <strong>make fixed contribution(每期存一定数目的钱)</strong> to employee’s account and provide sufficient investment vehicles</li><li>Employee will bear investment risk and company don’t provide guarantee for how much an employee can get after retirement</li></ul></li><li>Defined benefit plan(DB plan):<ul><li>Employer’s responsibility is to make sure employee will get a fixed amount of money after retirement and the company don’t necessary need to make regular fixed contribution to employee’s account. Employer bear investment risk.</li><li>Company provide guarantee for how much an employee can get after retirement.</li></ul></li><li>Projected benefit obligation(PBO,预期结付义务): PV of future cash outflow due to pension payment so it is a liability.</li><li>Fair value of plan assets: how much a company prepared for future pension payment so it is an asset.</li><li>Fund status = Fair value of plan assets - PBO<ul><li>If Fund status&gt;0, a <strong>Net plan asset = Fund status</strong> is formed, the company has enough asset ready for future pension payment</li><li>If Fund status&lt;0, a <strong>Net plan liability = Fund status</strong> is formed, the company does not have enough asset ready for future pension payment</li></ul></li></ul></li></ol><h2 id="Financial-Reporting-Quality"><a href="#Financial-Reporting-Quality" class="headerlink" title="Financial Reporting Quality"></a>Financial Reporting Quality</h2><ol><li>Financial reporting quality:<ul><li>Provides decision-useful information</li><li>Information is relevance and faithful</li></ul></li><li>Earnings quality: return is sustainable and adequate(企业盈利多且可持续)</li><li>Ideally, we want both financial reporting quality and earning quality to be high. However, if financial reporting quality is low and earning quality is high, we could question the reliability of earning quality as the financial report is not a faithful representation(既然财报有问题,盈利质量再高也不可信). </li><li>Fraud triangle: A fraud can only happen with <strong>Motivation, opportunity and rationalization(在欺诈者看来正当的理由)</strong> </li></ol><h2 id="Applications-of-Financial-Statement-Analysis"><a href="#Applications-of-Financial-Statement-Analysis" class="headerlink" title="Applications of Financial Statement Analysis"></a>Applications of Financial Statement Analysis</h2><ol><li>Assessing credit risk(4C):<ul><li>Capacity(还款能力)</li><li>Collateral(抵押物)</li><li>Covenants(合约)</li><li>Character(还款意愿)</li></ul></li><li>Credit score: rating agency use formula that are weighted average of a number of accounting ratio and business characteristics includes:<ul><li>Scale and diversification</li><li>Operational efficiency: turnover ratios, ROA, operating margin etc.</li><li>Margin stability: stability of profitability</li><li>Leverage: financial leverage ratio</li></ul></li><li>Equity investment analysis(股票分析):<ul><li>Top-down analysis: 先选择一个宏观行业然后从中挑选合适的股票</li><li>Bottom-up analysis: 研究具体几个公司</li></ul></li><li>Investor types:<ul><li>Growth investor: value growth in share price</li><li>Value investor: value dividends payment</li><li>Market-oriented investor: not specific preference but oriented by market trend</li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Introduction-to-Financial-Statement-Analysis&quot;&gt;&lt;a href=&quot;#Introduction-to-Financial-Statement-Analysis&quot; class=&quot;headerlink&quot; title=&quot;Introduction to Financial Statement Analysis&quot;&gt;&lt;/a&gt;Introduction to Financial Statement Analysis&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Users of financial report:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/07/14/NzCsMRJXqwSDn4a.png&quot; alt=&quot;Report_user.png&quot;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Information available for analysis:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/07/14/GcmoNlsvytPd1zZ.png&quot; alt=&quot;Information_for_analysis.png&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Financial statement is part of Financial report&lt;/li&gt;
&lt;li&gt;Footnotes: 披露会计方法(e.g. FIFO, LIFO), 折旧方法, 表中数值的计算过程&lt;/li&gt;
&lt;li&gt;MD&amp;amp;A: past performance, future outlook, off-balance-sheet obligations(表外负债:不太可能产生的负债所以不会被计入BS), MD&amp;amp;A don’t need to be audited&lt;/li&gt;
&lt;li&gt;Audit: provide opinion on &lt;strong&gt;financial statements&lt;/strong&gt; and internal controls(内控)&lt;ul&gt;
&lt;li&gt;Unqualified opinion: a true and fair view&lt;/li&gt;
&lt;li&gt;Qualified opinion: make some errors against accounting principal&lt;/li&gt;
&lt;li&gt;Adverse opinion(否定意见): not present a fair view&lt;/li&gt;
&lt;li&gt;Disclaimer of opinion(无法表达意见): scope limitation(not enough information provided)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Finance" scheme="https://yuxuanliu.tech/categories/Finance/"/>
    
    
      <category term="CFA" scheme="https://yuxuanliu.tech/tags/CFA/"/>
    
      <category term="Finance" scheme="https://yuxuanliu.tech/tags/Finance/"/>
    
  </entry>
  
  <entry>
    <title>CFA Quantitative method Notes</title>
    <link href="https://yuxuanliu.tech/CFA_Quantitative_method/"/>
    <id>https://yuxuanliu.tech/CFA_Quantitative_method/</id>
    <published>2020-06-18T22:26:58.000Z</published>
    <updated>2020-06-18T15:47:06.510Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Time-value-of-money"><a href="#Time-value-of-money" class="headerlink" title="Time value of money"></a>Time value of money</h2><ol><li><p>Applications of interest rate:</p><ul><li>Required rate of return: minimum rate of return must receive to accept an investment</li><li>Discount rate: cash in the future is discounted to find the value today</li><li>Opportunity cost: 因为做了A投资,所以必须放弃B投资,B投资的收益就是opportunity cost</li></ul></li><li><p>Components of interest rate:</p><ul><li>Nominal risk-free rate(rf) = US Treasury bond(T-bond) rate = real risk-free rate + inflation rate</li><li>Risk premium = Default risk premium + Liquidity premium + Maturity premium</li><li>Nominal interest rate = Nominal risk-free rate + Risk premium</li></ul></li><li><p>Effective Annual Rate(EAR):</p><ul><li>EAR = $(1+\frac{r_{s}}{m})^{m}$</li><li>$r_{s}$: nominal rate</li><li>m: compounding frequency</li></ul><a id="more"></a></li><li><p>Continuous compounding:</p><ul><li>EAR = $e^{r_{s}}-1$</li><li>Continuous compounding EAR is the maximum return for a given $r_{s}$</li></ul></li><li><p>Annuity:</p><ul><li>A set of <strong>fixed</strong> cash flows</li><li>Ordinary annuity: cash inflow at the end of each period</li><li>Annuity due: cash inflow at the beginning of each period</li><li>Perpetuity(永续年金): never ending cash inflow at the end of each period</li><li>Present value of a perpetuity with a periodic cash inflow of A = $\frac{A}{r}$</li></ul></li></ol><h2 id="Basic-statistics"><a href="#Basic-statistics" class="headerlink" title="Basic statistics"></a>Basic statistics</h2><ol><li><p>Parameter: any measure of a <strong>population</strong> characteristic</p></li><li><p>Sample statistics: any measure of a <strong>sample</strong> characteristic</p></li><li><p>Measurement scales:</p><ul><li><p>Nominal scale: no ranking between groups(没有排名)</p></li><li><p>Ordinal scale: there is ranking between groups(有排名)</p></li><li><p>Interval scale: difference between any two scales are equal and can be quantized(前后一名差距相同)</p></li><li><p>Ratio scale: there is a <strong>true zero point</strong> at the zero scale(真实零点,零点即代表没有)</p></li></ul></li><li><p>Central tendency:</p><ul><li><p>Types of mean:</p><ul><li><p>Arithmetic mean: focus on average <strong>single-period</strong> performance(预测未来一期的收益)</p></li><li><p>Weighted mean</p></li><li><p>Geometric mean: focus on average <strong>multi-period</strong> performance as it takes into account compounding interest(预测未来多期的收益)</p></li><li><p>Periodic compound return = $\sqrt[n]{(1+R_{1})(1+R_{2})……(1+R_n)}-1$ </p><p>where $R_{i}$ is the return in each <strong>equal period</strong></p></li><li><p>Time weighted return(TWR) = $\sqrt[N]{(1+HPR_{1})(1+HPR_{2})……(1+HPR_{n})}-1$ </p><p>where HPR: holding period return, N is the total holding time in years</p><p>TWR is very similar to periodical compound return but <strong>holding periods in TWR are not necessarily to be equal</strong></p></li><li><p>Harmonic mean(调和平均数) = $$\bar{X}<em>{Harmonic}=\frac{N}{\sum</em>{i=1}^{N} \frac{1}{X_{i}}}$$</p><p>used to find average cost per share purchased at different time(基金定投)</p></li></ul></li><li><p>Harmonic mean &lt; Geometric mean &lt; Arithmetic mean</p><p>$\sigma$ 越大,三种平均数之间的差距越大</p></li><li><p>Median</p></li><li><p>Mode</p></li><li><p>Quantile: a value at or below which a stated fraction(<strong>y</strong>) of the data lies</p><p>Location of the value = (n+1)$\frac{y}{100}$</p><p>Quartiles: 四分位 Quintiles: 五分位 Deciles: 十分位 Percentiles: 百分位</p></li></ul></li><li><p>Dispersion:</p><ul><li>Range = maxima - minima</li><li>Mean absolute deviation(MAD) = $\frac{\sum_{i=1}^{n}\left|x_{1}-\bar{x}\right|}{n}$</li><li>Population variance= $\sigma^{2}=\frac{\sum_{i=1}^{N}(X_{i}-\mu)^{2}}{N}$ where $\mu$ is the population mean</li><li>Sample variance = $s^{2}= \frac{\sum_{i=1}^{N}(X_{i}-\bar{X})^{2}}{n-1}$ where $\bar{X}$ is the sample mean, <strong>degree of freedom = n-1</strong></li><li>Population standard deviation = $\sigma = \sqrt{\frac{\sum_{i=1}^{N}(X_{i}-\mu)^{2}}{N}}$</li><li>Sample standard deviation = $s = \sqrt{\frac{\sum_{i=1}^{N}(X_{i}-\bar{X})^{2}}{n-1}}$</li></ul></li><li><p>Chebyshev’s inequality: <strong>minimum percentage of population</strong> that lies within <strong>k</strong> standard deviation of the mean would be $1- \frac{1}{k^{2}}$ </p></li><li><p>Coefficient of variation(CV) = $\frac{S}{\bar{X}}$, standard deviation over mean</p></li><li><p>Sharpe ratio(SR) = $\frac{\bar{R_{p}}-\bar{R_{F}}}{\sigma_{p}}$  where $\bar{R_{P}}$ is the mean return of the portfolio, $\bar{R_{F}}$ is the mean risk-free return, $\sigma_{P}$ is the standard deviation of the portfolio reurn.</p><p>  In other word, it is measuring the excess return earned for every unit of standard deviation</p></li><li><p>Skewness(偏度):</p><ul><li>Skewness = 0, symmetrical distribution, mean = mode = median</li><li>Skewness &gt; 0, 尾部右偏(正偏), mode &lt; median &lt; mean</li><li>Skewness &lt; 0, 尾部左边(负偏), mean &lt; median &lt; mode</li></ul></li><li><p>Kurtosis(峰度):</p><ul><li><strong>Normal distribution has a kurtosis of 3</strong></li><li>Excess kurtosis = kurtosis -3</li><li>Leptokurtic: kurtosis&gt;3, more peaked, fatter tail(高尖肥尾)</li><li>Mesokurtic: kurtosis=3, identical to normal distribution</li><li>Platykurtic: kurtosis&lt;3, less peaked, thinner tail(低尖瘦尾)</li></ul></li></ol><h2 id="Basic-probability"><a href="#Basic-probability" class="headerlink" title="Basic probability"></a>Basic probability</h2><ol><li><p>Random variable: a quantity whose possible values are uncertain</p></li><li><p>Outcome: a result of a random experiment </p></li><li><p>Event: A set of outcomes</p></li><li><p>Exhaustive events(遍历的): events cover all possible outcomes so P(A)=1</p></li><li><p>Types of probability:</p><ul><li>Empirical probability: estimate probability based on <strong>historical data</strong></li><li>Priori probability: estimate probability based on <strong>logical analysis</strong></li><li>subjective probability: estimate probability without referencing any data</li></ul></li><li><p>Odds(赔率):</p><ul><li>Odds for a event E = $\frac{P(E)}{1-P(E)}$</li><li>Odds against a event E = $\frac{1-P(E)}{P(E)}$</li></ul></li><li><p>Multiplication rule:</p><ul><li>P(A and B)=$P(AB) = P(A|B)P(B)$</li><li>If A and B are independent, $P(AB) = P(A)P(B)$</li></ul></li><li><p>Addition rule:</p><ul><li>P(A or B) = $P(A+B)=P(A)+P(B)-P(AB)$</li><li>If A and B are independent, P(A+B) = P(A)+P(B)-P(A)P(B)</li></ul></li><li><p>Total probability rule: $P(A) = P(A|S_{1})P(S_{1})+P(A|S_{2})P(S_{2})+……P(A|S_{n})P(S_{n})$</p><p>where $S_{i}$ must be mutually exclusive and exhaustive so $\sum_{i=1}^{n} s_{i}=1$</p></li><li><p>Bayes’ Formula: $P(A|B)P(B)=P(B|A)P(A)$</p></li><li><p>Probability weighted variance: </p><p>$\sigma ^{2} = P(x_{1})(x_{1}-E(x))^{2}+P(x_{2})(x_{2}-E(x))^{2}……P(x_{n})(x_{n}-E(x))^{2} = E([x-E(x)]^{2}) = E(x^{2})-E(x)^{2}$</p></li><li><p>Covariance:</p><ul><li>$Cov(X,Y)=E[(X-E(X))(Y-E(Y)]$</li><li>X and Y must appear in pairs</li><li>Measure the linear relationship between two variables</li><li>Positive covariance: two variables tend to increase or decrease at the same time</li><li>Negative covariance: one variable increases when the other decreases Vice versa</li><li>Zero covariance: no linear relationship between two variables</li></ul></li><li><p>Correlation:</p><ul><li>Population correlation= $\rho = \frac{Cov(x,y)}{\sigma_{x}\sigma_{y}}$</li><li>Sample correlation= r = $\frac{Cov(x,y)}{s_{x}s_{y}}$</li><li>Correlation removes the influence of order of magnitude compared to covariance</li><li>Correlation = 1, perfect positive linear relationship, Correlation = -1, perfect negative linear relationship</li></ul></li></ol><h2 id="Probability-distribution"><a href="#Probability-distribution" class="headerlink" title="Probability distribution"></a>Probability distribution</h2><ol><li>Discrete distribution:<ul><li>A countable number of outcomes</li><li>Probability function:  穷举每个outcome的概率 e.g. P(X=1)=0.1,P(X=2)=0.1 etc.</li><li>Bernoulli random variable: only two outcomes 1 or 0<ul><li>1 represents success i.e. P(Y=1) = P</li><li>0 represents failure i.e. P(Y=0) = 1-P</li><li>E(Y) = P</li><li>$\sigma_{Y}$=P(1-P)</li></ul></li><li>Binomial distribution:<ul><li>Random variable(X): <strong>number of success in Bernoulli trials</strong></li><li>X <strong>~</strong> B(n,p), Binomial distribution takes two parameters where n is total number of trials and P is success rate</li><li>$P(X=x)= (nCx)P^{x}(1-P)^{n-x}$</li><li>E(X)=nP</li><li>$\sigma_{X}=nP(1-P)$</li></ul></li></ul></li><li>Continuous distribution:<ul><li>Outcome is usually a range</li><li>Probability density function <strong>f(x)</strong>:<ul><li>$P(x_{1}&lt;X&lt;x_{2})=\int ^{x_{2}}<em>{x</em>{1}}f(x)dx$</li><li>$P(X=x_{1})=0$</li></ul></li><li>Cumulative probability function <strong>F(x)</strong>:<ul><li>$F(x_{1})=P(X\leq x_{1})=\int ^{x_{1}}_{-\infty}f(x)dx$</li><li>Gives the probability of a random variable less or equal to $x_{1}$</li></ul></li><li>Normal distribution:<ul><li>X <strong>~</strong> N($\mu,\sigma$), probability density function is described by two parameters  </li><li>Skewness = 0</li><li>Kurtosis = 3</li></ul></li><li>Standard normal distribution(z distribution):<ul><li>$Z = \frac{X-\mu}{\sigma}$ so Z is a random variable as $\mu,\sigma$ are fixed and X is a random variable</li><li>Z <strong>~</strong> N(0,1) i.e. a normal distribution with zero mean and standard deviation of 1</li></ul></li><li>Lognormal distribution:<ul><li>If X<strong>~</strong> N($\mu,\sigma$), $e^{X}$<strong>~</strong>  lognormal</li><li>If X​<strong>~</strong>  lognormal, $ln(X)$ <strong>~</strong> N($\mu,\sigma$)</li><li>positive skewed</li></ul></li><li>Student t distribution(t distribution):<ul><li>X <strong>~</strong> t(n-1) defined by a single parameter <strong>n-1(degree of freedom) where n is the sample size</strong></li><li>Less peaked and fat tail(低峰肥尾)</li><li>As n increase, t distribution is approaching normal distribution</li><li>For a given degree of confidence, t distribution has a wider confidence interval than z distribution</li></ul></li></ul></li><li>Shortfall risk: the possibility the portfolio return will be less than $R_{L}$ i.e. P(X&lt;$R_{L}$)=F($R_{L}$)</li><li>Safety first ratio: <ul><li>distance from the mean return to shortfall level($R_{L}$) in units of standard deviation</li><li>SF ratio = $\frac{E(R_{P})-R_{L}}{\sigma}$</li><li>Sharpe ratio is a special case of SF ratio(when risk free return equals $R_{L}$)</li></ul></li><li>Monte Carlo simulation: use randomly generated values without the use of historical data</li><li>Historical simulation: use randomly selected past data</li></ol><h2 id="Sampling"><a href="#Sampling" class="headerlink" title="Sampling"></a>Sampling</h2><ol><li><p>Types of data:</p><ul><li>Time-series: same object at different time</li><li>Cross-sectional: different object at same time</li></ul></li><li><p>Types of sampling:</p><ul><li>Simple random sampling(简单随机抽样)</li><li>Stratified random sampling(分层抽样)</li></ul></li><li><p>Sampling error: difference between sample statistics and the actual population parameter</p></li><li><p><strong>Sampling distribution: the distribution of sample statistics</strong>(A sample statistics is a random variable so we can draw a probability density function of it)</p></li><li><p>Sampling biases:</p><ul><li>Data-mining bias: 强行找统计上的关系尽管事实上没有关系,所谓的统计关系只是巧合</li><li>Sample selection bias</li><li>Survivorship bias</li><li>Look-ahead bias: use data that was not available on the test date</li><li>Time-period bias: only take samples within a time period will make the result time-period specific</li></ul></li><li><p>Estimator and its properties:</p><ul><li>Estimator: A random variable that generates estimation of a population parameter For example: sample mean($\bar{X}$) is used to estimate population mean($\mu$)</li><li>Unbiasedness: expected value of the estimator equals the population parameter</li><li>Consistency: probability of estimator gets close to the population parameter increases with sample size</li><li>Efficiency: the unbiased distribution of the estimator with the smallest variance(多次抽样可以产生许多个estimator的distribution,方差最小的distribution我们说它具有efficiency)</li></ul></li><li><p>Central limit theorem: </p><ul><li><p>given a population described by any probability distribution with a population mean($\mu$) and variance($\sigma ^{2}$), the <strong>sampling distribution</strong> of sample mean($\bar{X}$)  with a sample size <strong>n&gt;30</strong> will be approximately normal with mean=$\mu$ and variance=$\frac{\sigma ^{2}}{n}$ </p></li><li><p>Standard error(standard deviation of the sampling distribution):</p><ul><li><p>when population standard deviation($\sigma$) is known:</p><p>$$\sigma_{x}=\frac{\sigma}{\sqrt{n}}$$</p></li><li><p>when population standard deviation($\sigma$) is <strong>not</strong> known, we use sample standard deviation($s$) instead:</p><p>$$s_{x}=\frac{s}{\sqrt{n}}$$</p></li></ul></li><li><p>Change normal distribution into standard normal distribution: $\bar{X}$ <strong>~</strong> N($\mu,\frac{\sigma ^{2}}{n}$) so $\frac{\bar{X}-\mu}{\frac{\sigma}{\sqrt{n}}}$ <strong>~</strong> N(0,1)</p></li><li><p>A very important table:</p><table><thead><tr><th>Population distribution</th><th>Variance of  population</th><th>Small sample size(n&lt;30)</th><th>Large sample size(n&gt;30)</th></tr></thead><tbody><tr><td>Normal distribution</td><td>known</td><td>Normal distribution</td><td>Normal distribution</td></tr><tr><td>Normal distribution</td><td>not known</td><td>T distribution</td><td>T distribution</td></tr><tr><td>Non-normal</td><td>known</td><td>Can’t do</td><td>Normal distribution</td></tr><tr><td>Non-normal</td><td>not known</td><td>Can’t do</td><td>T distribution</td></tr></tbody></table></li></ul></li><li><p>Point estimate: used a sample statistics to estimate population parameter directly</p></li><li><p>Confidence interval:</p><ul><li>Significance level($\alpha$): probability of sample statistics <strong>not</strong> fall in the confidence interval</li><li>Degree of confidence(1-$\alpha$): probability of sample statistics will fall in the confidence interval</li><li>Confidence interval = point estimate $\pm$ reliability factor$\times$ standard error</li></ul></li></ol><h2 id="Hypothesis-testing"><a href="#Hypothesis-testing" class="headerlink" title="Hypothesis testing"></a>Hypothesis testing</h2><ol><li><p>Hypothesis testing:</p><ul><li>An act to test an assumption regarding a <strong>population parameter</strong></li><li>Null hypothesis($H_{0}$): hypothesis to be tested</li><li>Alternative hypothesis($H_{a}$): the opposite side of null hypothesis so they must be mutually exclusive and exhaustive</li><li>The ‘<strong>=</strong>‘ sign must be in null hypothesis and null hypothesis is the assumption we wish to reject</li></ul></li><li><p>Two tailed test: used to test if the population parameter is different from a specific value</p><p>Example: $H_{0}:\mu = \mu_{0}$, $H_{a}: \mu \not= \mu_{0}$</p></li><li><p>One tailed test: used to test if the population parameter is greater or less than a specific value</p><p>Example: $H_{0}:\mu &gt; \mu_{0}$, $H_{a}: \mu \leq \mu_{0}$ <strong>rejection region is on the left</strong></p><p>Example: $H_{0}:\mu &lt; \mu_{0}$, $H_{a}: \mu \geq \mu_{0}$ <strong>rejection region is on the right</strong></p></li><li><p>Test statistic: <strong>A value calculated to test the null hypothesis</strong></p><ul><li><p>Mean of a single population:</p><ul><li><p>假设null hypothesis是正确的,以此为mean构建sample distribution(应用central limit theorem),看实际抽样的sample statistics是否落在significance level($\alpha$)对应的confidence interval以内,若在外面则可以作为依据来reject </p></li><li><p>When population variance is known(Z distribution):</p><p>$z=\frac{\bar{x}-\mu_{0}}{\frac{\sigma}{\sqrt{n}}}$</p></li><li><p>When population variance is not known(T distribution):</p><p>$t_{n-1}=\frac{\bar{X}-\mu_{0}}{\frac{S}{\sqrt{n}}}$</p></li></ul></li><li><p>Difference of mean of two independent population(两组数平均数的差为随机变量):</p><ul><li>T distribution</li><li>Assume variance of two population are unknow but equal, <strong>degree of freedom</strong> = $n_{1}+n_{2}-2$</li></ul></li><li><p>Mean difference of two independent population(两组数中每一对求差,差的平均数为随机变量):</p><ul><li>T distribution</li><li><strong>degree of freedom</strong> = n-1</li></ul></li><li><p>Variance of a single population:</p><ul><li>Chi-square distribution($X^{2}$ distribution)</li><li>degree of freedom = n-1</li></ul></li><li><p>Whether variance of two independent population are equal:</p><ul><li>Fisher distribution($F$ distribution)</li><li>Test statistics = $\frac{S_{1}^{2}}{S_{2}^{2}}$,  $S_{1}$ 和 $S_{2}$ 中大的放在分子以确保test statistics is greater than 1</li><li>Degrees of freedom:($n_{1}-1$) and ($n_{2}-1$)</li></ul></li><li><p>Correlation of two independent population</p><ul><li>sample size must be equal</li><li>T distribution</li><li>Test statistics = $\frac{r\sqrt{n-2}}{\sqrt{1-r^{2}}}$ where $r$ is the correlation of the samples</li><li>degree of freedom = n-2</li></ul></li></ul></li><li><p>Decision rule:</p><ul><li>We <strong>assume null hypothesis is true</strong> to calculate test statistics</li><li>If Test statistics is outside the range of critical value, we reject null hypothesis</li><li>P-value is less than the significance level($\alpha$), we reject null hypothesis</li></ul></li><li><p>Types of result of hypothesis test:</p><ul><li><p>Type I error: </p><ul><li>rejecting null hypothesis when it is true</li><li>P(Type I error) = significance level($\alpha$)</li></ul></li><li><p>Type II error:</p><ul><li>fail to reject null hypothesis when it is false</li><li>p(Type II error) = $\beta$</li></ul></li><li><p>Correct decision: fail to reject null hypothesis when it is true</p></li><li><p>Power of test: reject the null hypothesis when it is false</p></li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Time-value-of-money&quot;&gt;&lt;a href=&quot;#Time-value-of-money&quot; class=&quot;headerlink&quot; title=&quot;Time value of money&quot;&gt;&lt;/a&gt;Time value of money&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Applications of interest rate:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Required rate of return: minimum rate of return must receive to accept an investment&lt;/li&gt;
&lt;li&gt;Discount rate: cash in the future is discounted to find the value today&lt;/li&gt;
&lt;li&gt;Opportunity cost: 因为做了A投资,所以必须放弃B投资,B投资的收益就是opportunity cost&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Components of interest rate:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Nominal risk-free rate(rf) = US Treasury bond(T-bond) rate = real risk-free rate + inflation rate&lt;/li&gt;
&lt;li&gt;Risk premium = Default risk premium + Liquidity premium + Maturity premium&lt;/li&gt;
&lt;li&gt;Nominal interest rate = Nominal risk-free rate + Risk premium&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Effective Annual Rate(EAR):&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;EAR = $(1+\frac{r_{s}}{m})^{m}$&lt;/li&gt;
&lt;li&gt;$r_{s}$: nominal rate&lt;/li&gt;
&lt;li&gt;m: compounding frequency&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Finance" scheme="https://yuxuanliu.tech/categories/Finance/"/>
    
    
      <category term="CFA" scheme="https://yuxuanliu.tech/tags/CFA/"/>
    
      <category term="Finance" scheme="https://yuxuanliu.tech/tags/Finance/"/>
    
  </entry>
  
  <entry>
    <title>IB Linear Systems and Control notes</title>
    <link href="https://yuxuanliu.tech/IB_Linear_System_and_Control/"/>
    <id>https://yuxuanliu.tech/IB_Linear_System_and_Control/</id>
    <published>2020-05-15T23:28:07.000Z</published>
    <updated>2020-05-15T16:37:39.470Z</updated>
    
    <content type="html"><![CDATA[<h1 id="IB-Paper-6-Linear-Systems-amp-Control-Notes"><a href="#IB-Paper-6-Linear-Systems-amp-Control-Notes" class="headerlink" title="IB Paper 6 Linear Systems &amp; Control Notes"></a>IB Paper 6 Linear Systems &amp; Control Notes</h1><p>This is my personal notes abstract from the Linear Systems and Control course given by the Department of Engineering, University of Cambridge. This course introduces basic ideas in Linear System and Control Theory. It includes the following topics: Signal &amp; System, Laplace Transform, Impulse Response, Step Response, Transfer Function, Stability &amp; Poles, Frequency Response &amp; Steady State Response, Feedback Control System, Bold Diagram, PID Control, Nyquist Diagram and Feedback Stability.</p><p>Lectures are given by Dr. Lestas. If you spot any mistake or have any questions, please don’t hesitate to contact me. Many thanks</p><a id="more"></a><p><img src="https://i.loli.net/2020/05/16/6xt2JS75wRiHuX8.jpg" alt="1.jpg"></p><p><img src="https://i.loli.net/2020/05/16/9JY4pjqMTcWHmvZ.jpg" alt="2.jpg"></p><p><img src="https://i.loli.net/2020/05/16/o5GQXebPmy2JTIs.jpg" alt="3.jpg"></p><p><img src="https://i.loli.net/2020/05/16/UHIopQGaVXuCT8w.jpg" alt="4.jpg"></p><p><img src="https://i.loli.net/2020/05/16/KXqvh2QcDCaAulz.jpg" alt="5.jpg"></p><p><img src="https://i.loli.net/2020/05/16/cWGPng5whAQDxqp.jpg" alt="6.jpg"></p><p><img src="https://i.loli.net/2020/05/16/7BYnXLU6oCsclKf.jpg" alt="7.jpg"></p><p><img src="https://i.loli.net/2020/05/16/FepRbgtmiIEfTxz.jpg" alt="8.jpg"></p><p><img src="https://i.loli.net/2020/05/16/8zQdxZK3UCPoeuc.jpg" alt="9.jpg"></p><p><img src="https://i.loli.net/2020/05/16/SLaqnhtrjFcDeMw.jpg" alt="10.jpg"></p><p><img src="https://i.loli.net/2020/05/16/BHpfiCxQ61bAITE.jpg" alt="11.jpg"></p><p><img src="https://i.loli.net/2020/05/16/qtucK74jXgnWISf.jpg" alt="12.jpg"></p><p><img src="https://i.loli.net/2020/05/16/rxUL8ak1cMXG96C.jpg" alt="13.jpg"></p><p><img src="https://i.loli.net/2020/05/16/fdPCiDsHB4FulQ5.jpg" alt="14.jpg"></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;IB-Paper-6-Linear-Systems-amp-Control-Notes&quot;&gt;&lt;a href=&quot;#IB-Paper-6-Linear-Systems-amp-Control-Notes&quot; class=&quot;headerlink&quot; title=&quot;IB Paper 6 Linear Systems &amp;amp; Control Notes&quot;&gt;&lt;/a&gt;IB Paper 6 Linear Systems &amp;amp; Control Notes&lt;/h1&gt;&lt;p&gt;This is my personal notes abstract from the Linear Systems and Control course given by the Department of Engineering, University of Cambridge. This course introduces basic ideas in Linear System and Control Theory. It includes the following topics: Signal &amp;amp; System, Laplace Transform, Impulse Response, Step Response, Transfer Function, Stability &amp;amp; Poles, Frequency Response &amp;amp; Steady State Response, Feedback Control System, Bold Diagram, PID Control, Nyquist Diagram and Feedback Stability.&lt;/p&gt;
&lt;p&gt;Lectures are given by Dr. Lestas. If you spot any mistake or have any questions, please don’t hesitate to contact me. Many thanks&lt;/p&gt;
    
    </summary>
    
    
      <category term="University notes" scheme="https://yuxuanliu.tech/categories/University-notes/"/>
    
    
      <category term="Information" scheme="https://yuxuanliu.tech/tags/Information/"/>
    
      <category term="Engineering" scheme="https://yuxuanliu.tech/tags/Engineering/"/>
    
  </entry>
  
  <entry>
    <title>IB Signal and Data Analysis notes</title>
    <link href="https://yuxuanliu.tech/IB_Signal_and_Data_Analysis/"/>
    <id>https://yuxuanliu.tech/IB_Signal_and_Data_Analysis/</id>
    <published>2020-05-13T20:52:47.000Z</published>
    <updated>2020-05-13T14:00:02.655Z</updated>
    
    <content type="html"><![CDATA[<h1 id="IB-Paper-6-Signal-and-Data-Analysis-Notes"><a href="#IB-Paper-6-Signal-and-Data-Analysis-Notes" class="headerlink" title="IB Paper 6 Signal and Data Analysis Notes"></a>IB Paper 6 Signal and Data Analysis Notes</h1><p>This is my personal notes abstract from the Signal and Data Analysis course given by the Department of Engineering, University of Cambridge. This course introduces basic tools in data analysis including: Fourier’s Series, Fourier’s Transform and Sampling theory.</p><p>Lectures are given by Dr. Godsill. If you spot any mistake or have any questions, please don’t hesitate to contact me. Many thanks</p><a id="more"></a><p><img src="https://i.loli.net/2020/05/13/asVO7Ze6DhWNoil.jpg" alt="1.jpg"></p><p><img src="https://i.loli.net/2020/05/13/mCM1G6g5QlJoSzW.jpg" alt="2.jpg"></p><p><img src="https://i.loli.net/2020/05/13/ijcCpuJhx3Xl2E5.jpg" alt="3.jpg"></p><p><img src="https://i.loli.net/2020/05/13/nIG6rzQZeC1kwLp.jpg" alt="4.jpg"></p><p><img src="https://i.loli.net/2020/05/13/JCfbSiEUsxpt6XZ.jpg" alt="5.jpg"></p><p><img src="https://i.loli.net/2020/05/13/H8cvN1SLiJKgudU.jpg" alt="6.jpg"></p><p><img src="https://i.loli.net/2020/05/13/BtPwGSQIY1L7zeu.jpg" alt="7.jpg"></p><p><img src="https://i.loli.net/2020/05/13/rHQmw1Ti5zjvIy3.jpg" alt="8.jpg"></p><p><img src="https://i.loli.net/2020/05/13/JbM9CklFx6AnHZ8.jpg" alt="9.jpg"></p><p><img src="https://i.loli.net/2020/05/13/QIA6Rd5G7SrNb2P.jpg" alt="10.jpg"></p><p><img src="https://i.loli.net/2020/05/13/5SHLogNmelCnqU1.jpg" alt="11.jpg"></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;IB-Paper-6-Signal-and-Data-Analysis-Notes&quot;&gt;&lt;a href=&quot;#IB-Paper-6-Signal-and-Data-Analysis-Notes&quot; class=&quot;headerlink&quot; title=&quot;IB Paper 6 Signal and Data Analysis Notes&quot;&gt;&lt;/a&gt;IB Paper 6 Signal and Data Analysis Notes&lt;/h1&gt;&lt;p&gt;This is my personal notes abstract from the Signal and Data Analysis course given by the Department of Engineering, University of Cambridge. This course introduces basic tools in data analysis including: Fourier’s Series, Fourier’s Transform and Sampling theory.&lt;/p&gt;
&lt;p&gt;Lectures are given by Dr. Godsill. If you spot any mistake or have any questions, please don’t hesitate to contact me. Many thanks&lt;/p&gt;
    
    </summary>
    
    
      <category term="University notes" scheme="https://yuxuanliu.tech/categories/University-notes/"/>
    
    
      <category term="Information" scheme="https://yuxuanliu.tech/tags/Information/"/>
    
      <category term="Engineering" scheme="https://yuxuanliu.tech/tags/Engineering/"/>
    
  </entry>
  
  <entry>
    <title>IB Electromagnetism Waves and Fields notes</title>
    <link href="https://yuxuanliu.tech/IB_EM_waves_and_field/"/>
    <id>https://yuxuanliu.tech/IB_EM_waves_and_field/</id>
    <published>2020-05-10T23:09:11.000Z</published>
    <updated>2020-05-10T16:29:29.202Z</updated>
    
    <content type="html"><![CDATA[<h1 id="IB-Paper-5-EM-Waves-and-Fields-Notes"><a href="#IB-Paper-5-EM-Waves-and-Fields-Notes" class="headerlink" title="IB Paper 5 EM Waves and Fields Notes"></a>IB Paper 5 EM Waves and Fields Notes</h1><p>This is my personal notes abstract from the EM waves &amp; fields course given by the Department of Engineering, University of Cambridge. This course introduces some concepts on top of the course in IA, it includes the following topics: Transmission lines, Maxwell Equations, EM waves in dielectric, Antennas, Reflection and refraction of EM waves, EM waves in conducting medium.</p><p>Lectures are given by Dr. Flewitt. If you spot any mistake or have any questions, please don’t hesitate to contact me. Many thanks</p><a id="more"></a><p><img src="https://i.loli.net/2020/05/11/Kh1mzksf9awOj57.jpg" alt="1.jpg"></p><p><img src="https://i.loli.net/2020/05/11/T7BIJWuwPdo6QtD.jpg" alt="2.jpg"></p><p><img src="https://i.loli.net/2020/05/11/61yUnAGoJTbsp9k.jpg" alt="3.jpg"></p><p><img src="https://i.loli.net/2020/05/11/IxjoW8LlGOnzmEd.jpg" alt="4.jpg"></p><p><img src="https://i.loli.net/2020/05/11/hZfDFKOXRqi5k68.jpg" alt="5.jpg"></p><p><img src="https://i.loli.net/2020/05/11/lf1gMw4WCoReZOP.jpg" alt="6.jpg"></p><p><img src="https://i.loli.net/2020/05/11/nKY395ZbOvRXBUx.jpg" alt="7.jpg"></p><p><img src="https://i.loli.net/2020/05/11/O8lBRbSCvJY5zuH.jpg" alt="8.jpg"></p><p><img src="https://i.loli.net/2020/05/11/XqLydnVBtwso3eb.jpg" alt="9.jpg"></p><p><img src="https://i.loli.net/2020/05/11/YiSM2wlKzBUhfW5.jpg" alt="10.jpg"></p><p><img src="https://i.loli.net/2020/05/11/LUBMbEPkhozlqxJ.jpg" alt="11.jpg"></p><p><img src="https://i.loli.net/2020/05/11/xvyZOXnFR1CiklA.jpg" alt="12.jpg"></p><p><img src="https://i.loli.net/2020/05/11/PzFYDLTrEQ8yb97.jpg" alt="13.jpg"></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;IB-Paper-5-EM-Waves-and-Fields-Notes&quot;&gt;&lt;a href=&quot;#IB-Paper-5-EM-Waves-and-Fields-Notes&quot; class=&quot;headerlink&quot; title=&quot;IB Paper 5 EM Waves and Fields Notes&quot;&gt;&lt;/a&gt;IB Paper 5 EM Waves and Fields Notes&lt;/h1&gt;&lt;p&gt;This is my personal notes abstract from the EM waves &amp;amp; fields course given by the Department of Engineering, University of Cambridge. This course introduces some concepts on top of the course in IA, it includes the following topics: Transmission lines, Maxwell Equations, EM waves in dielectric, Antennas, Reflection and refraction of EM waves, EM waves in conducting medium.&lt;/p&gt;
&lt;p&gt;Lectures are given by Dr. Flewitt. If you spot any mistake or have any questions, please don’t hesitate to contact me. Many thanks&lt;/p&gt;
    
    </summary>
    
    
      <category term="University notes" scheme="https://yuxuanliu.tech/categories/University-notes/"/>
    
    
      <category term="Engineering" scheme="https://yuxuanliu.tech/tags/Engineering/"/>
    
      <category term="Electricity" scheme="https://yuxuanliu.tech/tags/Electricity/"/>
    
  </entry>
  
  <entry>
    <title>IB Electrical Power notes</title>
    <link href="https://yuxuanliu.tech/IB_Electrical_Power/"/>
    <id>https://yuxuanliu.tech/IB_Electrical_Power/</id>
    <published>2020-04-26T22:55:20.000Z</published>
    <updated>2020-04-26T16:10:47.944Z</updated>
    
    <content type="html"><![CDATA[<h1 id="IB-Paper-5-Electrical-Power-Notes"><a href="#IB-Paper-5-Electrical-Power-Notes" class="headerlink" title="IB Paper 5 Electrical Power Notes"></a>IB Paper 5 Electrical Power Notes</h1><p>This is my personal notes abstract from the Electrical Power course given by the Department of Engineering, University of Cambridge. This course introduces Electrical Power System includes: Three Phase Power Supply, AC Generator(Synchronous Machine), Transmission Line and Induction Motor(Asynchronous Machine).</p><p>Lectures are given by Dr. Flack. If you spot any mistake or have any questions, please don’t hesitate to contact me. Many thanks</p><a id="more"></a><p><img src="https://i.loli.net/2020/04/27/wduVo3CBMxezv9T.jpg" alt="1.jpg"></p><p><img src="https://i.loli.net/2020/04/27/qaANV5x9nrzDFOi.jpg" alt="2.jpg"></p><p><img src="https://i.loli.net/2020/04/27/HyvPhjZkxeOCX6n.jpg" alt="3.jpg"></p><p><img src="https://i.loli.net/2020/04/27/AIO4hBPGo6Czklx.jpg" alt="4.jpg"></p><p><img src="https://i.loli.net/2020/04/27/me8VoqhTz7bG6pS.jpg" alt="5.jpg"></p><p><img src="https://i.loli.net/2020/04/27/pjT1ABk3FDtOEW2.jpg" alt="6.jpg"></p><p><img src="https://i.loli.net/2020/04/27/PaZOphYXVx6QwBz.jpg" alt="7.jpg"></p><p><img src="https://i.loli.net/2020/04/27/T7bjNfZW4cYsCh2.jpg" alt="8.jpg"></p><p><img src="https://i.loli.net/2020/04/27/SZNgz48Het6Uoc9.jpg" alt="9.jpg"></p><p><img src="https://i.loli.net/2020/04/27/8JlQfYKRozISZqE.jpg" alt="10.jpg"></p><p><img src="https://i.loli.net/2020/04/27/v8ibScFlQTG2KjE.jpg" alt="11.jpg"></p><p><img src="https://i.loli.net/2020/04/27/F85cNRrbXOk37eL.jpg" alt="12.jpg"></p><p><img src="https://i.loli.net/2020/04/27/PpcYgiCU2emxLHT.jpg" alt="13.jpg"></p><p><img src="https://i.loli.net/2020/04/27/mvD86fOwJXzGbNU.jpg" alt="14.jpg"></p><p><img src="https://i.loli.net/2020/04/27/JQHcbLf2R9wgMSi.jpg" alt="15.jpg"></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;IB-Paper-5-Electrical-Power-Notes&quot;&gt;&lt;a href=&quot;#IB-Paper-5-Electrical-Power-Notes&quot; class=&quot;headerlink&quot; title=&quot;IB Paper 5 Electrical Power Notes&quot;&gt;&lt;/a&gt;IB Paper 5 Electrical Power Notes&lt;/h1&gt;&lt;p&gt;This is my personal notes abstract from the Electrical Power course given by the Department of Engineering, University of Cambridge. This course introduces Electrical Power System includes: Three Phase Power Supply, AC Generator(Synchronous Machine), Transmission Line and Induction Motor(Asynchronous Machine).&lt;/p&gt;
&lt;p&gt;Lectures are given by Dr. Flack. If you spot any mistake or have any questions, please don’t hesitate to contact me. Many thanks&lt;/p&gt;
    
    </summary>
    
    
      <category term="University notes" scheme="https://yuxuanliu.tech/categories/University-notes/"/>
    
    
      <category term="Engineering" scheme="https://yuxuanliu.tech/tags/Engineering/"/>
    
      <category term="Electricity" scheme="https://yuxuanliu.tech/tags/Electricity/"/>
    
  </entry>
  
  <entry>
    <title>IB Communication Notes</title>
    <link href="https://yuxuanliu.tech/IB_Communication/"/>
    <id>https://yuxuanliu.tech/IB_Communication/</id>
    <published>2020-04-20T23:53:24.000Z</published>
    <updated>2020-04-26T16:10:41.514Z</updated>
    
    <content type="html"><![CDATA[<h1 id="IB-Paper-6-Communication-Notes"><a href="#IB-Paper-6-Communication-Notes" class="headerlink" title="IB Paper 6 Communication Notes"></a>IB Paper 6 Communication Notes</h1><p>This is my personal notes abstract from the Communication course given by the Department of Engineering, University of Cambridge. This course introduces some basic ideas in Information Engineering includes: Analogue modulation, Frequency modulation, ADC, Baseband modulation &amp; demodulation, Passband modulation &amp; demodulation, Channel coding and Multiple Access.</p><p>Lectures are given by Dr. Venkataramanan. If you spot any mistake or have any questions, please don’t hesitate to contact me. Many thanks</p><a id="more"></a><p><img src="https://i.loli.net/2020/04/21/GSJKudTzkbI49gw.jpg" alt="1"></p><p><img src="https://i.loli.net/2020/04/21/D3R6XrBQa4ikzcx.jpg" alt="2.jpg"></p><p><img src="https://i.loli.net/2020/04/21/mgfa4UxBb3oSDPQ.jpg" alt="3.jpg"></p><p><img src="https://i.loli.net/2020/04/21/EI6vU4ysxFJe3kD.jpg" alt="4.jpg"></p><p><img src="https://i.loli.net/2020/04/21/5Rc6lEXwmdOBHgW.jpg" alt="5.jpg"></p><p><img src="https://i.loli.net/2020/04/21/NtYegnuPZ2TGXV8.jpg" alt="6.jpg"></p><p><img src="https://i.loli.net/2020/04/21/OQKAgFI56ECH8BZ.jpg" alt="7.jpg"></p><p><img src="https://i.loli.net/2020/04/21/SI2YGTPDoUp9WwV.jpg" alt="8.jpg"></p><p><img src="https://i.loli.net/2020/04/21/pES73KaJLDIo8eH.jpg" alt="9.jpg"></p><p><img src="https://i.loli.net/2020/04/21/Fy69bCkSDsQW45U.jpg" alt="10.jpg"></p><p><img src="https://i.loli.net/2020/04/21/R8AvZlrN2IP1yLm.jpg" alt="11.jpg"></p><p><img src="https://i.loli.net/2020/04/21/sY3CGnczqINASFE.jpg" alt="12.jpg"></p><p><img src="https://i.loli.net/2020/04/21/6z4Yscw5SIbTJVl.jpg" alt="13.jpg"></p><p><img src="https://i.loli.net/2020/04/21/AfWGNsuC7D2eicb.jpg" alt="14.jpg"></p><p><img src="https://i.loli.net/2020/04/21/qaHLbFT4ckdzfCn.jpg" alt="15.jpg"></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;IB-Paper-6-Communication-Notes&quot;&gt;&lt;a href=&quot;#IB-Paper-6-Communication-Notes&quot; class=&quot;headerlink&quot; title=&quot;IB Paper 6 Communication Notes&quot;&gt;&lt;/a&gt;IB Paper 6 Communication Notes&lt;/h1&gt;&lt;p&gt;This is my personal notes abstract from the Communication course given by the Department of Engineering, University of Cambridge. This course introduces some basic ideas in Information Engineering includes: Analogue modulation, Frequency modulation, ADC, Baseband modulation &amp;amp; demodulation, Passband modulation &amp;amp; demodulation, Channel coding and Multiple Access.&lt;/p&gt;
&lt;p&gt;Lectures are given by Dr. Venkataramanan. If you spot any mistake or have any questions, please don’t hesitate to contact me. Many thanks&lt;/p&gt;
    
    </summary>
    
    
      <category term="University notes" scheme="https://yuxuanliu.tech/categories/University-notes/"/>
    
    
      <category term="Information" scheme="https://yuxuanliu.tech/tags/Information/"/>
    
      <category term="Engineering" scheme="https://yuxuanliu.tech/tags/Engineering/"/>
    
  </entry>
  
  <entry>
    <title>IB Analogue circuit and devices notes part 1</title>
    <link href="https://yuxuanliu.tech/IB_Analogue_circuit_and_devices_part_1/"/>
    <id>https://yuxuanliu.tech/IB_Analogue_circuit_and_devices_part_1/</id>
    <published>2019-12-17T22:32:03.000Z</published>
    <updated>2019-12-17T14:44:43.090Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-Bipolar-transistor-DC-properties"><a href="#1-Bipolar-transistor-DC-properties" class="headerlink" title="1. Bipolar transistor DC properties"></a>1. Bipolar transistor DC properties</h1><ol><li><p>p-n junction:</p><ul><li>p-type silicon: substitute silicon by Group Ⅲ element. Majority charge carrier: holes; minority change carrier: electrons.</li><li>n-type silicon: substitute silicon by Group Ⅴ element. Majority charge carrier: electrons; minority change carrier: holes.</li><li>If we put a p-type and a n-type together, a depletion region is formed due to electrons and holes join together. </li></ul></li><li><p>FET(Field effect transistor): </p><ul><li>Unipolar(either electrons or holes as charge carrier)</li><li>Gate, drain and source</li><li>Voltage at gate controls conductivity and can’t sustain large current</li><li>Operating at low current to amplify voltage</li></ul><a id="more"></a></li><li><p>Bipolar transistor(三极管):</p><ul><li><p>Bipolar(both electrons and holes as charge carrier)</p></li><li><p>Amplify current</p></li><li><p>Base, collector and emitter.</p></li><li><p>Two diodes(n-p &amp; p-n) attached together to form a npn.</p></li><li><p>$I_{B}$ is used to control $I_{C}$ but $I_{B}$ is way smaller than $I_{C}$.</p></li><li><p>Detailed theory for operation:</p><ul><li>Base voltage is positive with respect to emitter so base-emitter diode is forward biased.</li><li>Collector-base diode is reversed biased. Electrons can fill up the depletion layer(may be neglected) as base(p type) is very thin. As a result, electrons can flow between collector and emitter.</li><li>In summary: <strong>a small change in base current causes a large change in collector current. The collector current is nearly equal to emitter current.</strong></li></ul></li><li><p>A bit math:<br>$$<br>I_{C}=\alpha I_{E}\<br>I_{E}=I_{C}+I_{B}\<br>I_{C}=\frac {\alpha}{1-\alpha}I_{B}=\beta I_{B}=h_{FE}\cdot I_{B}<br>$$</p><ul><li>$\alpha$ is called the common base current gain and ranges from 0.9 to 0.99.</li><li>$h_{FE}$ is called the current gain and usually range from 20 to 500.</li></ul></li></ul></li></ol><h1 id="2-Bipolar-transistor-AC-properties"><a href="#2-Bipolar-transistor-AC-properties" class="headerlink" title="2. Bipolar transistor AC properties"></a>2. Bipolar transistor AC properties</h1><ol><li><p>DC analysis on BJT:</p><ul><li><img src="https://i.loli.net/2019/12/17/TxUGDOJjmt59RdZ.png" alt="1571179715877"></li><li>$R_{1}$ is used to set $I_{B}$. $R_{1}=\frac {V_{CC}-V_{BE}}{I_{B}}$</li><li>$R_{2}$ is used to set $I_{C}$ and $V_{CE}$. $R_{2}=\frac {V_{CC}-V_{CE}}{I_{C}}$</li><li>$V_{CE}$ is normally set to be half of $V_{CC}$.</li><li>Picking an operating point is in fact selecting $V_{CE}$, $I_{C}$ and $I_{B}$. </li><li>We can find $V_{BE}$ in a graph after $V_{CE}$ and $I_{C}$ are determined. </li><li>Values of relevant resistances can be determined after setting $V_{CE}$, $I_{C}$, $I_{B}$ and $V_{BE}$.</li><li>$V_{CE}$ is the output voltage while $V_{BE}$ is the input voltage.</li></ul></li><li><p>Small signal model(ssm) for BJT:</p><ul><li><p>We assume the operating point is already set.</p></li><li><p>For the ssm model, we are not wondering what is actually happening when AC is applied. Instead we’re just modelling the problem using a few parameters.</p></li><li><p>How $I_{C}$ will change if we change $V_{CE}$ and $I_{B}$ slightly. </p></li><li><p>$$<br>\because i_{c}=\left.\frac{\partial I_{c}}{\partial I_{B}}\right|<em>{V</em>{CE}}i_{b}+\left.\frac{\partial I_{c}}{\partial V_{C E}}\right|<em>{I</em>{B}} V_{ce}\<br>$$</p><p>$$<br>\frac{\partial I_{c}}{\partial I_{B}}=h_{fe}\<br>$$</p><p>$$<br>\frac{\partial I_{c}}{\partial V_{C E}}=h_{oe}\<br>$$</p><p>$$<br>\therefore i_{c}=h_{f e} i_{b}+h_{o e} v_{c e}<br>$$</p></li></ul></li></ol><ul><li><p>How $V_{BE}$ will change if we change $I_{B}$ and $V_{CE}$ slightly.</p></li><li><p>$$<br>\because v_{be}=\left.\frac{\partial V_{BE}}{\partial I_{B}}\right|<em>{V</em>{CE}}i_{b}+\left.\frac{\partial V_{BE}}{\partial V_{C E}}\right|<em>{I</em>{B}} V_{ce}\<br>$$</p><p>$$<br>\frac{\partial V_{BE}}{\partial I_{B}}=h_{ie}\<br>$$</p><p>$$<br>\frac{\partial V_{BE}}{\partial V_{CE}}=h_{re}\<br>$$</p><p>$$<br>\therefore v_{be}=h_{ie} i_{b}+h_{re} v_{ce}<br>$$</p><p>$h_{re}$ can be neglected in most cases.</p></li><li><p>Full ssm diagram:</p><p><img src="https://i.loli.net/2019/12/17/xXe3suD6V9NZfo5.png" alt="1571182027668"></p></li></ul><ol start="3"><li>Some tips:<ul><li>All dc parameters are grounded in ssm.</li><li>$i_{b}$ by defemination is the current flow into $h_{ie}$ rather than the current in base.</li><li>$i_{b}$ and $i_{c}$ are current so they just flow into the ground. However, $h_{fe}i_{b}$ is a current source so current must flow back.</li><li>To find input resistance, we must apply a test current at the input terminal with the output terminal open circuited.</li><li>To find output resistance, we must apply a test current at the output terminal with the input terminal short circuited.</li><li>We can check if $h_{fe}i_{b}=0$. If so, it means output resistance is simply resistances in parallel. This is because test current $i_{x}$ only comes from $v_{x}$. No other voltage contributes to $i_{x}$.</li></ul></li></ol><h1 id="3-Bipolar-transistor-circuits-design"><a href="#3-Bipolar-transistor-circuits-design" class="headerlink" title="3. Bipolar transistor circuits design"></a>3. Bipolar transistor circuits design</h1><ol><li><p>Common emitter amplifier:</p><ul><li><p><img src="https://i.loli.net/2019/12/17/OsEW23UlZKmR8Da.png" alt="1576589230987"></p></li><li><p>We may connect $R_{1}$ to collector rather than $V_{CC}$ to improve stability but we are losing some ssm input resistance(a bad thing).</p></li></ul></li><li><p>Common emitter circuit with an emitter resistance:</p><ul><li><p><img src="https://i.loli.net/2019/12/17/GjO78tT6YeJFhPg.png" alt="1576589937199"></p></li><li><p>Use Thevenin theory to find the equivalent circuit of the potential divider $R_{1}$ and $R_{2}$.</p></li><li><p>The emitter resistance $R_{4}$ improve the stability of the circuit but we are losing some gain. A possible way to fix this problem is to add a bypass capacitor across $R_{4}$</p></li></ul></li><li><p>Emitter follower:</p><ul><li><p><img src="https://i.loli.net/2019/12/17/nKDsRyCoEANdpge.png" alt="1576590374329"></p></li><li><p>Has a gain of almost unity so can act as a buffer</p></li><li><p>Has large input resistance and small output resistance</p></li></ul></li><li><p>Source follower(using FET included for completeness):</p><ul><li><p><img src="https://i.loli.net/2019/12/17/IsAxXo3ZPTa5Nd1.png" alt="1576590601262"></p></li><li><p>Also has a gain of nearly unity</p></li><li><p>Input resistance and output resistance of source follower are both greater compared to emitter follower</p></li></ul></li></ol><h1 id="4-Circuit-elements-of-Op-amp"><a href="#4-Circuit-elements-of-Op-amp" class="headerlink" title="4. Circuit elements of Op-amp"></a>4. Circuit elements of Op-amp</h1><ol><li><p>Differential amplifier(Long tail pair):</p><ul><li><p><img src="https://i.loli.net/2019/12/17/wxsB51IQ3YuohKG.png" alt="1576591592558"></p></li><li><p>Act as the input circuit of the Op-amp and can amplify the difference between voltage sources $v_{1}$ and $v_{2}$.</p></li><li><p>Output voltages are $v_{3}$ and $v_{4}$</p></li><li><p>The circuit is perfect symmetrical so everything happens on one side also happens on the other side. We can treat $R_{s}$ into two resistors with resistance of $2R_{s}$ in parallel to simplify analysis.</p></li><li><p>Common mode: $v_{1}=v_{2}$</p><ul><li>If we increase $v_{1}$ and $v_{2}$ together by the same amount, $I_{bias}$ will also increase so current flows into $R_{S}$ increases.</li></ul></li><li><p>Differential mode: $v_{1}$=$-v_{2}$ </p><ul><li>If we increase $v_{1}$ and drop $v_{2}$ by the same amount, change of current in each loop cancel out each other so current flow into $R_{S}$ stays unchanged. As a result, $R_{S}$ can be removed in ssm analysis of the differential mode.</li></ul></li></ul></li><li><p>Common Mode Rejection Ratio(CMRR):</p><ul><li><p>$$<br>CMRR = \frac{G_{diff}}{G_{comm}}<br>$$</p><ul><li>$G_{diff}$: gain for differential mode signals</li><li>$G_{comm}$: gain for common mode signals</li></ul></li><li><p>We want CMRR to be as large as possible.</p></li></ul></li></ol><h1 id="End"><a href="#End" class="headerlink" title="End"></a>End</h1><p>These notes are summarized from handouts and lectures of Cambridge University Engineering Tripos part IB Analogue circuit and devices course given by <a href="cd299@cam.ac.uk">Dr Colm Durkan</a>. If you spot any mistake or have any question, please feel free to get in touch. Many thanks.</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-Bipolar-transistor-DC-properties&quot;&gt;&lt;a href=&quot;#1-Bipolar-transistor-DC-properties&quot; class=&quot;headerlink&quot; title=&quot;1. Bipolar transistor DC properties&quot;&gt;&lt;/a&gt;1. Bipolar transistor DC properties&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;p-n junction:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;p-type silicon: substitute silicon by Group Ⅲ element. Majority charge carrier: holes; minority change carrier: electrons.&lt;/li&gt;
&lt;li&gt;n-type silicon: substitute silicon by Group Ⅴ element. Majority charge carrier: electrons; minority change carrier: holes.&lt;/li&gt;
&lt;li&gt;If we put a p-type and a n-type together, a depletion region is formed due to electrons and holes join together. &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;FET(Field effect transistor): &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Unipolar(either electrons or holes as charge carrier)&lt;/li&gt;
&lt;li&gt;Gate, drain and source&lt;/li&gt;
&lt;li&gt;Voltage at gate controls conductivity and can’t sustain large current&lt;/li&gt;
&lt;li&gt;Operating at low current to amplify voltage&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="University notes" scheme="https://yuxuanliu.tech/categories/University-notes/"/>
    
    
      <category term="Engineering" scheme="https://yuxuanliu.tech/tags/Engineering/"/>
    
      <category term="Electricity" scheme="https://yuxuanliu.tech/tags/Electricity/"/>
    
  </entry>
  
  <entry>
    <title>Python for Finance part 3</title>
    <link href="https://yuxuanliu.tech/Python_for_Finance_3/"/>
    <id>https://yuxuanliu.tech/Python_for_Finance_3/</id>
    <published>2019-09-30T09:59:42.000Z</published>
    <updated>2019-09-30T03:33:04.919Z</updated>
    
    <content type="html"><![CDATA[<h2 id="11-Portfolio-optimization"><a href="#11-Portfolio-optimization" class="headerlink" title="11. Portfolio optimization"></a>11. Portfolio optimization</h2><ol><li><p>Monte Carlo Simulation: randomly assign a weight to each security in our portfolio, then calculate the mean daily return, daily return std and Sharp ratio</p></li><li><p>Plot results on a chart showing <strong>Return against Volatility and colored by Sharp Ratio</strong>.</p></li><li><p>Full code for Monte Carlo:</p><a id="more"></a><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> yfinance <span class="keyword">as</span> yf</span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> sqrt</span><br><span class="line"></span><br><span class="line"><span class="comment">#Load data</span></span><br><span class="line">TESLA = pd.read_csv(<span class="string">"Tesla_data.csv"</span>,index_col=<span class="string">"Date"</span>,parse_dates=<span class="literal">True</span>)</span><br><span class="line">GOOGLE = pd.read_csv(<span class="string">"Google_data.csv"</span>,index_col=<span class="string">"Date"</span>,parse_dates=<span class="literal">True</span>)</span><br><span class="line">GM = pd.read_csv(<span class="string">"GM_data.csv"</span>,index_col=<span class="string">"Date"</span>,parse_dates=<span class="literal">True</span>)</span><br><span class="line">APPLE = pd.read_csv(<span class="string">"Apple_data.csv"</span>,index_col=<span class="string">"Date"</span>,parse_dates=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#Create a new dataframe with adjusted close prices only</span></span><br><span class="line">df_close = pd.concat([TESLA[<span class="string">"Adj Close"</span>],GOOGLE[<span class="string">"Adj Close"</span>],GM[<span class="string">"Adj Close"</span>],APPLE[<span class="string">"Adj Close"</span>]],axis = <span class="number">1</span>)</span><br><span class="line">df_close.columns = [<span class="string">"TESLA"</span>,<span class="string">"GOOGLE"</span>,<span class="string">"GM"</span>,<span class="string">"APPLE"</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#Find daily return in the log scale</span></span><br><span class="line">df_daily_return = np.log(df_close/df_close.shift(<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">#Create several arries to store data</span></span><br><span class="line">array_return = np.zeros(<span class="number">5000</span>)</span><br><span class="line">array_variance = np.zeros(<span class="number">5000</span>)</span><br><span class="line">array_sharp = np.zeros(<span class="number">5000</span>)</span><br><span class="line">array_allocation = np.zeros((<span class="number">5000</span>,<span class="number">4</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">#5000 iteration(Monte Carlo method)</span></span><br><span class="line"><span class="keyword">for</span> m <span class="keyword">in</span> range(<span class="number">5000</span>):</span><br><span class="line">    <span class="comment">#Create a random allocation and normalise it.</span></span><br><span class="line">    allocation = np.random.random(<span class="number">4</span>)</span><br><span class="line">    allocation = allocation/np.sum(allocation)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#Find the total daily return which has taken into account allocation</span></span><br><span class="line">    allo_ret = (df_daily_return*allocation).sum(axis = <span class="number">1</span>)</span><br><span class="line">    <span class="comment">#Change daily average return to yearly</span></span><br><span class="line">    exp_ret = allo_ret.mean()*<span class="number">252</span></span><br><span class="line">    <span class="comment">#Find the expected volatility(standard deviation)</span></span><br><span class="line">    exp_vol = allo_ret.std()*sqrt(<span class="number">252</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#We may also use the line of code below to make calculations faster.</span></span><br><span class="line">    <span class="comment">#exp_vol = np.sqrt(np.dot(allocation.T, np.dot(df_daily_return.cov() * 252, allocation)))</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#Store data</span></span><br><span class="line">    array_return[m] = exp_ret</span><br><span class="line">    array_variance[m] = exp_vol</span><br><span class="line">    array_sharp[m] = exp_ret/exp_vol</span><br><span class="line">    array_allocation[m] = allocation</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#Plot data</span></span><br><span class="line">plt.figure(figsize=(<span class="number">12</span>,<span class="number">8</span>))</span><br><span class="line">plt.scatter(array_variance,array_return,c=array_sharp,cmap=<span class="string">'plasma'</span>)</span><br><span class="line">position = array_sharp.argmax()</span><br><span class="line">print(array_allocation[position])</span><br><span class="line">plt.colorbar(label=<span class="string">'Sharpe Ratio'</span>)</span><br><span class="line">plt.xlabel(<span class="string">'Volatility(standard deviation)'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'Return'</span>) </span><br><span class="line">plt.scatter(array_variance[position],array_return[position],c=<span class="string">'blue'</span>,s=<span class="number">40</span>,edgecolors=<span class="string">'black'</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>We can either use arithmetic daily return = $\frac {P_{t}}{P_{t-1}}-1$ or logarithm daily return = $\lg \frac{P_{t}}{P_{t-1}}$ for portfolio optimization. However, logarithm daily return is recommended as it has better performance.</p></li><li><p>Random guessing is not really efficient, we can also use math to find the optimal Sharp Ratio for any given portfolio.</p></li><li><p>The idea of using math is to build a minimizer to find:<br>$$<br>S’ = -\frac{R_{p}-R_{f}}{\sigma_{p}}<br>$$<br>the minimum of the <strong>negative</strong> of the Sharpe ratio leaving us the maximum of the Sharpe ratio.</p></li><li><p>Full code for minimizer(Scipy):</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> scipy.optimize <span class="keyword">import</span> minimize</span><br><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> sqrt</span><br><span class="line"></span><br><span class="line"><span class="comment">#Load data</span></span><br><span class="line">TESLA = pd.read_csv(<span class="string">"Tesla_data.csv"</span>,index_col=<span class="string">"Date"</span>,parse_dates=<span class="literal">True</span>)</span><br><span class="line">GOOGLE = pd.read_csv(<span class="string">"Google_data.csv"</span>,index_col=<span class="string">"Date"</span>,parse_dates=<span class="literal">True</span>)</span><br><span class="line">GM = pd.read_csv(<span class="string">"GM_data.csv"</span>,index_col=<span class="string">"Date"</span>,parse_dates=<span class="literal">True</span>)</span><br><span class="line">APPLE = pd.read_csv(<span class="string">"Apple_data.csv"</span>,index_col=<span class="string">"Date"</span>,parse_dates=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#Create a new dataframe with adjusted close prices only</span></span><br><span class="line">df_close = pd.concat([TESLA[<span class="string">"Adj Close"</span>],GOOGLE[<span class="string">"Adj Close"</span>],GM[<span class="string">"Adj Close"</span>],APPLE[<span class="string">"Adj Close"</span>]],axis = <span class="number">1</span>)</span><br><span class="line">df_close.columns = [<span class="string">"TESLA"</span>,<span class="string">"GOOGLE"</span>,<span class="string">"GM"</span>,<span class="string">"APPLE"</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#Find daily return</span></span><br><span class="line">df_daily_return = np.log(df_close/df_close.shift(<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">#A function returns sharpe ratio</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_return_vol_sharp</span><span class="params">(allocation)</span>:</span></span><br><span class="line">    allocation = allocation/np.sum(allocation)</span><br><span class="line">    allo_ret = (df_daily_return*allocation).sum(axis = <span class="number">1</span>)</span><br><span class="line">    exp_ret = allo_ret.mean()*<span class="number">252</span></span><br><span class="line">    exp_vol = allo_ret.std()*sqrt(<span class="number">252</span>)</span><br><span class="line">    exp_sharpe = exp_ret/exp_vol</span><br><span class="line">    <span class="keyword">return</span> np.array([exp_ret,exp_vol,exp_sharpe])</span><br><span class="line"></span><br><span class="line"><span class="comment">#Another function returns negaive sharpe ratio so we want to minimise it to maximise sharpe ratio</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">neg_sharpe</span><span class="params">(allocation)</span>:</span></span><br><span class="line">    <span class="keyword">return</span>  get_return_vol_sharp(allocation)[<span class="number">2</span>] * <span class="number">-1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">check_sum</span><span class="params">(allocation)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    Returns 0 if sum of weights is 1.0</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    <span class="keyword">return</span> np.sum(allocaiton) - <span class="number">1</span></span><br><span class="line">cons = (&#123;<span class="string">'type'</span>:<span class="string">'eq'</span>,<span class="string">'fun'</span>: check_sum&#125;)</span><br><span class="line"></span><br><span class="line">bounds = ((<span class="number">0</span>, <span class="number">1</span>), (<span class="number">0</span>, <span class="number">1</span>), (<span class="number">0</span>, <span class="number">1</span>), (<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">init_guess = [<span class="number">0.25</span>,<span class="number">0.25</span>,<span class="number">0.25</span>,<span class="number">0.25</span>]</span><br><span class="line"><span class="comment">#opt_results = minimize(neg_sharpe, init_guess, method='SLSQP', bounds=bounds, constraints=cons)</span></span><br><span class="line">opt_results = minimize(neg_sharpe, init_guess, method=<span class="string">'SLSQP'</span>, bounds=bounds)</span><br><span class="line">print(opt_results)</span><br><span class="line">print(get_return_vol_sharp(opt_results.x))</span><br></pre></td></tr></table></figure><ul><li>Firstly, we need to create a function we wish to maximize. Then create another function returning the negative. This second function is what we want to minimize.</li><li><code>constraints = cons</code> is a parameter of the constraint. This means that the value returned from the function must equal to 0 otherwise it will be filtered.</li><li>We need to set <code>bonds</code>(boundaries) for each input. It is quite helpful and easy to understand as the sum for <code>allocation</code> is 1.</li><li>Set an initial guess, often we do even allocation.</li></ul></li><li><p>Full code for efficient frontier:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> scipy.optimize <span class="keyword">import</span> minimize</span><br><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> sqrt</span><br><span class="line"><span class="keyword">import</span> yfinance <span class="keyword">as</span> yf</span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line"><span class="comment">#Load data</span></span><br><span class="line">TESLA = pd.read_csv(<span class="string">"Tesla_data.csv"</span>,index_col=<span class="string">"Date"</span>,parse_dates=<span class="literal">True</span>)</span><br><span class="line">GOOGLE = pd.read_csv(<span class="string">"Google_data.csv"</span>,index_col=<span class="string">"Date"</span>,parse_dates=<span class="literal">True</span>)</span><br><span class="line">GM = pd.read_csv(<span class="string">"GM_data.csv"</span>,index_col=<span class="string">"Date"</span>,parse_dates=<span class="literal">True</span>)</span><br><span class="line">APPLE = pd.read_csv(<span class="string">"Apple_data.csv"</span>,index_col=<span class="string">"Date"</span>,parse_dates=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#Create a new dataframe with adjusted close prices only</span></span><br><span class="line">df_close = pd.concat([TESLA[<span class="string">"Adj Close"</span>],GOOGLE[<span class="string">"Adj Close"</span>],GM[<span class="string">"Adj Close"</span>],APPLE[<span class="string">"Adj Close"</span>]],axis = <span class="number">1</span>)</span><br><span class="line">df_close.columns = [<span class="string">"TESLA"</span>,<span class="string">"GOOGLE"</span>,<span class="string">"GM"</span>,<span class="string">"APPLE"</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#Find daily return</span></span><br><span class="line">df_daily_return = np.log(df_close/df_close.shift(<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">#A function returns sharpe ratio</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_return_vol_sharp</span><span class="params">(allocation)</span>:</span></span><br><span class="line">    allocation = allocation/np.sum(allocation)</span><br><span class="line">    allo_ret = (df_daily_return*allocation).sum(axis = <span class="number">1</span>)</span><br><span class="line">    exp_ret = allo_ret.mean()*<span class="number">252</span></span><br><span class="line">    exp_vol = allo_ret.std()*sqrt(<span class="number">252</span>)</span><br><span class="line">    <span class="keyword">return</span> np.array([exp_ret,exp_vol])</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">volati</span><span class="params">(allocation)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> get_return_vol_sharp(allocation)[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">check_sum</span><span class="params">(allocation)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    Returns 0 if sum of weights is 1.0</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    <span class="keyword">return</span> np.sum(allocation) - <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">bounds = ((<span class="number">0</span>, <span class="number">1</span>), (<span class="number">0</span>, <span class="number">1</span>), (<span class="number">0</span>, <span class="number">1</span>), (<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">init_guess = [<span class="number">0.25</span>,<span class="number">0.25</span>,<span class="number">0.25</span>,<span class="number">0.25</span>]</span><br><span class="line">y_axis = np.linspace(<span class="number">0</span>,<span class="number">0.4</span>,<span class="number">30</span>)</span><br><span class="line">list_x = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> y_axis:</span><br><span class="line">    cons = (&#123;<span class="string">'type'</span>:<span class="string">'eq'</span>,<span class="string">'fun'</span>: check_sum&#125;,&#123;<span class="string">'type'</span>:<span class="string">'eq'</span>,<span class="string">'fun'</span>: <span class="keyword">lambda</span> w: get_return_vol_sharp(w)[<span class="number">0</span>] - i&#125;)</span><br><span class="line">    opt_results = minimize(volati, init_guess, method=<span class="string">'SLSQP'</span>, bounds=bounds, constraints=cons)</span><br><span class="line">    list_x.append(opt_results[<span class="string">"fun"</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#Create several arries to store data</span></span><br><span class="line">array_return = np.zeros(<span class="number">3000</span>)</span><br><span class="line">array_variance = np.zeros(<span class="number">3000</span>)</span><br><span class="line">array_sharp = np.zeros(<span class="number">3000</span>)</span><br><span class="line">array_allocation = np.zeros((<span class="number">3000</span>,<span class="number">4</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">#3000 iteration(Monte Carlo method)</span></span><br><span class="line"><span class="keyword">for</span> m <span class="keyword">in</span> range(<span class="number">3000</span>):</span><br><span class="line">    <span class="comment">#Create a random allocation and normalise it.</span></span><br><span class="line">    allocation = np.random.random(<span class="number">4</span>)</span><br><span class="line">    allocation = allocation/np.sum(allocation)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#Find the total daily return which has taken into account allocation</span></span><br><span class="line">    allo_ret = (df_daily_return*allocation).sum(axis = <span class="number">1</span>)</span><br><span class="line">    <span class="comment">#Change daily average return to yearly</span></span><br><span class="line">    exp_ret = allo_ret.mean()*<span class="number">252</span></span><br><span class="line">    <span class="comment">#Find the expected volatility(standard deviation)</span></span><br><span class="line">    exp_vol = allo_ret.std()*sqrt(<span class="number">252</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#We may also use the line of code below to make calculations faster.</span></span><br><span class="line">    <span class="comment">#exp_vol = np.sqrt(np.dot(allocation.T, np.dot(df_daily_return.cov() * 252, allocation)))</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#Store data</span></span><br><span class="line">    array_return[m] = exp_ret</span><br><span class="line">    array_variance[m] = exp_vol</span><br><span class="line">    array_sharp[m] = exp_ret/exp_vol</span><br><span class="line">    array_allocation[m] = allocation</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#Plot data</span></span><br><span class="line">plt.scatter(array_variance,array_return,c=array_sharp,cmap=<span class="string">'plasma'</span>)</span><br><span class="line">position = array_sharp.argmax()</span><br><span class="line">print(array_allocation[position])</span><br><span class="line">plt.colorbar(label=<span class="string">'Sharpe Ratio'</span>)</span><br><span class="line">plt.xlabel(<span class="string">'Volatility(standard deviation)'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'Return'</span>) </span><br><span class="line">plt.scatter(array_variance[position],array_return[position],c=<span class="string">'blue'</span>,s=<span class="number">40</span>,edgecolors=<span class="string">'black'</span>)</span><br><span class="line">plt.plot(list_x,y_axis,<span class="string">'g--'</span>,linewidth=<span class="number">3</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>Find the range of y and minimise x within this range to find efficient frontier.</p></li></ol><h2 id="12-Finance-concepts"><a href="#12-Finance-concepts" class="headerlink" title="12. Finance concepts"></a>12. Finance concepts</h2><ol><li><p>Types of funds:</p><ul><li>ETF(Exchange Traded Funds):<ul><li>Holdings are transparent and public</li><li>Individuals can trade ETF just like stocks(Liquidity)</li><li>Expense ratio: 0.01%-0.1% asset under management(<strong>AUM</strong>)</li></ul></li><li>Mutual Funds(公募基金):<ul><li>A pool of funds collected from investors for the purpose of investing in securities</li><li>Operated by fund managers</li><li>Normally disclose their holdings once a quarter(may vary)</li><li>Individuals can trade at the end of the day through broker(掮客)</li><li>Expense ratio: 0.5%-3% AUM</li></ul></li><li>Hedge funds(对冲基金):<ul><li>Alternative investments using pooled funds</li><li>Less regulation and only open to accredited investors</li><li>No need to disclose strategy</li><li>Trading of hedge funds depends on agreements.</li><li>Expense ratio: 2% of AUM and 20% of the profit</li></ul></li></ul></li><li><p>Order books:</p><ul><li>An order is created when you click <strong>BUY</strong> on your stock trading APP(broker).</li><li>An order includes the following information:<ul><li>Buy or sell</li><li>Symbol(sticker) of the stock</li><li>Number of shares</li><li>Limit(only buy share under certain price) or market(buy share at the current market price)</li><li>Price(only required if it is an limit order)</li></ul></li><li>The order is sent to exchanges and goes into an order book.</li><li>Your order may not actually be sent to the exchange due to the reasons below:<ul><li>Order can be done within the broker</li><li>Order is done within the darkpool(private exchanges between brokers)</li></ul></li></ul></li><li><p>High frequency trading(HFT):</p><ul><li>HFT firms make profit using the latency(潜在) differences due to geographical distance.</li><li>Latency arbitrage: A bank purchases a large amount of share. It needs to send orders to multiple exchanges, it takes some time(2ms) for the order to travel between exchanges. HFT firm builds colocated server to detect this large order so they can send orders to other exchanges faster than the bank. The price is almost guaranteed to go up due to the large buy-in so HFT makes money. </li></ul></li><li><p>Short-selling(抛空):</p><ul><li>If you believe the price for a share will go down, you can go to the broker and borrow someone else’s share.</li><li>Sell these shares and buy back when it goes down. You end up making money.</li><li>However, you will end up losing money if the price goes up.</li></ul></li><li><p>Capital asset pricing model(CAPM):</p><ul><li><p>Return of the portfolio:  $r_{p}(t) = cw_{i}r_{i}(t)$ </p></li><li><p>We can also image the whole market as a portfolio to find the <strong>return of market</strong>: $r_{m}(t) = \sum_{i}^{n}w_{m}r_{i}(t)$ where $w_{m}$ is the market capital of a company over the market capital of the market.</p></li><li><p>CAPM equation for a stock: $r_{i}(t) = \beta_{i}r_{m}(t)+\alpha_{i}(t)$</p><ul><li>Return of any share is just a weight of the return of market plus $\alpha_{i}$ which is the residual term.</li><li>We are expecting $\alpha_{i}$ to be zero and we are trying to predict $\alpha_{i}$</li></ul></li><li><p>CAPM equation for a portfolio: $r_{p}(t) = \beta_{p}r_{m}(t)+\sum_{i}^{n}w_{i}\alpha_{i}(t)$</p></li><li><p>Full code for CAPM demo:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> scipy <span class="keyword">import</span> stats</span><br><span class="line"><span class="keyword">import</span> pandas_datareader <span class="keyword">as</span> pdr</span><br><span class="line"><span class="keyword">import</span> yfinance <span class="keyword">as</span> yf</span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line">yf.pdr_override()</span><br><span class="line">start = datetime.date(<span class="number">2015</span>,<span class="number">9</span>,<span class="number">30</span>)</span><br><span class="line">end = datetime.date(<span class="number">2019</span>,<span class="number">9</span>,<span class="number">30</span>)</span><br><span class="line">GM = pdr.get_data_yahoo(<span class="string">"GM"</span>,start,end)</span><br><span class="line">spy = pdr.get_data_yahoo(<span class="string">"SPY"</span>,start,end)</span><br><span class="line">GM[<span class="string">"Daily return"</span>] = (GM[<span class="string">"Close"</span>]/GM.shift(<span class="number">1</span>)[<span class="string">"Close"</span>])<span class="number">-1</span></span><br><span class="line">spy[<span class="string">"Daily return"</span>] = (spy[<span class="string">"Close"</span>]/spy.shift(<span class="number">1</span>)[<span class="string">"Close"</span>])<span class="number">-1</span></span><br><span class="line">beta,alpha,r_value,p_value,std_err = stats.linregress(GM[<span class="string">'Daily return'</span>].iloc[<span class="number">1</span>:],spy[<span class="string">'Daily return'</span>].iloc[<span class="number">1</span>:])</span><br><span class="line">print(beta)</span><br><span class="line">print(alpha)</span><br></pre></td></tr></table></figure></li></ul></li><li><p>A few notes</p><ul><li>When the price for a share is extremely high, the company may split up a share in to two or three. This will cause a big jump in the share price which will affect our trading algorithm.</li><li>The price for a stock will go up before dividends pay-out being announced and go down afterwards. This will affect our trading algorithm as well.</li><li>Adjusted close will remove the influence above. You should use the adjusted close where possible.</li><li>Survivorship bias: companies with poor performance are removed from S&amp;P 500 as time move on. Leaving only companies with good performance. This will cause bias, making us too optimistic about our strategy. In other words, companies in S&amp;P 500 in 2006 are different from today.</li><li>EMH(Efficient Market Hypothesis):<ul><li>stocks always trade at their fair value on stock exchanges, making it impossible for investors to either purchase undervalued stocks or sell stocks for inflated prices.</li><li>The only way to gain higher return is by purchasing riskier investments.</li><li>We believe EMH is NOT true and market is not 100% efficient otherwise there is no point doing analysis. Besides, large hedge funds keep making money is also evidence that the market is not 100% efficient.</li></ul></li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;11-Portfolio-optimization&quot;&gt;&lt;a href=&quot;#11-Portfolio-optimization&quot; class=&quot;headerlink&quot; title=&quot;11. Portfolio optimization&quot;&gt;&lt;/a&gt;11. Portfolio optimization&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Monte Carlo Simulation: randomly assign a weight to each security in our portfolio, then calculate the mean daily return, daily return std and Sharp ratio&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Plot results on a chart showing &lt;strong&gt;Return against Volatility and colored by Sharp Ratio&lt;/strong&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Full code for Monte Carlo:&lt;/p&gt;
    
    </summary>
    
    
      <category term="Programming" scheme="https://yuxuanliu.tech/categories/Programming/"/>
    
      <category term="Finance" scheme="https://yuxuanliu.tech/categories/Finance/"/>
    
    
      <category term="Python" scheme="https://yuxuanliu.tech/tags/Python/"/>
    
      <category term="Finance" scheme="https://yuxuanliu.tech/tags/Finance/"/>
    
  </entry>
  
  <entry>
    <title>Python for Finance part 2</title>
    <link href="https://yuxuanliu.tech/Python_for_Finance_2/"/>
    <id>https://yuxuanliu.tech/Python_for_Finance_2/</id>
    <published>2019-09-19T21:11:11.000Z</published>
    <updated>2019-09-30T03:32:52.095Z</updated>
    
    <content type="html"><![CDATA[<h2 id="9-Time-series-analysis"><a href="#9-Time-series-analysis" class="headerlink" title="9. Time series analysis"></a>9. Time series analysis</h2><ol><li><p>Key words related to time series:</p><ul><li>Trend: Upward, Horizontal/Stationary and Downward.</li><li>Seasonality(季节性): repeated trends</li><li>Cyclical(周期性): trends with no set repetition</li></ul></li><li><p>Statsmodels:</p><ul><li><p><code>import statsmodels.api as sm</code></p></li><li><p>Demo: Hodrick-Prescott filter: $\min_{\{ \tau_{t}\} }\sum_{t}^{T}\zeta_{t}^{2}+\lambda\sum_{t=1}^{T}\left[\left(\tau_{t}-\tau_{t-1}\right)-\left(\tau_{t-1}-\tau_{t-2}\right)\right]^{2}$</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Fetching data</span></span><br><span class="line">yf.pdr_override()</span><br><span class="line">start = datetime.date(<span class="number">2018</span>,<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">end = datetime.date(<span class="number">2019</span>,<span class="number">9</span>,<span class="number">16</span>)</span><br><span class="line">data = pdr.get_data_yahoo(<span class="string">"TSLA"</span>,start,end)</span><br><span class="line"></span><br><span class="line"><span class="comment">#Applying Hodrick-Prescott filter, We get back a tuple with two elements, the first is the cycle pandas series and the second is the trend pandas series.</span></span><br><span class="line">close_cycle, close_trend = sm.tsa.filters.hpfilter(data[<span class="string">"Close"</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">#Plotting</span></span><br><span class="line">fig,axe = plt.subplots(<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line"><span class="comment">#data["Close"].plot(label = "Raw data")</span></span><br><span class="line"><span class="comment">#close_cycle.plot(label = "Cycle")</span></span><br><span class="line">close_trend.plot(label = <span class="string">"Trend"</span>)</span><br><span class="line">data[<span class="string">"Close"</span>].rolling(<span class="number">20</span>).mean().plot(label = <span class="string">"20MA"</span>)</span><br><span class="line">axe.set_xlabel(<span class="string">"Price"</span>)</span><br><span class="line">axe.set_ylabel(<span class="string">"Time"</span>)</span><br><span class="line">axe.set_title(<span class="string">"Hodrick-Prescott filter analysis on Tesla"</span>)</span><br><span class="line">plt.legend()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><a id="more"></a><ul><li>Splitting data into two components: <strong>trend</strong> and <strong>cycle</strong>.</li><li>We can find some similarities between the 20MA plot and the trend plot.</li></ul></li></ul></li><li><p>ETS model(Error-Trend-Seasonality):</p><ul><li><p>ETS decomposition: decompose the time series data into those three main factors:</p><ul><li>Seasonal patterns</li><li>General trends</li><li>Error</li></ul></li><li><p>Demo:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> pandas_datareader <span class="keyword">as</span> pdr</span><br><span class="line"><span class="keyword">import</span> yfinance <span class="keyword">as</span> yf</span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">from</span> statsmodels.tsa.seasonal <span class="keyword">import</span> seasonal_decompose</span><br><span class="line"></span><br><span class="line"><span class="comment">#Fetching data</span></span><br><span class="line">start = datetime.date(<span class="number">2013</span>,<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">end = datetime.date(<span class="number">2019</span>,<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">yf.pdr_override()</span><br><span class="line">data = pdr.get_data_yahoo(<span class="string">"TSLA"</span>,start,end)</span><br><span class="line"><span class="comment">#Choose whether to use EWMA values</span></span><br><span class="line"><span class="comment">#data1["Close"] = data1["Close"].ewm(span = 7).mean()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#Filter dates</span></span><br><span class="line">data1 = data.reset_index()</span><br><span class="line">data1 = data1[(data1[<span class="string">"Date"</span>].apply(<span class="keyword">lambda</span> x:x.day == <span class="number">10</span>))|(data1[<span class="string">"Date"</span>].apply(<span class="keyword">lambda</span> x:x.day == <span class="number">20</span>)) | (data1[<span class="string">"Date"</span>].apply(<span class="keyword">lambda</span> x:x.day == <span class="number">30</span>))]</span><br><span class="line">data1 = data1.set_index(<span class="string">"Date"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#Plotting data</span></span><br><span class="line">seasonal_decompose(data1[<span class="string">"Close"</span>],freq = <span class="number">36</span>,model=<span class="string">'multiplicative'</span>).plot()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><ul><li><code>seasonal_decompose()</code> has two main parameters. <code>freq</code> equals 52 for weekly data, equals 12 for monthly data etc. <code>model</code> has two options, by default it is <strong>additive</strong> and we can also choose to use <strong>multiplicative</strong>.</li><li>I use two sets of data(raw and EWMA) and set frequencies to be every 5 days or every 10 days for comparison purpose.</li><li>Result: <a href="https://i.loli.net/2019/09/19/ayBLv3FfcD9RhPl.png" target="_blank" rel="noopener">raw data every 5 days</a>, <a href="https://i.loli.net/2019/09/19/8BtjGodQwYuElAx.png" target="_blank" rel="noopener">raw data every 10 days</a>, <a href="https://i.loli.net/2019/09/19/UzK1M7hDQsIVrv6.png" target="_blank" rel="noopener">EWMA data every 5 days</a>, <a href="https://i.loli.net/2019/09/19/O2E69k3nVxj1CaX.png" target="_blank" rel="noopener">EWMA data every 10 days</a>.</li></ul></li></ul></li><li><p>EWMA model(Exponentially Weighted Moving Average):</p><ul><li><p>We have Simple Moving average by using <code>.rolling()</code> in Pandas but it has some cons:</p><ul><li>Smaller window will still lead to noise.</li><li>Always lag by the size of the window(missing data at the beginning).</li><li>Never reach the full peak or valley due to the averaging nature.</li><li>Can’t estimate future behavior as all SMA does is describing the trend in the past.</li></ul></li><li><p>Key nature about EWMA:</p><ul><li>Overcome the cons of SMA.</li><li>Put more weight on values that occurred more recently.</li><li>The weight applied depends on the actual parameters used and the window size.</li></ul></li><li><p><code>.ewm()</code> has parameters: <code>com</code>(center of mass); <code>span</code>, <code>halflife</code> and <code>adjust</code>.</p></li><li><p>Formula for the EWMA:<br>$$<br>y_t =   \frac{\sum\limits_{i=0}^t w_i x_{t-i}}{\sum\limits_{i=0}^t w_i}<br>$$</p><ul><li>$y_{t}$ is the output value at time t</li><li>$x_{t}$ is the input value at time t</li><li>All we need to define is $\omega _{i}$ and it depends on the <strong>adjust</strong> parameter you provided.</li></ul></li><li><p>If <code>adjust = True</code>:<br>$$<br>y_t = \frac{x_t + (1 - \alpha)x_{t-1} + (1 - \alpha)^2 x_{t-2} + … + (1 - \alpha)^t x_{0}}{1 + (1 - \alpha) + (1 - \alpha)^2 + … + (1 - \alpha)^t}<br>$$</p><ul><li>By default, <code>adjust = True</code>.</li><li>$0&lt; \alpha &lt;1$ </li><li>This is basically the same as the first expression.</li><li>We are taking all historical values into account.</li><li>$\omega _{i}= (1-\alpha)^{i}$</li></ul></li><li><p>If <code>adjust = False</code>:<br>$$<br> \begin{split}y_0 &amp;= x_0 \<br> y_t &amp;= (1 - \alpha) y_{t-1} + \alpha x_t,\end{split}<br>$$</p><ul><li>$0&lt; \alpha &lt;1$ </li><li>A bit different</li><li>We only take into account the input at <strong>t</strong> and the output at <strong>t-1</strong></li></ul></li><li><p>From the above expressions, we still need to determine $\alpha$. There are three ways:</p><ul><li><p>Span:<br>$$<br>\alpha = \frac{2}{s + 1},\text{for span}\ s \geq 1<br>$$<br>Span corresponds to what is commonly called an <strong>“N-day EWMA”</strong>.</p></li><li><p>Center of mass:<br>$$<br>\alpha = \frac{1}{1 + c},\text{for center of mass}\ c \geq 0<br>$$<br>Center of mass has more physical interpretation and can be thought of in terms of span: $c=\frac{s−1}{2}$</p></li><li><p>Half-life:<br>$$<br>\alpha = 1 - \exp^{\frac{\log 0.5}{h}},\text{for half-life}\ h &gt; 0<br>$$<br>Half-life is the period of time for the exponential weight to reduce to one half.</p></li></ul></li><li><p>Demo:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> pandas_datareader <span class="keyword">as</span> pdr</span><br><span class="line"><span class="keyword">import</span> yfinance <span class="keyword">as</span> yf</span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line"><span class="comment">#Fetching data</span></span><br><span class="line">yf.pdr_override()</span><br><span class="line">start = datetime.date(<span class="number">2019</span>,<span class="number">8</span>,<span class="number">1</span>)</span><br><span class="line">end = datetime.date(<span class="number">2019</span>,<span class="number">9</span>,<span class="number">16</span>)</span><br><span class="line">data = pdr.get_data_yahoo(<span class="string">"TSLA"</span>,start,end)</span><br><span class="line"></span><br><span class="line"><span class="comment">#Plotting data</span></span><br><span class="line">fig,axe = plt.subplots(<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">data[<span class="string">"Close"</span>].plot(label = <span class="string">"Raw data"</span>)</span><br><span class="line"><span class="comment">#data["Close"].rolling(7).mean().plot(label = "7MA")</span></span><br><span class="line">data[<span class="string">"Close"</span>].ewm(span = <span class="number">7</span>).mean().plot(label = <span class="string">"7EWMA"</span>)</span><br><span class="line"></span><br><span class="line">axe.set_xlabel(<span class="string">"Price"</span>)</span><br><span class="line">axe.set_ylabel(<span class="string">"Time"</span>)</span><br><span class="line">axe.set_title(<span class="string">"7 days EWMA analysis on Tesla"</span>)</span><br><span class="line">plt.legend()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><h2 id="10-Sharpe-ratio"><a href="#10-Sharpe-ratio" class="headerlink" title="10. Sharpe ratio"></a>10. Sharpe ratio</h2><ol><li><p>Portfolio: </p><ul><li>a set of allocations in a variety of securities(shares).</li><li>Example: 20% Tesla; 50% Apple; 30% GM</li><li>Key values for a portfolio:<ul><li>Daily return</li><li>Cumulative return</li><li>Average daily return</li><li>Standard deviation of daily return(volatility of daily return)</li><li>Sharpe ratio</li></ul></li></ul></li><li><p>Sharpe ratio:</p><ul><li><p>A measure for risk-adjusted return. It quantifies the relationship between return and risk. In other words, how much more risk we are facing for a higher return?</p></li><li><p>Formula:<br>$$<br>S = \frac{R_{p}-R_{f}}{\sigma_{p}}<br>$$<br>$R_{p}$: expected portfolio return mean</p><p>$R_{f}$: Risk-free return</p><p>$\sigma p$: Portfolio standard deviation</p></li><li><p>In this note, we set $R_{f}=0$ leaving $S = \frac{R_{p}}{\sigma{p}}$</p></li><li><p>Conservation to annualized Sharp ratio: $ASR = K\times SR$</p><ul><li>If we have daily data: K =$\sqrt{252}$</li><li>If we have weekly data: K =$\sqrt{52}$</li><li>If we have monthly data: K =$\sqrt{12}$</li></ul></li></ul></li><li><p>Implanting ideas in Python:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> pandas_datareader <span class="keyword">as</span> pdr</span><br><span class="line"><span class="keyword">import</span> yfinance <span class="keyword">as</span> yf</span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> sqrt</span><br><span class="line"></span><br><span class="line"><span class="comment">#Fetching data</span></span><br><span class="line">start = datetime.date(<span class="number">2013</span>,<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">end = datetime.date(<span class="number">2019</span>,<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">yf.pdr_override()</span><br><span class="line">TESLA = pdr.get_data_yahoo(<span class="string">"TSLA"</span>,start,end)</span><br><span class="line">GOOGLE = pdr.get_data_yahoo(<span class="string">"GOOGL"</span>,start,end)</span><br><span class="line">GM = pdr.get_data_yahoo(<span class="string">"GM"</span>,start,end)</span><br><span class="line">APPLE = pdr.get_data_yahoo(<span class="string">"AAPL"</span>,start,end)</span><br><span class="line">allocation = np.array([<span class="number">0.4</span>,<span class="number">0.2</span>,<span class="number">0.1</span>,<span class="number">0.3</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">#Set a new dataframe with close prices only</span></span><br><span class="line">df = pd.concat([TESLA[<span class="string">"Close"</span>],GOOGLE[<span class="string">"Close"</span>],GM[<span class="string">"Close"</span>],APPLE[<span class="string">"Close"</span>]],axis = <span class="number">1</span>)</span><br><span class="line">df.columns = [<span class="string">"TESLA"</span>,<span class="string">"GOOGLE"</span>,<span class="string">"GM"</span>,<span class="string">"APPLE"</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#Find daily return</span></span><br><span class="line">daily_return = ((df/df.shift(<span class="number">1</span>))<span class="number">-1</span>)*allocation</span><br><span class="line">Total_daily_return = daily_return.sum(axis = <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#Find mean and std of daily return</span></span><br><span class="line">daily_return_mean = Total_daily_return.mean()</span><br><span class="line">daily_return_std = Total_daily_return.std()</span><br><span class="line"></span><br><span class="line"><span class="comment">#Find SR and ASR</span></span><br><span class="line">SR = daily_return_mean/daily_return_std</span><br><span class="line">ASR = SR*sqrt(<span class="number">252</span>)</span><br><span class="line">print(ASR)</span><br></pre></td></tr></table></figure></li></ol></li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;9-Time-series-analysis&quot;&gt;&lt;a href=&quot;#9-Time-series-analysis&quot; class=&quot;headerlink&quot; title=&quot;9. Time series analysis&quot;&gt;&lt;/a&gt;9. Time series analysis&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Key words related to time series:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Trend: Upward, Horizontal/Stationary and Downward.&lt;/li&gt;
&lt;li&gt;Seasonality(季节性): repeated trends&lt;/li&gt;
&lt;li&gt;Cyclical(周期性): trends with no set repetition&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Statsmodels:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;import statsmodels.api as sm&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Demo: Hodrick-Prescott filter: $\min_{\{ \tau_{t}\} }\sum_{t}^{T}\zeta_{t}^{2}+\lambda\sum_{t=1}^{T}\left[\left(\tau_{t}-\tau_{t-1}\right)-\left(\tau_{t-1}-\tau_{t-2}\right)\right]^{2}$&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;#Fetching data&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;yf.pdr_override()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;start = datetime.date(&lt;span class=&quot;number&quot;&gt;2018&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;end = datetime.date(&lt;span class=&quot;number&quot;&gt;2019&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;9&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;16&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;data = pdr.get_data_yahoo(&lt;span class=&quot;string&quot;&gt;&quot;TSLA&quot;&lt;/span&gt;,start,end)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;#Applying Hodrick-Prescott filter, We get back a tuple with two elements, the first is the cycle pandas series and the second is the trend pandas series.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;close_cycle, close_trend = sm.tsa.filters.hpfilter(data[&lt;span class=&quot;string&quot;&gt;&quot;Close&quot;&lt;/span&gt;])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;#Plotting&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;fig,axe = plt.subplots(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;#data[&quot;Close&quot;].plot(label = &quot;Raw data&quot;)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;#close_cycle.plot(label = &quot;Cycle&quot;)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;close_trend.plot(label = &lt;span class=&quot;string&quot;&gt;&quot;Trend&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;data[&lt;span class=&quot;string&quot;&gt;&quot;Close&quot;&lt;/span&gt;].rolling(&lt;span class=&quot;number&quot;&gt;20&lt;/span&gt;).mean().plot(label = &lt;span class=&quot;string&quot;&gt;&quot;20MA&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;axe.set_xlabel(&lt;span class=&quot;string&quot;&gt;&quot;Price&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;axe.set_ylabel(&lt;span class=&quot;string&quot;&gt;&quot;Time&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;axe.set_title(&lt;span class=&quot;string&quot;&gt;&quot;Hodrick-Prescott filter analysis on Tesla&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;plt.legend()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;plt.show()&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Programming" scheme="https://yuxuanliu.tech/categories/Programming/"/>
    
      <category term="Finance" scheme="https://yuxuanliu.tech/categories/Finance/"/>
    
    
      <category term="Python" scheme="https://yuxuanliu.tech/tags/Python/"/>
    
      <category term="Finance" scheme="https://yuxuanliu.tech/tags/Finance/"/>
    
  </entry>
  
  <entry>
    <title>Python for Finance part 1</title>
    <link href="https://yuxuanliu.tech/Python_for_Finance_1/"/>
    <id>https://yuxuanliu.tech/Python_for_Finance_1/</id>
    <published>2019-09-17T16:43:30.000Z</published>
    <updated>2019-09-30T03:32:37.021Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1. Introduction"></a>1. Introduction</h2><ol><li>First do <code>activate pyfinance</code> to activate the conda environment. Then do <code>jupyter notebook</code> to run the note book</li></ol><h2 id="2-Python-review"><a href="#2-Python-review" class="headerlink" title="2. Python review"></a>2. Python review</h2><ol><li><p><code>0</code> also means <code>False</code> in python. <code>0.1</code> is <code>True</code></p><p><code>[1,2,3]</code> can also means <code>True</code> but <code>[]</code> means <code>False</code></p><p>If you have something, we can say it is <code>True</code>. If there is nothing(empty), we can say it is <code>False</code>.</p></li><li><p><code>.format()</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">"My name is &#123;x&#125;, I am &#123;y&#125; years old"</span>.format(y=<span class="number">19</span>,x=<span class="string">"Oscar"</span>))</span><br><span class="line">print(<span class="string">"My name is &#123;&#125;, I am &#123;&#125; years old"</span>.format(<span class="string">"Oscar"</span>,<span class="number">19</span>))</span><br></pre></td></tr></table></figure><p>The two methods above are equivalent.</p></li><li><p>Lambda expression: anonymous function, we don’t have to write the whole <code>def</code> structure.</p><ul><li><p>Basics:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="keyword">lambda</span> x,y:x+y</span><br><span class="line">print(a(<span class="number">1</span>,<span class="number">2</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plus</span><span class="params">(x,y)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x+y</span><br><span class="line">print(plus(<span class="number">1</span>,<span class="number">2</span>))</span><br></pre></td></tr></table></figure><p>These two methods are equivalent.</p><a id="more"></a></li><li><p>Jump table:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">jump = [<span class="keyword">lambda</span> x:x+<span class="number">1</span>,<span class="keyword">lambda</span> x:x+<span class="number">2</span>,<span class="keyword">lambda</span> x:x+<span class="number">3</span>]</span><br><span class="line">print(jump[<span class="number">0</span>](<span class="number">1</span>))</span><br><span class="line">print(jump[<span class="number">1</span>](<span class="number">1</span>))</span><br><span class="line">print(jump[<span class="number">2</span>](<span class="number">1</span>))</span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>map()</code> : takes two arguments, the first argument is a function, the second argument is an iterable object. Each element within the iterable object will be passed in the function respectively. See example below.</p><ul><li><p>One way:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plus</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x+<span class="number">2</span></span><br><span class="line">list1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">list2 = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> list1:</span><br><span class="line">    tem = plus(i)</span><br><span class="line">    list2.append(tem)</span><br><span class="line">print(list2)</span><br></pre></td></tr></table></figure><p>As you can see, super tedious.</p></li><li><p>Using lambda expression and map function:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(list(map((<span class="keyword">lambda</span> x:x+<span class="number">2</span>),[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>])))</span><br></pre></td></tr></table></figure><p>We can simply make it one line of code only(for demo purpose only, can be hard to read).</p><p>Don’t forget to put a <code>list()</code> or something similar functions after using <code>map()</code></p></li></ul></li><li><p><code>filter()</code>: similar to <code>map()</code>takes two arguments, a function(must return a Boolean value) and an iterable object. Elements can only pass the filter if the function returns <code>True</code>. See the demo below.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">list1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>]</span><br><span class="line">print(list(filter((<span class="keyword">lambda</span> x:(x%<span class="number">2</span>==<span class="number">0</span>)),list1)))</span><br></pre></td></tr></table></figure><p>Again, for demo purpose only and don’t forget <code>list()</code>.</p></li><li><p><code>zip()</code>: we can combine two list into one. See below.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">list1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">list2 = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line">print(list(zip(list1,list2)))</span><br></pre></td></tr></table></figure><p>This gives <code>[(1,4),(2,5),(3,6)]</code>.</p><p>A useful trick, we can combine two lists of same length into one dictionary. See below.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">list1 = [<span class="string">"one"</span>,<span class="string">"two"</span>,<span class="string">"three"</span>]</span><br><span class="line">list2 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">print(dict(zip(list1,list2)))</span><br></pre></td></tr></table></figure><p>This gives <code>{&#39;one&#39;: 1, &#39;two&#39;: 2, &#39;three&#39;: 3}</code></p></li><li><p>Please view <a href="https://yuxuanliu.tech/python_basics/">Python basics</a> and <a href="https://yuxuanliu.tech/python_revision/">Python revision notes</a> for more information about Python.</p></li></ol><h2 id="3-Numpy-introduction"><a href="#3-Numpy-introduction" class="headerlink" title="3. Numpy introduction"></a>3. Numpy introduction</h2><p>Please refer to my <a href="https://yuxuanliu.tech/numpy_notes/">Numpy notes</a>.</p><h2 id="4-Pandas-introduction"><a href="#4-Pandas-introduction" class="headerlink" title="4. Pandas introduction"></a>4. Pandas introduction</h2><p>Please refer to my <a href="https://yuxuanliu.tech/pandas_basics/#more">Pandas basics notes</a>, <a href="https://yuxuanliu.tech/pandas_advanced/#more">Pandas advanced notes</a> and <a href="https://yuxuanliu.tech/pandas_visulisation/#more">Pandas visualization notes</a>.</p><h2 id="5-Matplotlib-introduction"><a href="#5-Matplotlib-introduction" class="headerlink" title="5. Matplotlib introduction"></a>5. Matplotlib introduction</h2><p>Please refer to my <a href="https://yuxuanliu.tech/Matplotlib_basics/#more">Matplotlib notes</a>.</p><h2 id="6-Data-sources"><a href="#6-Data-sources" class="headerlink" title="6. Data sources"></a>6. Data sources</h2><ol><li><p>Two ways of obtaining data: Pandas-datareader and <a href="https://www.quandl.com/" target="_blank" rel="noopener">Quandl</a>.</p></li><li><p>Pandas-datareader:</p><ul><li><p>Documentation: <a href="https://pandas-datareader.readthedocs.io/en/latest/index.html" target="_blank" rel="noopener">https://pandas-datareader.readthedocs.io/en/latest/index.html</a></p></li><li><p>Using Pandas-datareader to access Yahoo API:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas_datareader.data <span class="keyword">as</span> pdr</span><br><span class="line"><span class="keyword">import</span> yfinance <span class="keyword">as</span> yf</span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line">yf.pdr_override()</span><br><span class="line">start = datetime.date(<span class="number">2019</span>,<span class="number">1</span>,<span class="number">1</span>).__format__(<span class="string">'%Y-%m-%d'</span>)</span><br><span class="line">end = datetime.date(<span class="number">2019</span>,<span class="number">6</span>,<span class="number">6</span>).__format__(<span class="string">'%Y-%m-%d'</span>)</span><br><span class="line">data = pdr.get_data_yahoo(<span class="string">"FB"</span>,start,end)</span><br><span class="line">print(data.head())</span><br></pre></td></tr></table></figure></li><li><p>Using Pandas-datareader to access Quandl:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas_datareader.data <span class="keyword">as</span> pdr</span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line">api_key= <span class="string">"Fill in your api key"</span></span><br><span class="line">start = datetime.date(<span class="number">2014</span>,<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">end = datetime.date(<span class="number">2015</span>,<span class="number">6</span>,<span class="number">6</span>)</span><br><span class="line">data = pdr.DataReader(<span class="string">"WIKI/FB"</span>,<span class="string">"quandl"</span>,start,end,access_key=api_key)</span><br><span class="line">print(data.head())</span><br></pre></td></tr></table></figure><p><code>&quot;WIKI/FB&quot;</code> is the key on Quandl, which is in the format of <code>DB_name/Sticker_name</code>. You can find out these keys on their website. </p></li></ul></li><li><p>Quandl</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">import</span> quandl</span><br><span class="line">quandl.ApiConfig.api_key = <span class="string">"Fill in your api key"</span></span><br><span class="line">data = quandl.get(<span class="string">"WIKI/FB"</span>)</span><br><span class="line">print(data.head())</span><br></pre></td></tr></table></figure></li></ol><h2 id="7-Pandas-with-time-series-data"><a href="#7-Pandas-with-time-series-data" class="headerlink" title="7. Pandas with time series data"></a>7. Pandas with time series data</h2><ol><li><p>Python datatime basics: refer to my <a href="https://yuxuanliu.tech/datetime_summary/#more">notes</a>.</p></li><li><p>Creating datetime index:</p><ul><li><p><code>df[&quot;A&quot;]=pd.to_date_time(df[&quot;A&quot;],format = &quot;%d/%m/%Y&quot;)</code> to convert a string date object to <code>datetime.date</code> object so it can be manipulated easily using Pandas. <code>format</code> argument gives the format that the string datetime is in.</p></li><li><p><code>index = pd.DatetimeIndex(list_of_datetime)</code> to convert Python datetime objects to the format that can be used in Pandas as a datetime index.</p></li><li><p>A quick demo:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">list1 = [datetime.date(<span class="number">2019</span>,<span class="number">9</span>,<span class="number">12</span>),datetime.date(<span class="number">2019</span>,<span class="number">9</span>,<span class="number">13</span>)]</span><br><span class="line">index1 = pd.DatetimeIndex(list1)</span><br><span class="line">df = pd.DataFrame(np.random.rand(<span class="number">2</span>,<span class="number">3</span>),columns = [<span class="string">"A"</span>,<span class="string">"B"</span>,<span class="string">"C"</span>],index = index1)</span><br><span class="line">print(df)</span><br></pre></td></tr></table></figure></li></ul></li><li><p>Methods of datetime index:</p><ul><li><code>df.index.argmax()</code>: return the index of the latest date.</li><li><code>df.index.max()</code>: return the latest date.</li><li><code>df.index.argmin()</code>: return the index of the earliest date.</li><li><code>df.index.min()</code>: return the earliest date.</li></ul></li><li><p>Time resampling(need index to be datetime index):</p><ul><li><p>Similar to the <strong>groupby</strong> method, we can groupby datetime index using year-end frequency etc. In other words, put rows within one year together for aggregate functions.</p></li><li><p><code>df.resample(rule = &quot;A&quot;).sum()</code> perform aggregate functions just like doing groupby</p><p>Another example: <code>df.resample(rule = &quot;W&quot;).apply(lambda x:x[0])</code></p></li><li><p>List of rules:</p><table><thead><tr><th>Alias</th><th>Description</th></tr></thead><tbody><tr><td>B</td><td>Business day frequency</td></tr><tr><td>D</td><td>Calendar day frequency</td></tr><tr><td>W</td><td>Weekly frequency</td></tr><tr><td>SM</td><td>Semi-month end frequency(15th and end of month)</td></tr><tr><td>M</td><td>Month end frequency</td></tr><tr><td>Q</td><td>Quarter end frequency</td></tr><tr><td>A</td><td>Year end frequency</td></tr><tr><td>BA</td><td>Business year end frequency</td></tr><tr><td>AS</td><td>Year start frequency</td></tr><tr><td>H</td><td>Hourly frequency</td></tr><tr><td>T, min</td><td>Minutely frequency</td></tr><tr><td>S</td><td>Secondly frequency</td></tr><tr><td>L, ms</td><td>Millisecond frequency</td></tr><tr><td>U, us</td><td>Microsecond frequency</td></tr><tr><td>N, ns</td><td>Nanosecond frequency</td></tr></tbody></table></li><li><p><code>df.resample(rule = &quot;A&quot;).mean().plot.bar()</code> a quick bar plot</p></li></ul></li><li><p>Time shifts(need the index to be <code>datetime.datetime</code>):</p><ul><li><code>df = df.shift(periods = 1)</code> push data forward by one day, leaving the first row <code>NaN</code>. In other words, data was on <code>2019-01-01</code> is now on <code>2019-01-02</code>. </li><li><code>df = df.shift(periods = -1)</code> push data back by one day, leaving the last row <code>NaN</code>. In other words, data was on <code>2019-01-02</code> is now on <code>2019-01-01</code>. </li><li><code>df = df.tshift(freq = &quot;M&quot;)</code> push dates within each month to the end of the month. For example, <code>2019-01-01</code> becomes <code>2019-01-31</code> and <code>2019-01-02</code> becomes <code>2019-01-31</code> etc. <code>freq</code> arguments also followed the table above.</li></ul></li><li><p>Rolling average(Moving mean): <code>df[&quot;A&quot;].rolling(window = 5).mean()</code> :</p><ul><li><p>This means we are setting the value at row 4 to be the average of row 0 to row 4 and leaving row 0 to row 3 <code>NaN</code>. </p></li><li><p>Similarly, we are setting the value at row 5 to be the average of row 1 to row 5 and keep going.</p></li><li><p>This method can remove <strong>noise</strong> from the graph and help find a general trend.</p></li><li><p>Quick demo:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas_datareader.data <span class="keyword">as</span> pdr</span><br><span class="line"><span class="keyword">import</span> yfinance <span class="keyword">as</span> yf</span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">yf.pdr_override()</span><br><span class="line">start = datetime.date(<span class="number">2019</span>,<span class="number">1</span>,<span class="number">1</span>).__format__(<span class="string">'%Y-%m-%d'</span>)</span><br><span class="line">end = datetime.date(<span class="number">2019</span>,<span class="number">9</span>,<span class="number">15</span>).__format__(<span class="string">'%Y-%m-%d'</span>)</span><br><span class="line">data = pdr.get_data_yahoo(<span class="string">"FB"</span>,start,end)</span><br><span class="line"></span><br><span class="line">fig,axe = plt.subplots(<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">axe.plot(data.index,data[<span class="string">"Open"</span>],label = <span class="string">"acutal data"</span>)</span><br><span class="line">axe.plot(data.index,data[<span class="string">"Open"</span>].rolling(<span class="number">14</span>).mean(), label = <span class="string">"rolling data"</span>)</span><br><span class="line">axe.legend(loc = <span class="number">0</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></li></ul></li><li><p>Expanding method: <code>df[&quot;A&quot;].expanding().mean()</code></p><ul><li><p>This means we are setting the value at each row to be the average of all values in <strong>previous rows</strong>.</p></li><li><p>Quick demo:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas_datareader.data <span class="keyword">as</span> pdr</span><br><span class="line"><span class="keyword">import</span> yfinance <span class="keyword">as</span> yf</span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">yf.pdr_override()</span><br><span class="line">start = datetime.date(<span class="number">2019</span>,<span class="number">1</span>,<span class="number">1</span>).__format__(<span class="string">'%Y-%m-%d'</span>)</span><br><span class="line">end = datetime.date(<span class="number">2019</span>,<span class="number">9</span>,<span class="number">15</span>).__format__(<span class="string">'%Y-%m-%d'</span>)</span><br><span class="line">data = pdr.get_data_yahoo(<span class="string">"FB"</span>,start,end)</span><br><span class="line"></span><br><span class="line">fig,axe = plt.subplots(<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">axe.plot(data.index,data[<span class="string">"Open"</span>],label = <span class="string">"acutal data"</span>)</span><br><span class="line">axe.plot(data.index,data[<span class="string">"Open"</span>].rolling(<span class="number">30</span>).mean(), label = <span class="string">"rolling data"</span>)</span><br><span class="line">axe.plot(data.index,data[<span class="string">"Open"</span>].expanding().mean(), label = <span class="string">"expanding data"</span>)</span><br><span class="line">axe.legend(loc = <span class="number">0</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></li><li><p>The <code>.rolling()</code> method is more popular than the <code>.expanding()</code> method.</p></li></ul></li><li><p>Bollinger bands(布林线):</p><ul><li><p>General information:</p><ul><li>Bollinger bands are <strong>volatility bands</strong> placed above and below the moving average.</li><li>Volatility is based on the standard deviation.</li><li>Bands <strong>widen</strong> when volatility increases and <strong>narrow</strong> when volatility decreases.</li><li>Bands are used to determine whether a price movement is significant.</li><li>Price is relatively high when it is above the upper band and relatively low under the lower band.</li><li>You shouldn’t use Bollinger bands solely for trading.</li></ul></li><li><p>Full code for plotting:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas_datareader.data <span class="keyword">as</span> pdr</span><br><span class="line"><span class="keyword">import</span> yfinance <span class="keyword">as</span> yf</span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">yf.pdr_override()</span><br><span class="line">start = datetime.date(<span class="number">2019</span>,<span class="number">1</span>,<span class="number">1</span>).__format__(<span class="string">'%Y-%m-%d'</span>)</span><br><span class="line">end = datetime.date(<span class="number">2019</span>,<span class="number">9</span>,<span class="number">15</span>).__format__(<span class="string">'%Y-%m-%d'</span>)</span><br><span class="line">data = pdr.get_data_yahoo(<span class="string">"FB"</span>,start,end)</span><br><span class="line"></span><br><span class="line">fig,axe = plt.subplots(<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line"><span class="comment">#Source data</span></span><br><span class="line">axe.plot(data.index,data[<span class="string">"Close"</span>],label = <span class="string">"Source data"</span>)</span><br><span class="line"><span class="comment">#20MA</span></span><br><span class="line">axe.plot(data.index,data[<span class="string">"Close"</span>].rolling(<span class="number">20</span>).mean(), label = <span class="string">"20MA"</span>)</span><br><span class="line"><span class="comment">#Upper band</span></span><br><span class="line">axe.plot(data.index,data[<span class="string">"Close"</span>].rolling(<span class="number">20</span>).mean()+<span class="number">2</span>*data[<span class="string">"Close"</span>].rolling(<span class="number">20</span>).std(), label = <span class="string">"Upper band"</span>)</span><br><span class="line"><span class="comment">#Lower band</span></span><br><span class="line">axe.plot(data.index,data[<span class="string">"Close"</span>].rolling(<span class="number">20</span>).mean()<span class="number">-2</span>*data[<span class="string">"Close"</span>].rolling(<span class="number">20</span>).std(), label = <span class="string">"Lower band"</span>)</span><br><span class="line"></span><br><span class="line">axe.set_xlabel(<span class="string">"Time"</span>)</span><br><span class="line">axe.set_ylabel(<span class="string">"Price"</span>)</span><br><span class="line">axe.set_title(<span class="string">"Bollinger bands for Facebook between 1/1/2019 and 15/9/2015"</span>)</span><br><span class="line">axe.legend(loc = <span class="number">0</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><ul><li>20 days <strong>closing moving average</strong> is used(20MA)</li><li>Upper band = 20MA + 2$\times$ std(20 days)</li><li>Lower band = 20MA - 2$\times$ std(20 days)</li></ul></li></ul></li></ol><h2 id="8-Notes-on-the-capstone-project"><a href="#8-Notes-on-the-capstone-project" class="headerlink" title="8. Notes on the capstone project"></a>8. Notes on the capstone project</h2><ol><li><p>Two ways of finding the index of the maximum value in a column:</p><ul><li><code>data3.sort_values(&quot;Volume&quot;,ascending= False).iloc[0:1].index</code></li><li><code>data3[&quot;Volume&quot;].argmax()</code></li></ul></li><li><p>Market cap = share price $\times$ total units of stock present</p><p>A company with higher share price does not necessary be more valuable than the other with a lower share price as we also need to take into account the total units of stock present.</p></li><li><p>Plotting scatter matrix:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pandas.plotting <span class="keyword">import</span> scatter_matrix</span><br><span class="line">scatter_matrix(df1,figsize=(<span class="number">16</span>,<span class="number">8</span>),alpha = <span class="number">0.2</span>,hist_kwds= &#123;<span class="string">'bins'</span>:<span class="number">30</span>&#125;)</span><br></pre></td></tr></table></figure></li><li><p>Candlestick chart(K线图):</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> pandas_datareader <span class="keyword">as</span> pdr</span><br><span class="line"><span class="keyword">import</span> yfinance <span class="keyword">as</span> yf</span><br><span class="line"><span class="keyword">from</span> mpl_finance <span class="keyword">import</span> candlestick_ohlc</span><br><span class="line"><span class="keyword">from</span> matplotlib.dates <span class="keyword">import</span> DateFormatter, date2num, WeekdayLocator, DayLocator, MONDAY</span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#Fetching data</span></span><br><span class="line">yf.pdr_override()</span><br><span class="line">start = datetime.date(<span class="number">2019</span>,<span class="number">8</span>,<span class="number">16</span>).__format__(<span class="string">"%d-%m-%Y"</span>)</span><br><span class="line">end = datetime.date(<span class="number">2019</span>,<span class="number">9</span>,<span class="number">16</span>).__format__(<span class="string">"%d-%m-%Y"</span>)</span><br><span class="line">data = pdr.get_data_yahoo(<span class="string">"TSLA"</span>,start,end)</span><br><span class="line"><span class="comment">#Reset index because there is no .apply() method on datetimeindex, we need to change it into a normal column first.</span></span><br><span class="line">df2 = data.reset_index()</span><br><span class="line"></span><br><span class="line"><span class="comment">#Change datetime.date into integer days so it can be recognised by Matplotlib</span></span><br><span class="line">df2[<span class="string">"date in num"</span>] = df2[<span class="string">"Date"</span>].apply(<span class="keyword">lambda</span> x:date2num(x))</span><br><span class="line"></span><br><span class="line"><span class="comment">#candlestick_ohlc() is taking a list with tuples(date_num,Open,High,Low,Close) inside</span></span><br><span class="line">list_for_plotting = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(df2[<span class="string">"Date"</span>])):</span><br><span class="line">    info=(float(df2.loc[i,<span class="string">"date in num"</span>]),float(df2.loc[i,<span class="string">"Open"</span>]),float(df2.loc[i,<span class="string">"High"</span>]),float(df2.loc[i,<span class="string">"Low"</span>]),float(df2.loc[i,<span class="string">"Close"</span>]))</span><br><span class="line">    list_for_plotting.append(info)</span><br><span class="line">    </span><br><span class="line"><span class="comment">#Formatting candlestick chart</span></span><br><span class="line">mondays = WeekdayLocator(MONDAY)        <span class="comment"># major ticks on the mondays</span></span><br><span class="line">alldays = DayLocator()              <span class="comment"># minor ticks on the days</span></span><br><span class="line">weekFormatter = DateFormatter(<span class="string">'%b %d'</span>)  <span class="comment"># e.g., Jan 12</span></span><br><span class="line">dayFormatter = DateFormatter(<span class="string">'%d'</span>)      <span class="comment"># e.g., 12</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#Plot it</span></span><br><span class="line">fig, ax = plt.subplots(figsize = (<span class="number">16</span>,<span class="number">8</span>))</span><br><span class="line">fig.subplots_adjust(bottom=<span class="number">0.2</span>)</span><br><span class="line">ax.xaxis.set_major_locator(mondays)</span><br><span class="line">ax.xaxis.set_minor_locator(alldays)</span><br><span class="line">ax.xaxis.set_major_formatter(weekFormatter)</span><br><span class="line">candlestick_ohlc(ax, list_for_plotting, width=<span class="number">0.6</span>, colorup=<span class="string">'g'</span>,colordown=<span class="string">'r'</span>)</span><br><span class="line">ax.set_title(<span class="string">"Candlestick chart for Tesla between 17/8/2019 and 17/9/2015"</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></li><li><p>Daily percentage change(Daily return) = $\frac{P_{t}}{P_{t-1}}-1$</p><ul><li><p>$P_{t}$: price at time <strong>t</strong></p></li><li><p>$P_{t-1}$: price at time <strong>t-1</strong></p></li><li><p>Percentage of gain in one day relative to <strong>the price of yesterday</strong>.</p></li><li><p>If you plot daily return in a histogram and it is wide means high volatility</p></li><li><p>Python code:</p><ul><li><p>Method 1:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df[<span class="string">"daily return"</span>] = (df[<span class="string">"Close"</span>]/df.shift(<span class="number">1</span>)[<span class="string">"Close"</span>]) - <span class="number">1</span></span><br></pre></td></tr></table></figure></li><li><p>Method 2”</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df[<span class="string">"daily return"</span>] = df[<span class="string">"Close"</span>].pct_change(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p><code>.pct_change(1)</code> means percentage change in a period of 1 day and it is exactly what we do in method 1.</p></li></ul></li></ul></li><li><p>Cumulative daily returns:</p><ul><li><p>The aggregate amount an investment has gained or lost over time, independent of the period of time involved.</p></li><li><p>Daily return is useful but it doesn’t give a insight into how much a investor is actually making. Cumulative return is computed relatively to <strong>the day investment is made</strong>.</p></li><li><p>Formula: $R_{c} = \frac{P_{t}}{P_{0}}-1$</p></li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-Introduction&quot;&gt;&lt;a href=&quot;#1-Introduction&quot; class=&quot;headerlink&quot; title=&quot;1. Introduction&quot;&gt;&lt;/a&gt;1. Introduction&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;First do &lt;code&gt;activate pyfinance&lt;/code&gt; to activate the conda environment. Then do &lt;code&gt;jupyter notebook&lt;/code&gt; to run the note book&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;2-Python-review&quot;&gt;&lt;a href=&quot;#2-Python-review&quot; class=&quot;headerlink&quot; title=&quot;2. Python review&quot;&gt;&lt;/a&gt;2. Python review&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;0&lt;/code&gt; also means &lt;code&gt;False&lt;/code&gt; in python. &lt;code&gt;0.1&lt;/code&gt; is &lt;code&gt;True&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;[1,2,3]&lt;/code&gt; can also means &lt;code&gt;True&lt;/code&gt; but &lt;code&gt;[]&lt;/code&gt; means &lt;code&gt;False&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;If you have something, we can say it is &lt;code&gt;True&lt;/code&gt;. If there is nothing(empty), we can say it is &lt;code&gt;False&lt;/code&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;.format()&lt;/code&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;print(&lt;span class=&quot;string&quot;&gt;&quot;My name is &amp;#123;x&amp;#125;, I am &amp;#123;y&amp;#125; years old&quot;&lt;/span&gt;.format(y=&lt;span class=&quot;number&quot;&gt;19&lt;/span&gt;,x=&lt;span class=&quot;string&quot;&gt;&quot;Oscar&quot;&lt;/span&gt;))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;print(&lt;span class=&quot;string&quot;&gt;&quot;My name is &amp;#123;&amp;#125;, I am &amp;#123;&amp;#125; years old&quot;&lt;/span&gt;.format(&lt;span class=&quot;string&quot;&gt;&quot;Oscar&quot;&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;19&lt;/span&gt;))&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;The two methods above are equivalent.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Lambda expression: anonymous function, we don’t have to write the whole &lt;code&gt;def&lt;/code&gt; structure.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Basics:&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;a = &lt;span class=&quot;keyword&quot;&gt;lambda&lt;/span&gt; x,y:x+y&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;print(a(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;plus&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(x,y)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; x+y&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;print(plus(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;))&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;These two methods are equivalent.&lt;/p&gt;
    
    </summary>
    
    
      <category term="Programming" scheme="https://yuxuanliu.tech/categories/Programming/"/>
    
      <category term="Finance" scheme="https://yuxuanliu.tech/categories/Finance/"/>
    
    
      <category term="Python" scheme="https://yuxuanliu.tech/tags/Python/"/>
    
      <category term="Finance" scheme="https://yuxuanliu.tech/tags/Finance/"/>
    
  </entry>
  
  <entry>
    <title>Pandas visulisation basics</title>
    <link href="https://yuxuanliu.tech/pandas_visulisation/"/>
    <id>https://yuxuanliu.tech/pandas_visulisation/</id>
    <published>2019-09-16T17:01:53.000Z</published>
    <updated>2019-09-16T10:05:37.354Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p><code>import seaborn as sns</code> to make your plots more stylish(optional).</p></li><li><p><code>df1[&quot;A&quot;].plot.hist(bins = 30)</code> to produce a histogram from <strong>values</strong>, y axis will be frequency.</p></li><li><p><code>df1[&quot;A&quot;].plot.line()</code> to produce a line plot. It is also the graph you get if you do <code>df1[&quot;A&quot;].plot()</code></p></li><li><p><code>df1.plot.area(alpha = 0.5)</code> to produce an area plot which is similar to a line plot but the area under the lines is filled.</p></li><li><p><code>df1.plot.bar()</code> to produce a bar plot</p><a id="more"></a></li><li><ul><li><code>df1.plot.scatter(x=&quot;A&quot;,y=&quot;B&quot;,c=&quot;C&quot;)</code> to produce a scatter plot(散布图). Use the argument <code>c</code> to set intensity of the color so we have a scatter plot in <strong>3D</strong>.</li><li><code>df1.plot.scatter(x=&quot;A&quot;,y=&quot;B&quot;,s=df1[&quot;C&quot;]*100)</code> we can also use sizes of the dots rather than intensity of the color to express values of the third column.</li></ul></li><li><p><code>df = pd.read_csv(&quot;Filename.csv&quot;,index_col = &quot;A&quot;, parse_dates= True)</code> to read data with datetime information.</p></li><li><p><code>df.plot.line(xlim = [&quot;2007-01-01&quot;,&quot;2008-01-01&quot;],ylim = [20,50])</code> set boundaries for x axis and y axis of the plot.</p></li><li><p>Formatting plots with datatime information:</p><ul><li><p>Full code:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> matplotlib.dates <span class="keyword">as</span> dates</span><br><span class="line"></span><br><span class="line">df = pd.read_csv(<span class="string">'mcdonalds.csv'</span>,index_col=<span class="string">'Date'</span>,parse_dates=<span class="literal">True</span>)</span><br><span class="line"><span class="comment">#Slcing date information</span></span><br><span class="line">idx = df.loc[<span class="string">"2007-01-01"</span>:<span class="string">"2007-01-29"</span>].index</span><br><span class="line"><span class="comment">#slicing data</span></span><br><span class="line">data = df.loc[<span class="string">"2007-01-01"</span>:<span class="string">"2007-01-29"</span>,<span class="string">"Adj. Close"</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#Creating a plot on Matplotlib</span></span><br><span class="line">fig,axe = plt.subplots(<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line"><span class="comment">#A special line of code when ploting time series data</span></span><br><span class="line">axe.plot_date(idx,data,<span class="string">"-"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#Setting scale and formatting of the minor axis</span></span><br><span class="line">axe.xaxis.set_minor_locator(dates.DayLocator())</span><br><span class="line">axe.xaxis.set_minor_formatter(dates.DateFormatter(<span class="string">"%d"</span>))</span><br><span class="line"><span class="comment">#Setting scale and formatting of the major axis</span></span><br><span class="line">axe.xaxis.set_major_locator(dates.WeekdayLocator(byweekday=<span class="number">0</span>))</span><br><span class="line">axe.xaxis.set_major_formatter(dates.DateFormatter(<span class="string">"%A"</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">#Fixing overlap</span></span><br><span class="line">fig.autofmt_xdate()</span><br><span class="line">plt.tight_layout()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></li><li><p>Basically slicing data from the dataframe first. Then, plot and format data again in Matplotlib.</p></li><li><p><code>import matplotlib.dates as dates</code> the module used for formatting dates</p></li><li><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">idx = df.loc[<span class="string">"2007-01-01"</span>:<span class="string">"2007-01-29"</span>].index</span><br><span class="line">data = df.loc[<span class="string">"2007-01-01"</span>:<span class="string">"2007-01-29"</span>,<span class="string">"Adj. Close"</span>]</span><br></pre></td></tr></table></figure><p>Slicing dates and values from the dataframe</p></li><li><p><code>axe.xaxis.set_major_locator(dates.Monthlocator())</code> setting the scale(刻度) of the major axis and the minor axis. There are:</p><ul><li><code>.MinuteLocator()</code>: set minute as the scale</li><li><code>.HourLocator()</code>: set hour as the scale</li><li><code>.DayLocator()</code>: set day as the scale</li><li><code>.WeekdayLocator(byweekday = 0)</code>: Set week as the scale and every Monday will be shown</li><li><code>.MonthLocator()</code>: Set month as the scale</li><li><code>.YearLocator()</code>: Set year as the scale</li></ul></li><li><p><code>axe.xaxis.set_major_formatter(dates.DateFormatter(&quot;%b-%Y&quot;))</code> formatting date expression</p></li><li><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">axe.xaxis.set_minor_locator(dates.MonthLocator())</span><br><span class="line">axe.xaxis.set_minor_locator(dates.DateFormattor(<span class="string">"%n"</span>))</span><br></pre></td></tr></table></figure><p>Works exactly the same for setting minor axis.</p></li><li><p><code>fig.autofmt_xdate()</code> solve the overlapping problem in the x axis</p></li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;import seaborn as sns&lt;/code&gt; to make your plots more stylish(optional).&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;df1[&amp;quot;A&amp;quot;].plot.hist(bins = 30)&lt;/code&gt; to produce a histogram from &lt;strong&gt;values&lt;/strong&gt;, y axis will be frequency.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;df1[&amp;quot;A&amp;quot;].plot.line()&lt;/code&gt; to produce a line plot. It is also the graph you get if you do &lt;code&gt;df1[&amp;quot;A&amp;quot;].plot()&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;df1.plot.area(alpha = 0.5)&lt;/code&gt; to produce an area plot which is similar to a line plot but the area under the lines is filled.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;df1.plot.bar()&lt;/code&gt; to produce a bar plot&lt;/p&gt;
    
    </summary>
    
    
      <category term="Programming" scheme="https://yuxuanliu.tech/categories/Programming/"/>
    
    
      <category term="Python" scheme="https://yuxuanliu.tech/tags/Python/"/>
    
      <category term="Pandas" scheme="https://yuxuanliu.tech/tags/Pandas/"/>
    
  </entry>
  
  <entry>
    <title>Python datetime summary</title>
    <link href="https://yuxuanliu.tech/datetime_summary/"/>
    <id>https://yuxuanliu.tech/datetime_summary/</id>
    <published>2019-09-15T23:03:21.000Z</published>
    <updated>2019-09-16T16:19:00.903Z</updated>
    
    <content type="html"><![CDATA[<p><code>import datetime</code></p><h2 id="1-datetime-date"><a href="#1-datetime-date" class="headerlink" title="1. datetime.date"></a>1. datetime.date</h2><ol><li><p><code>datetime.date.today()</code> return the date of today. </p></li><li><p>Accessing year, month and date attributes:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = datetime.date.today()</span><br><span class="line">print(a.year)</span><br><span class="line">print(a.month)</span><br><span class="line">print(a.day)</span><br></pre></td></tr></table></figure></li><li><p><code>b = datetime.date(Year,Month,Day)</code> create a <code>datetime.date</code> object manually</p><a id="more"></a></li><li><p>Difference between two <code>datetime.date</code> objects:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = datetime.date.today()</span><br><span class="line">b = datetime.date(<span class="number">2019</span>,<span class="number">3</span>,<span class="number">15</span>)</span><br><span class="line">diff = a - b</span><br><span class="line">print(diff)</span><br><span class="line">print(diff.day)</span><br></pre></td></tr></table></figure><p><strong>diff</strong> is a <code>datetime.timedelta</code> object with <code>day</code>, <code>hour</code>, <code>minute</code>, <code>second</code> and <code>microsecond</code> attributes but you can’t <code>print()</code> these attributes directly. In stead, you need to add <code>datetime.timedelta</code> to <code>datetime.date</code> or <code>datetime.datetime</code>.</p></li><li><p>Compare size between <code>datetime.date</code> objects</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = datetime.date.today()</span><br><span class="line">b = datetime.date(<span class="number">2019</span>,<span class="number">3</span>,<span class="number">15</span>)</span><br><span class="line">print(a.__gt__(b))</span><br></pre></td></tr></table></figure><p>There are a list of similar methods available:</p><table><thead><tr><th>Methods</th><th>Operators</th></tr></thead><tbody><tr><td>a.__eq__(b)</td><td>a==b</td></tr><tr><td>a.__ge__(b)</td><td>a&gt;=b</td></tr><tr><td>a.__gt__(b)</td><td>a&gt;b</td></tr><tr><td>a.__le__(b)</td><td>a&lt;b</td></tr><tr><td>a.__lt__(b)</td><td>a&lt;=b</td></tr><tr><td>a.__ne__(b)</td><td>a!=b</td></tr></tbody></table></li><li><p><code>datetime.date()</code> methods:</p><ul><li><p><code>.isocalendar()</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">day = datetime.date(<span class="number">2019</span>,<span class="number">9</span>,<span class="number">3</span>)</span><br><span class="line">tup_format = day.isocalendar()</span><br><span class="line">print(tup_format)</span><br><span class="line"><span class="comment">#(2019, 36, 2)</span></span><br></pre></td></tr></table></figure><p>Returns a tuple in the format of <code>(year, week number, weekday)</code></p></li><li><p>String formatting</p><ul><li><p><code>.isoformat()</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">day = datetime.date(<span class="number">2019</span>,<span class="number">9</span>,<span class="number">3</span>)</span><br><span class="line">str_format = day.isoformat()</span><br><span class="line">print(str_format)</span><br><span class="line"><span class="comment">#"2019-09-03"</span></span><br></pre></td></tr></table></figure><p>Change <code>datetime.date</code> into a string(“%Y-%m-%d”)</p></li><li><p><code>.__format__()</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">day = datetime.date(<span class="number">2019</span>,<span class="number">9</span>,<span class="number">3</span>)</span><br><span class="line">str_format = day.__format(<span class="string">"%d/%m/%Y"</span>)</span><br><span class="line">print(str_format)</span><br><span class="line"><span class="comment">#"03/09/2019"</span></span><br></pre></td></tr></table></figure><p>Use the table in the appendix as reference. More control of the string format.</p></li><li><p><code>.__str__()</code></p><p>Does the same as <code>.isoformat()</code></p></li></ul></li><li><p><code>.isoweekday()</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">day = datetime.date(<span class="number">2019</span>,<span class="number">9</span>,<span class="number">3</span>)</span><br><span class="line">weekday = day.isoweekday()</span><br><span class="line">print(weekday)</span><br><span class="line"><span class="comment">#2</span></span><br></pre></td></tr></table></figure><p><strong>1</strong> stands for Monday and <strong>2</strong> stands for Tuesday etc.</p></li><li><p><code>.fromtimestamp()</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line">stamp = time.time()</span><br><span class="line">day = datetime.date.fromtimestamp(stamp)</span><br><span class="line">print(day.isoformat())</span><br><span class="line"><span class="comment">#"2019-09-16"</span></span><br></pre></td></tr></table></figure><p>Change a time stamp to <code>datetime.date</code></p></li></ul></li></ol><h2 id="2-datetime-time"><a href="#2-datetime-time" class="headerlink" title="2. datetime.time"></a>2. datetime.time</h2><ol><li><p>Create a <code>datetime.time()</code> object manually: <code>b = datetime.time(Hour,Minute,Second,microsecond)</code></p></li><li><p>Accessing hour, minute, second, microsecond attributes</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a = datetime.time(<span class="number">19</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">113232</span>)</span><br><span class="line">print(a)</span><br><span class="line">print(a.hour)</span><br><span class="line">print(a.minute)</span><br><span class="line">print(a.second)</span><br><span class="line">print(a.microsecond)</span><br></pre></td></tr></table></figure></li><li><p>Compare size between <code>datetime.time</code> objects: works the same as <code>datetime.date</code></p></li><li><p>String formatting:</p><ul><li><code>.__format__()</code>: works the same as <code>datetime.date</code></li><li><code>.__str__()</code>: return a string in <code>Hour:Minute:Second:Mircosecond</code> format.</li></ul></li></ol><h2 id="3-datetime-datetime"><a href="#3-datetime-datetime" class="headerlink" title="3. datetime.datetime"></a>3. datetime.datetime</h2><ol><li><p><code>datetime.datetime()</code> is like a combination of <code>datetime.date</code> and <code>datetime.time</code></p></li><li><p>Create a <code>datetime.datetime()</code> object manually: </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b = datetime.datetime(Year,Month,Day,Hour,Minute,Second,microsecond)</span><br></pre></td></tr></table></figure></li><li><p>Accessing date and time attributes:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">b = datetime.datetime(<span class="number">2019</span>,<span class="number">9</span>,<span class="number">17</span>,<span class="number">9</span>,<span class="number">13</span>,<span class="number">42</span>,<span class="number">352445</span>)</span><br><span class="line">print(b.date())</span><br><span class="line">print(b.time())</span><br></pre></td></tr></table></figure><p>In other words, splitting <code>datetime.datetime</code> into <code>datetime.date</code> and <code>datetime.time</code></p></li><li><p><code>datetime.datetime.now()</code> return the current datetime</p></li><li><p><code>datetime.datetime.combine()</code>:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = datetime.date(<span class="number">2019</span>,<span class="number">9</span>,<span class="number">17</span>)</span><br><span class="line">b = datetime.time(<span class="number">9</span>,<span class="number">13</span>,<span class="number">42</span>,<span class="number">352445</span>)</span><br><span class="line">c = datetime.datetime.combine(a,b)</span><br><span class="line">print(c)</span><br></pre></td></tr></table></figure><p>Combine a <code>datetime.date</code> and a <code>datetime.time</code> into a <code>datetime.datetime</code></p></li><li><p>Difference between two <code>datetime.datetime</code> objects:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line">a = datetime.datetime.now()</span><br><span class="line">b = datetime.datetime(<span class="number">2019</span>,<span class="number">9</span>,<span class="number">17</span>,<span class="number">9</span>,<span class="number">13</span>,<span class="number">42</span>,<span class="number">352445</span>)</span><br><span class="line">diff = b-a</span><br><span class="line">print(diff)</span><br></pre></td></tr></table></figure><p><strong>diff</strong> is a <code>datetime.timedelta</code> object, we can also add a <code>datetime.timedelta</code> to another <code>datetime.datetime</code> to obtain a <code>datetime.datetime</code>.</p></li></ol><h2 id="4-Appendix"><a href="#4-Appendix" class="headerlink" title="4. Appendix"></a>4. Appendix</h2><table><thead><tr><th>符号</th><th>说明</th></tr></thead><tbody><tr><td><code>%y</code></td><td>两位数的年份表示（00-99）</td></tr><tr><td><code>%Y</code></td><td>四位数的年份表示（000-9999）</td></tr><tr><td><code>%m</code></td><td>月份（01-12）</td></tr><tr><td><code>%d</code></td><td>月内中的一天（0-31）</td></tr><tr><td><code>%H</code></td><td>24小时制小时数（0-23）</td></tr><tr><td><code>%I</code></td><td>12小时制小时数（01-12）</td></tr><tr><td><code>%M</code></td><td>分钟数（00=59）</td></tr><tr><td><code>%S</code></td><td>秒（00-59）</td></tr><tr><td><code>%a</code></td><td>本地简化星期名称</td></tr><tr><td><code>%A</code></td><td>本地完整星期名称</td></tr><tr><td><code>%b</code></td><td>本地简化的月份名称</td></tr><tr><td><code>%B</code></td><td>本地完整的月份名称</td></tr><tr><td><code>%c</code></td><td>本地相应的日期表示和时间表示</td></tr><tr><td><code>%j</code></td><td>年内的一天（001-366）</td></tr><tr><td><code>%p</code></td><td>本地A.M.或P.M.的等价符</td></tr><tr><td><code>%U</code></td><td>一年中的星期数（00-53）星期天为星期的开始</td></tr><tr><td><code>%w</code></td><td>星期（0-6），星期天为星期的开始</td></tr><tr><td><code>%W</code></td><td>一年中的星期数（00-53）星期一为星期的开始</td></tr><tr><td><code>%x</code></td><td>本地相应的日期表示</td></tr><tr><td><code>%X</code></td><td>本地相应的时间表示</td></tr><tr><td><code>%Z</code></td><td>当前时区的名称</td></tr><tr><td><code>%%</code></td><td>%号本身</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;import datetime&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;1-datetime-date&quot;&gt;&lt;a href=&quot;#1-datetime-date&quot; class=&quot;headerlink&quot; title=&quot;1. datetime.date&quot;&gt;&lt;/a&gt;1. datetime.date&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;datetime.date.today()&lt;/code&gt; return the date of today. &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Accessing year, month and date attributes:&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;a = datetime.date.today()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;print(a.year)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;print(a.month)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;print(a.day)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;b = datetime.date(Year,Month,Day)&lt;/code&gt; create a &lt;code&gt;datetime.date&lt;/code&gt; object manually&lt;/p&gt;
    
    </summary>
    
    
      <category term="Programming" scheme="https://yuxuanliu.tech/categories/Programming/"/>
    
    
      <category term="Python" scheme="https://yuxuanliu.tech/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Matplotlib basics</title>
    <link href="https://yuxuanliu.tech/Matplotlib_basics/"/>
    <id>https://yuxuanliu.tech/Matplotlib_basics/</id>
    <published>2019-09-13T22:55:53.000Z</published>
    <updated>2019-09-13T16:15:03.033Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>There are two ways of working with Matplotlib: function method and OOP method.</p></li><li><p><code>import matplotlib.pyplot as plt</code></p></li><li><ul><li><code>%matplotlib inline</code> to visualize plots inside the <strong>Jupyter notebook</strong>.</li><li><code>plt.show()</code> to visualize plots in other IDE.</li></ul></li><li><p>Quick examples:</p><ul><li><p>Functional method:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">x = np.arange(<span class="number">1</span>,<span class="number">10</span>,<span class="number">0.01</span>)</span><br><span class="line">y = x**<span class="number">2</span></span><br><span class="line">plt.plot(x,y)</span><br><span class="line">plt.xlabel(<span class="string">"X Label"</span>)</span><br><span class="line">plt.ylabel(<span class="string">"Y Label"</span>)</span><br><span class="line">plt.title(<span class="string">"Fill in the title"</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>Just putting data into <code>plt.plot()</code></p><a id="more"></a></li><li><p>Subplot method:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">x = np.arange(<span class="number">1</span>,<span class="number">10</span>,<span class="number">0.01</span>)</span><br><span class="line">y = x**<span class="number">2</span></span><br><span class="line"><span class="comment">#First part of the subplot with 1 row and 2 column and the serial number: 1</span></span><br><span class="line">plt.subplot(<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>)</span><br><span class="line">plt.plot(x,y)</span><br><span class="line"><span class="comment">#Second part of the subplot with 1 row and 2 column and has the serial number: 2</span></span><br><span class="line">plt.subplot(<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>)</span><br><span class="line">plt.plot(y,x)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>A bit messy as we are using the function method, everything will be clear after we do the OOP method.</p></li><li><p>OOP method:</p><ul><li><p>Full codes:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">  <span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">  x = np.arange(<span class="number">1</span>,<span class="number">5</span>,<span class="number">0.1</span>)</span><br><span class="line">  y = x**<span class="number">2</span></span><br><span class="line">  fig = plt.figure()</span><br><span class="line">  axes1 = fig.add_axes([<span class="number">0.1</span>,<span class="number">0.1</span>,<span class="number">0.3</span>,<span class="number">0.3</span>])</span><br><span class="line">  axes1.set_xlabel(<span class="string">"Fill in the name for x axis"</span>)</span><br><span class="line">  axes1.set_ylabel(<span class="string">"Fill in the name for y axis"</span>)</span><br><span class="line">  axes1.set_title(<span class="string">"Fill in the title"</span>)</span><br><span class="line">  axes1.plot(x,y)</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  axes2 = fig.add_axes([<span class="number">0.5</span>,<span class="number">0.5</span>,<span class="number">0.3</span>,<span class="number">0.3</span>])</span><br><span class="line">  axes2.set_xlabel(<span class="string">"Fill in the name for x axis"</span>)</span><br><span class="line">  axes2.set_ylabel(<span class="string">"Fill in the name for y axis"</span>)</span><br><span class="line">  axes2.set_title(<span class="string">"Fill in the title"</span>)</span><br><span class="line">  axes2.plot(y,x)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></li><li><p><code>fig = plt.figure()</code> creating a figure object, you can consider this as a large canvas we may put multiple axes and plots on the canvas.</p></li><li><p><code>axes = fig.add_axe([origin_x,origin_y,length_x,length_y])</code> Creating an axes object on the canvas, we can put graph inside this axes object. It takes four arguments, first two set the origin of the axes, the remainder two determines the length of the axes, where <code>1.0</code> is the maximum length of the canvas. A quick example: <code>axes = fig.add_axe[0.1,0.1,0.8,0.8]</code></p></li><li><p><code>axes.plot(x,y)</code> plot the graph inside the axis.</p></li><li><p>We have two axis on one canvas. It is very clear and <strong>flexible</strong>. I highly recommend using the OOP method rather than the function method.</p></li></ul></li></ul></li><li><p><code>.subplots()</code>:</p><ul><li><p>Full codes:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">x = np.arange(<span class="number">1</span>,<span class="number">5</span>,<span class="number">0.1</span>)</span><br><span class="line">y = x**<span class="number">2</span></span><br><span class="line"><span class="comment"># 1*2 layout</span></span><br><span class="line">fig,axes = plt.subplots(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">axes[<span class="number">0</span>].plot(x,y)</span><br><span class="line">axes[<span class="number">1</span>].plot(y,x)    </span><br><span class="line">plt.tight_layout()</span><br><span class="line">plt.show()</span><br><span class="line"><span class="comment"># 2*1 layout</span></span><br><span class="line">fig1,axes1 = plt.subplots(<span class="number">2</span>,<span class="number">1</span>)</span><br><span class="line">axes1[<span class="number">0</span>].plot(x,y)</span><br><span class="line">axes1[<span class="number">1</span>].plot(y,x)    </span><br><span class="line">plt.tight_layout()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></li><li><p><code>.subplot()</code> will do the formatting for us when creating multiple axes so we don’t have to fill in <code>.add_axis()</code> manually which is quite laborious.</p></li><li><p><code>fig,axes = plt.subplots(nrows = 1,ncols = 2)</code> This will automatically set locations of axes on the canvas. We have one row and two columns of axes here(1$\times$2 axes).</p></li><li><p><code>axes</code> here is an array. We can access individual axes by indexing <code>axes[0]</code> etc.</p></li><li><p><code>plt.tight_layout()</code> will fix the problem that axes overlapping with each other. I would say just add this line every time you do <code>plt.show()</code>in case.</p></li></ul></li><li><p>Figure size and DPI(分辨率)</p><ul><li><code>fig = plt.figure(figsize = (3,2),dpi = 100)</code><ul><li><code>figsize</code> sets the size of the ‘canvas’ and unit is <strong>inch</strong>.</li><li>dpi stands for <strong>dots per inch</strong>, normally we can just use the default dpi.</li></ul></li><li><code>fig,axes = plt.subplots(2,1,figsize = (4,4),dpi = 100)</code> works for <code>.subplots()</code> as well</li></ul></li><li><p>Save the plot: </p><ul><li><code>fig.savefig(&quot;filename.png&quot;)</code> to save the plot, also supports <strong>.jpg</strong>, <strong>.pdf</strong> etc.</li><li>Must save the plot before <code>plt.show()</code></li></ul></li><li><p>Legends(图例):</p><ul><li><p>We can put multiple plots in one axe. By adding legends, the graph will become more clear.</p></li><li><p>Full codes:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">a = np.arange(<span class="number">0</span>,<span class="number">5</span>,<span class="number">0.1</span>)</span><br><span class="line">figure = plt.figure()</span><br><span class="line">axe = figure.add_axes([<span class="number">0.1</span>,<span class="number">0.1</span>,<span class="number">0.8</span>,<span class="number">0.8</span>])</span><br><span class="line">axe.plot(a,a**<span class="number">2</span>,label = <span class="string">"X^2"</span>)</span><br><span class="line">axe.plot(a,a**<span class="number">3</span>,label = <span class="string">"X^3"</span>)</span><br><span class="line">axe.legend(loc = <span class="number">0</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><ul><li><p>add another argument <code>label</code> in <code>axe.plot()</code></p></li><li><p><code>axe.legend(loc = 0)</code> before <code>plt.show()</code>.</p><p><code>loc</code> argument will pick the best location for the legend to prevent overlapping with plots.</p></li></ul></li></ul></li><li><p>Styling:</p><ul><li><p>Full codes:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">a = np.arange(<span class="number">0</span>,<span class="number">5</span>,<span class="number">0.1</span>)</span><br><span class="line">figure = plt.figure()</span><br><span class="line">axe = figure.add_axes([<span class="number">0.1</span>,<span class="number">0.1</span>,<span class="number">0.8</span>,<span class="number">0.8</span>])</span><br><span class="line">axe.plot(a,a**<span class="number">2</span>,color = <span class="string">"orange"</span>,</span><br><span class="line">             linewidth = <span class="number">3</span>,</span><br><span class="line">         alpha = <span class="number">0.6</span>,</span><br><span class="line">         linestyle = <span class="string">"--"</span>,</span><br><span class="line">        marker = <span class="string">"o"</span>,</span><br><span class="line">        markersize = <span class="number">2</span>,</span><br><span class="line">        markerfacecolor = <span class="string">"blue"</span>,</span><br><span class="line">        )</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></li><li><p><code>color = &quot;orange&quot;</code> to customize the color of the line, we can also use <strong>RGB hex code</strong> here for rare colors(Cambridge Blue:-) ).</p></li><li><p><code>linewidth = 3</code> to set the width of the line, by default it is 1.</p></li><li><p><code>alpha = 0.6</code> to set the transparency of our line, by default it is 1 which means not transparent at all.</p></li><li><p><code>linestype = &quot;--&quot;</code> to set the style of the line, refer to the doc for other options.</p></li><li><p><code>marker = &quot;o&quot;</code> to set some markers on the line, refer to the doc for other options.</p></li><li><p><code>markersize = 2</code> to set the size of markers.</p></li><li><p><code>markerfacecolor = &quot;blue&quot;</code> to set the color of markers.</p></li></ul></li><li><p>Plot range:</p><ul><li><p>Full code:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">a = np.arange(<span class="number">0</span>,<span class="number">5</span>,<span class="number">0.1</span>)</span><br><span class="line">figure = plt.figure()</span><br><span class="line">axe = figure.add_axes([<span class="number">0.1</span>,<span class="number">0.1</span>,<span class="number">0.8</span>,<span class="number">0.8</span>])</span><br><span class="line">axe.plot(a,a**<span class="number">2</span>)</span><br><span class="line">axe.set_xlim([<span class="number">0</span>,<span class="number">5</span>])</span><br><span class="line">axe.set_ylim([<span class="number">0</span>,<span class="number">30</span>])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></li><li><p><code>axe.set_xlim([lower_boundary,higher_boundary])</code> to set boundaries for the x axis.</p></li><li><p><code>axe.set_ylim([lower_boundary,higher_boundary])</code> to set boundaries for the y axis.</p></li></ul></li><li><p>Further reading:</p><ul><li><a href="http://www.matplotlib.org" target="_blank" rel="noopener">http://www.matplotlib.org</a> - The project web page for matplotlib.</li><li><a href="https://github.com/matplotlib/matplotlib" target="_blank" rel="noopener">https://github.com/matplotlib/matplotlib</a> - The source code for matplotlib.</li><li><a href="http://matplotlib.org/gallery.html" target="_blank" rel="noopener">http://matplotlib.org/gallery.html</a> - A large gallery with various types of plots matplotlib can create. Highly recommended! </li><li><a href="http://www.loria.fr/~rougier/teaching/matplotlib" target="_blank" rel="noopener">http://www.loria.fr/~rougier/teaching/matplotlib</a> - A good matplotlib tutorial.</li><li><a href="http://scipy-lectures.github.io/matplotlib/matplotlib.html" target="_blank" rel="noopener">http://scipy-lectures.github.io/matplotlib/matplotlib.html</a> - Another good matplotlib reference.</li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;&lt;p&gt;There are two ways of working with Matplotlib: function method and OOP method.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;import matplotlib.pyplot as plt&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;%matplotlib inline&lt;/code&gt; to visualize plots inside the &lt;strong&gt;Jupyter notebook&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;plt.show()&lt;/code&gt; to visualize plots in other IDE.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Quick examples:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Functional method:&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; matplotlib.pyplot &lt;span class=&quot;keyword&quot;&gt;as&lt;/span&gt; plt&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; numpy &lt;span class=&quot;keyword&quot;&gt;as&lt;/span&gt; np&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;x = np.arange(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;0.01&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;y = x**&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;plt.plot(x,y)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;plt.xlabel(&lt;span class=&quot;string&quot;&gt;&quot;X Label&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;plt.ylabel(&lt;span class=&quot;string&quot;&gt;&quot;Y Label&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;plt.title(&lt;span class=&quot;string&quot;&gt;&quot;Fill in the title&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;plt.show()&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;Just putting data into &lt;code&gt;plt.plot()&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Programming" scheme="https://yuxuanliu.tech/categories/Programming/"/>
    
    
      <category term="Matplotlib" scheme="https://yuxuanliu.tech/tags/Matplotlib/"/>
    
      <category term="Python" scheme="https://yuxuanliu.tech/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Pandas advanced</title>
    <link href="https://yuxuanliu.tech/pandas_advanced/"/>
    <id>https://yuxuanliu.tech/pandas_advanced/</id>
    <published>2019-09-12T14:21:17.000Z</published>
    <updated>2019-09-12T17:25:57.980Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-Handling-missing-data"><a href="#1-Handling-missing-data" class="headerlink" title="1. Handling missing data"></a>1. Handling missing data</h2><ol><li><p>Creating a dataframe with <code>NaN</code>:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">dict1 = &#123;<span class="string">"A"</span>:[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],<span class="string">"B"</span>:[<span class="number">1</span>,<span class="number">2</span>,np.nan],<span class="string">"C"</span>:[<span class="number">1</span>,np.nan,np.nan]&#125;</span><br><span class="line">df = pd.DataFrame(dict1)</span><br><span class="line">print(df)</span><br></pre></td></tr></table></figure></li><li><p>Drop missing values:</p><ul><li><code>df = df.dropna()</code> drop rows with at least one <code>NaN</code> inside</li><li><code>df = df.dropna(axis = 1)</code> drop columns with at least one <code>NaN</code> inside</li><li><code>df = df.dropna(axis = 1,thresh = 2)</code> The column won’t be dropped if there are at least two non-<code>NaN</code> values in the column.</li></ul><a id="more"></a></li><li><p>Replace missing values:</p><ul><li><code>df = df.fillna(value=&quot;Filled in value&quot;)</code> replace every <code>NaN</code> in the dataframe with a string.</li><li><code>df[&quot;B&quot;] = df[&quot;B&quot;].fillna(value=df[&quot;B&quot;].mean())</code> a very common operation in Pandas, replace <code>NaN</code> with the mean of other values within that column. There are many other Math or Statistical methods you may use to determine values for missing data.</li></ul></li></ol><h2 id="2-Group-by-method"><a href="#2-Group-by-method" class="headerlink" title="2. Group by method"></a>2. Group by method</h2><ol><li><p>It allows you to group together rows based on values in a column and perform an aggregate function(sum, average, std……) on them. See the example below.</p><table><thead><tr><th>ID</th><th>Value</th></tr></thead><tbody><tr><td>1</td><td>100</td></tr><tr><td>1</td><td>110</td></tr><tr><td>1</td><td>120</td></tr><tr><td>2</td><td>130</td></tr><tr><td>2</td><td>140</td></tr><tr><td>2</td><td>150</td></tr><tr><td>3</td><td>160</td></tr><tr><td>3</td><td>170</td></tr><tr><td>3</td><td>180</td></tr></tbody></table><p>We can change it into:</p><table><thead><tr><th>ID</th><th>Value</th></tr></thead><tbody><tr><td>1</td><td>330</td></tr><tr><td>2</td><td>420</td></tr><tr><td>3</td><td>510</td></tr></tbody></table></li><li><p>Creating the dataframe:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">data = &#123;<span class="string">'Company'</span>:[<span class="string">'GOOG'</span>,<span class="string">'GOOG'</span>,<span class="string">'MSFT'</span>,<span class="string">'MSFT'</span>,<span class="string">'FB'</span>,<span class="string">'FB'</span>],</span><br><span class="line">       <span class="string">'Person'</span>:[<span class="string">'Sam'</span>,<span class="string">'Charlie'</span>,<span class="string">'Amy'</span>,<span class="string">'Vanessa'</span>,<span class="string">'Carl'</span>,<span class="string">'Sarah'</span>],</span><br><span class="line">       <span class="string">'Sales'</span>:[<span class="number">200</span>,<span class="number">120</span>,<span class="number">340</span>,<span class="number">124</span>,<span class="number">243</span>,<span class="number">350</span>]&#125;</span><br><span class="line">df = pd.DataFrame(data)</span><br></pre></td></tr></table></figure></li><li><p>Perform aggregate functions:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">by_Comp = df.groupby(<span class="string">"Company"</span>)</span><br><span class="line"><span class="comment">#by_company is not a dataframe but an object</span></span><br><span class="line">print(by_Comp.mean())</span><br><span class="line">print(by_Comp.std())</span><br><span class="line">print(by_Comp.sum())</span><br><span class="line">print(by_Comp.count())</span><br><span class="line">print(by_Comp.max())</span><br><span class="line">print(by_Comp.min())</span><br><span class="line">print(by_Comp.count())</span><br><span class="line">print(by_Comp.describe())</span><br><span class="line">print(df.groupby(<span class="string">'Company'</span>).sum().loc[<span class="string">'GOOG'</span>])</span><br></pre></td></tr></table></figure></li></ol><ul><li>A dataframe is returned after performing the aggregate function, so we can perform all dataframe operations on it such as the last line of the code</li><li><code>print(by_Comp.describe())</code> a super powerful aggregate function. It is the sum of all other aggregated functions listed above.</li></ul><h2 id="3-Merging-joining-and-concatenating"><a href="#3-Merging-joining-and-concatenating" class="headerlink" title="3. Merging, joining and concatenating"></a>3. Merging, joining and concatenating</h2><ol><li><p>Creating dataframes</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="comment"># Concatenating</span></span><br><span class="line">df1 = pd.DataFrame(&#123;<span class="string">'A'</span>: [<span class="string">'A0'</span>, <span class="string">'A1'</span>, <span class="string">'A2'</span>, <span class="string">'A3'</span>],</span><br><span class="line">                        <span class="string">'B'</span>: [<span class="string">'B0'</span>, <span class="string">'B1'</span>, <span class="string">'B2'</span>, <span class="string">'B3'</span>],</span><br><span class="line">                        <span class="string">'C'</span>: [<span class="string">'C0'</span>, <span class="string">'C1'</span>, <span class="string">'C2'</span>, <span class="string">'C3'</span>],</span><br><span class="line">                        <span class="string">'D'</span>: [<span class="string">'D0'</span>, <span class="string">'D1'</span>, <span class="string">'D2'</span>, <span class="string">'D3'</span>]&#125;,</span><br><span class="line">                        index=[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"></span><br><span class="line">df2 = pd.DataFrame(&#123;<span class="string">'A'</span>: [<span class="string">'A4'</span>, <span class="string">'A5'</span>, <span class="string">'A6'</span>, <span class="string">'A7'</span>],</span><br><span class="line">                        <span class="string">'B'</span>: [<span class="string">'B4'</span>, <span class="string">'B5'</span>, <span class="string">'B6'</span>, <span class="string">'B7'</span>],</span><br><span class="line">                        <span class="string">'C'</span>: [<span class="string">'C4'</span>, <span class="string">'C5'</span>, <span class="string">'C6'</span>, <span class="string">'C7'</span>],</span><br><span class="line">                        <span class="string">'D'</span>: [<span class="string">'D4'</span>, <span class="string">'D5'</span>, <span class="string">'D6'</span>, <span class="string">'D7'</span>]&#125;,</span><br><span class="line">                         index=[<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]) </span><br><span class="line"></span><br><span class="line">df3 = pd.DataFrame(&#123;<span class="string">'A'</span>: [<span class="string">'A8'</span>, <span class="string">'A9'</span>, <span class="string">'A10'</span>, <span class="string">'A11'</span>],</span><br><span class="line">                        <span class="string">'B'</span>: [<span class="string">'B8'</span>, <span class="string">'B9'</span>, <span class="string">'B10'</span>, <span class="string">'B11'</span>],</span><br><span class="line">                        <span class="string">'C'</span>: [<span class="string">'C8'</span>, <span class="string">'C9'</span>, <span class="string">'C10'</span>, <span class="string">'C11'</span>],</span><br><span class="line">                        <span class="string">'D'</span>: [<span class="string">'D8'</span>, <span class="string">'D9'</span>, <span class="string">'D10'</span>, <span class="string">'D11'</span>]&#125;,</span><br><span class="line">                        index=[<span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>])</span><br><span class="line"><span class="comment">#Merging</span></span><br><span class="line">left = pd.DataFrame(&#123;<span class="string">'key'</span>: [<span class="string">'K0'</span>, <span class="string">'K1'</span>, <span class="string">'K2'</span>, <span class="string">'K3'</span>],</span><br><span class="line">                     <span class="string">'A'</span>: [<span class="string">'A0'</span>, <span class="string">'A1'</span>, <span class="string">'A2'</span>, <span class="string">'A3'</span>],</span><br><span class="line">                     <span class="string">'B'</span>: [<span class="string">'B0'</span>, <span class="string">'B1'</span>, <span class="string">'B2'</span>, <span class="string">'B3'</span>]&#125;)</span><br><span class="line">   </span><br><span class="line">right = pd.DataFrame(&#123;<span class="string">'key'</span>: [<span class="string">'K0'</span>, <span class="string">'K1'</span>, <span class="string">'K2'</span>, <span class="string">'K3'</span>],</span><br><span class="line">                          <span class="string">'C'</span>: [<span class="string">'C0'</span>, <span class="string">'C1'</span>, <span class="string">'C2'</span>, <span class="string">'C3'</span>],</span><br><span class="line">                          <span class="string">'D'</span>: [<span class="string">'D0'</span>, <span class="string">'D1'</span>, <span class="string">'D2'</span>, <span class="string">'D3'</span>]&#125;)   </span><br><span class="line"><span class="comment">#Joining</span></span><br><span class="line">left1 = pd.DataFrame(&#123;<span class="string">'A'</span>: [<span class="string">'A0'</span>, <span class="string">'A1'</span>, <span class="string">'A2'</span>],</span><br><span class="line">                     <span class="string">'B'</span>: [<span class="string">'B0'</span>, <span class="string">'B1'</span>, <span class="string">'B2'</span>]&#125;,</span><br><span class="line">                      index=[<span class="string">'K0'</span>, <span class="string">'K1'</span>, <span class="string">'K2'</span>]) </span><br><span class="line"></span><br><span class="line">right1 = pd.DataFrame(&#123;<span class="string">'C'</span>: [<span class="string">'C0'</span>, <span class="string">'C2'</span>, <span class="string">'C3'</span>],</span><br><span class="line">                    <span class="string">'D'</span>: [<span class="string">'D0'</span>, <span class="string">'D2'</span>, <span class="string">'D3'</span>]&#125;,</span><br><span class="line">                      index=[<span class="string">'K0'</span>, <span class="string">'K2'</span>, <span class="string">'K3'</span>])</span><br></pre></td></tr></table></figure></li><li><p>Concatenating: simply glues multiple dataframes together. Leaving the missing data <code>NaN</code>, no need to set a column as the key.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(pd.concat([df1,df2,df3],axis = <span class="number">0</span>))</span><br><span class="line">print(pd.concat([df1,df2,df3],axis = <span class="number">1</span>))</span><br></pre></td></tr></table></figure><p>When <code>axis = 0</code>, sticking rows together</p><p>when <code>axis = 1</code>, sticking columns together</p></li><li><p>Merging: combine dataframes together by using a column(s) <strong>other than</strong> the index column as the key.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">print(pd.merge(left,right,on = <span class="string">"key"</span>,how = <span class="string">'inner'</span>))</span><br><span class="line">print(pd.merge(left,right,on = <span class="string">"key"</span>,how = <span class="string">'outer'</span>))</span><br><span class="line">print(pd.merge(left,right,on = <span class="string">"key"</span>,how = <span class="string">'left'</span>))</span><br><span class="line">print(pd.merge(left,right,on = <span class="string">"key"</span>,how = <span class="string">'right'</span>))</span><br></pre></td></tr></table></figure><ul><li>inner: only keep rows which contain keys that appear in both dataframes(intersection; 交集)</li><li>outer: keep all rows even though keys may only appear in one dataframes(union set; 并集)</li><li>left: keep every row in the left dataframe and remove rows in the right dataframe whose keys can not be found in the left dataframe(left join in SQL)</li><li>right: keep every row in the right dataframe and remove rows in the left dataframe whose keys can not be found in the right dataframe(right join in SQL)</li></ul></li><li><p>Joining: very similar to the <strong>merging</strong> method but the <strong>index column</strong> is used as the key.  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">print(left1.join(right1, how = <span class="string">"inner"</span>))</span><br><span class="line">print(left1.join(right1, how = <span class="string">"outer"</span>))</span><br><span class="line">print(left1.join(right1, how = <span class="string">"left"</span>))</span><br><span class="line">print(left1.join(right1, how = <span class="string">"right"</span>))</span><br></pre></td></tr></table></figure></li></ol><h2 id="4-Further-pandas-operations"><a href="#4-Further-pandas-operations" class="headerlink" title="4. Further pandas operations"></a>4. Further pandas operations</h2><ol><li><ul><li><p><code>df[&quot;column_name&quot;].unique()</code> return unique values in a column</p></li><li><p><code>df[&quot;column_name&quot;].nunique()</code> return the number of unique values in a column</p><p><code>len(df[&quot;column_name&quot;])</code> does the same</p></li><li><p><code>df[&quot;column_name&quot;].value_counts()</code> return how many times each unique value appears </p></li></ul></li><li><p><code>.apply()</code>:</p><ul><li><p>There are already many built in functions in pandas such as <code>.sum()</code> We can use <code>.apply()</code> to call customized functions or Python built-in functions to the dataframe(series). </p></li><li><p>Example:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">by_two</span><span class="params">(value)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> (value*<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">df = pd.DataFrame(&#123;<span class="string">'col1'</span>:[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>],<span class="string">'col2'</span>:[<span class="number">444</span>,<span class="number">555</span>,<span class="number">666</span>,<span class="number">444</span>]&#125;)</span><br><span class="line">print(df.apply(by_two))</span><br><span class="line"></span><br><span class="line">df = df[<span class="string">'col2'</span>].apply(<span class="keyword">lambda</span> x: x*<span class="number">2</span>)</span><br><span class="line">df = df.apply(str)</span><br><span class="line">print(df.apply(len))</span><br></pre></td></tr></table></figure><p>Make sure to understand the codes above.</p></li></ul></li><li><p><code>df.isnull()</code> returns a dataframe with Boolean value. <code>True</code> if the value is <code>NaN</code>, <code>False</code> otherwise.</p></li><li><p>Pivot table(数据透视表): an advanced Excel technique, not often used. See the example below.</p><ul><li><p>Creating the dataframe:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">data = &#123;<span class="string">'A'</span>:[<span class="string">'foo'</span>,<span class="string">'foo'</span>,<span class="string">'foo'</span>,<span class="string">'bar'</span>,<span class="string">'bar'</span>,<span class="string">'bar'</span>],</span><br><span class="line">     <span class="string">'B'</span>:[<span class="string">'one'</span>,<span class="string">'one'</span>,<span class="string">'two'</span>,<span class="string">'two'</span>,<span class="string">'one'</span>,<span class="string">'one'</span>],</span><br><span class="line">       <span class="string">'C'</span>:[<span class="string">'x'</span>,<span class="string">'y'</span>,<span class="string">'x'</span>,<span class="string">'y'</span>,<span class="string">'x'</span>,<span class="string">'y'</span>],</span><br><span class="line">       <span class="string">'D'</span>:[<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">1</span>]&#125;</span><br><span class="line">df = pd.DataFrame(data)</span><br></pre></td></tr></table></figure><table><thead><tr><th></th><th>A</th><th>B</th><th>C</th><th>D</th></tr></thead><tbody><tr><td>0</td><td>foo</td><td>one</td><td>x</td><td>1</td></tr><tr><td>1</td><td>foo</td><td>one</td><td>y</td><td>3</td></tr><tr><td>2</td><td>foo</td><td>two</td><td>x</td><td>2</td></tr><tr><td>3</td><td>bar</td><td>two</td><td>y</td><td>5</td></tr><tr><td>4</td><td>bar</td><td>one</td><td>x</td><td>4</td></tr><tr><td>5</td><td>bar</td><td>one</td><td>y</td><td>1</td></tr></tbody></table></li><li><p><code>df.pivot_table(values=&#39;D&#39;,index=[&#39;A&#39;, &#39;B&#39;],columns=[&#39;C&#39;])</code></p><p>It mainly takes three arguments, we can specify which column we want it to become values, index or columns names</p></li><li><p>Pivot table:</p><table><thead><tr><th></th><th>C</th><th>X</th><th>Y</th></tr></thead><tbody><tr><td>A</td><td>B</td><td></td><td></td></tr><tr><td></td><td>one</td><td>4.0</td><td>1.0</td></tr><tr><td>bar</td><td></td><td></td><td></td></tr><tr><td></td><td>two</td><td>NaN</td><td>5.0</td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td>one</td><td>1.0</td><td>3.0</td></tr><tr><td>foo</td><td></td><td></td><td></td></tr><tr><td></td><td>two</td><td>2.0</td><td>NaN</td></tr></tbody></table></li><li><p>We have a compound index which are <code>A</code> and <code>B</code></p></li><li><p>We have column names which are in <code>C</code></p></li><li><p>Values are allocated according to index and columns</p></li></ul></li></ol><h2 id="5-Data-input-amp-output"><a href="#5-Data-input-amp-output" class="headerlink" title="5. Data input &amp; output"></a>5. Data input &amp; output</h2><ol><li><p>Main data input:</p><ul><li>csv</li><li>pandas data reader</li><li>Excel</li><li>HTML</li><li>SQL</li></ul></li><li><p><strong>CSV</strong> stands for Comma Separated Values.</p></li><li><p>CSV:</p><ul><li><p><code>df=pd.read_csv(&quot;filename.csv&quot;)</code> read data from a .csv file       </p></li><li><p><code>df.to_csv(&quot;filename.csv&quot;,index = False)</code> convert a dataframe to csv</p><p>We normally put <code>index = False</code>, otherwise there will be two columns of index when we <code>.read_csv()</code> again</p></li></ul></li><li><p>Excel:</p><ul><li><p><code>df=pd.read_excel(&quot;filename.xlsx&quot;,sheetname = &quot;Name_of_the_sheet&quot;)</code></p><p>Don’t forget to specify the sheet name. If there are formulae or images in the Excel file, pandas is very likely to crash.</p></li><li><p><code>df.to_excel(&quot;new_filename.xlsx&quot;,sheet_name = &quot;New_sheet&quot;)</code></p><p>A bit wired as the attribute name is <code>sheet_name</code></p></li></ul></li><li><p>HTML:</p><ul><li><p>A number of packages need to be installed for reading data from HTML</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pip install lxml</span><br><span class="line">pip install html5lib</span><br><span class="line">pip install BeautifulSoup4</span><br></pre></td></tr></table></figure><ul><li><p>data = <code>pd.read_html(&quot;link_of_the_data&quot;)</code> read data between <code>&lt;table&gt; &lt;/table&gt;</code></p><p>This returns a Python list with tables as elements inside. Use <code>data[0]</code> to access them.</p></li><li><p>Data obtained from HTML may get messy. Some operations are needed to tidy up.</p></li><li><p><code>df.to_html(&quot;filename.html&quot;)</code> convert a dataframe to HTML.</p></li></ul></li></ul></li><li><p>SQL database: use external packages such as <strong>Pymysql</strong> to read data from SQL database.</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-Handling-missing-data&quot;&gt;&lt;a href=&quot;#1-Handling-missing-data&quot; class=&quot;headerlink&quot; title=&quot;1. Handling missing data&quot;&gt;&lt;/a&gt;1. Handling missing data&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Creating a dataframe with &lt;code&gt;NaN&lt;/code&gt;:&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; numpy &lt;span class=&quot;keyword&quot;&gt;as&lt;/span&gt; np&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; pandas &lt;span class=&quot;keyword&quot;&gt;as&lt;/span&gt; pd&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;dict1 = &amp;#123;&lt;span class=&quot;string&quot;&gt;&quot;A&quot;&lt;/span&gt;:[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;],&lt;span class=&quot;string&quot;&gt;&quot;B&quot;&lt;/span&gt;:[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;,np.nan],&lt;span class=&quot;string&quot;&gt;&quot;C&quot;&lt;/span&gt;:[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,np.nan,np.nan]&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;df = pd.DataFrame(dict1)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;print(df)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Drop missing values:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;df = df.dropna()&lt;/code&gt; drop rows with at least one &lt;code&gt;NaN&lt;/code&gt; inside&lt;/li&gt;
&lt;li&gt;&lt;code&gt;df = df.dropna(axis = 1)&lt;/code&gt; drop columns with at least one &lt;code&gt;NaN&lt;/code&gt; inside&lt;/li&gt;
&lt;li&gt;&lt;code&gt;df = df.dropna(axis = 1,thresh = 2)&lt;/code&gt; The column won’t be dropped if there are at least two non-&lt;code&gt;NaN&lt;/code&gt; values in the column.&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Programming" scheme="https://yuxuanliu.tech/categories/Programming/"/>
    
    
      <category term="Python" scheme="https://yuxuanliu.tech/tags/Python/"/>
    
      <category term="Pandas" scheme="https://yuxuanliu.tech/tags/Pandas/"/>
    
  </entry>
  
  <entry>
    <title>Pandas basics</title>
    <link href="https://yuxuanliu.tech/pandas_basics/"/>
    <id>https://yuxuanliu.tech/pandas_basics/</id>
    <published>2019-09-11T22:36:17.000Z</published>
    <updated>2019-09-16T16:42:37.653Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Pandas-Python-data-analysis-library-basics"><a href="#Pandas-Python-data-analysis-library-basics" class="headerlink" title="Pandas(Python data analysis library) basics"></a>Pandas(Python data analysis library) basics</h2><ol><li><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br></pre></td></tr></table></figure></li><li><p><code>pd.Series()</code> is similar to <code>np.array()</code> but we can assign series with a <strong>string</strong> or <strong>datetime</strong> index rather than just numerical index.</p><ul><li><p>Convert list, array and dictionary to a series:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">list1 = [<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>]</span><br><span class="line">array1 = np.array([<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>])</span><br><span class="line">dict1 = &#123;<span class="number">1</span>:<span class="number">10</span>,<span class="number">2</span>:<span class="number">20</span>,<span class="number">3</span>:<span class="number">30</span>,<span class="number">4</span>:<span class="number">40</span>&#125;</span><br><span class="line">series1 = pd.Series(list1)</span><br><span class="line">series2 = pd.Series(array1)</span><br><span class="line">series3 = pd.Series(dict1)</span><br><span class="line">print(series1)</span><br><span class="line">print(series2)</span><br><span class="line">print(series3)</span><br></pre></td></tr></table></figure><p>By default, we have ascending numerical index</p><a id="more"></a></li><li><p>Assign index to a series</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">index1 = [<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>,<span class="string">"d"</span>]</span><br><span class="line">list1 = [<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>]</span><br><span class="line">array1 = np.array([<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>])</span><br><span class="line">dict1 = &#123;<span class="string">"a"</span>:<span class="number">10</span>,<span class="string">"b"</span>:<span class="number">20</span>,<span class="string">"c"</span>:<span class="number">30</span>,<span class="string">"d"</span>:<span class="number">40</span>&#125;</span><br><span class="line">series1 = pd.Series(list1,index1)</span><br><span class="line">series2 = pd.Series(array1,index1)</span><br><span class="line">series3 = pd.Series(dict1)</span><br><span class="line">print(series1)</span><br><span class="line">print(series2)</span><br><span class="line">print(series3)</span><br></pre></td></tr></table></figure><p>We now have a string index <code>&quot;a&quot;</code>, <code>&quot;b&quot;</code>, <code>&quot;c&quot;</code> and <code>&quot;d&quot;</code></p></li><li><p>Indexing series</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">series1 = pd.Series([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>],[<span class="string">"USA"</span>,<span class="string">"CHINA"</span>,<span class="string">"UK"</span>,<span class="string">"IRELAND"</span>])</span><br><span class="line">series2 = pd.Series([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>],[<span class="string">"USA"</span>,<span class="string">"CHINA"</span>,<span class="string">"FRANCE"</span>,<span class="string">"GERMANY"</span>])</span><br><span class="line">value = series1[<span class="string">"USA"</span>]</span><br><span class="line"><span class="comment">#value = series1.USA</span></span><br><span class="line">print(value)</span><br><span class="line">series3 = series1 + series2</span><br><span class="line">print(series3)</span><br></pre></td></tr></table></figure><p>There are two ways of indexing, see above. </p><p>Also, we can do mathematical operations between two series. Pandas will only carry out operations between values with the same index. For those index without a matching index in the other series, their value will be set to <code>NaN</code>. See below</p><table><thead><tr><th>CHINA</th><th>4.0</th></tr></thead><tbody><tr><td>FRANCE</td><td>NaN</td></tr><tr><td>GERMANY</td><td>NaN</td></tr><tr><td>IRELAND</td><td>NaN</td></tr><tr><td>UK</td><td>NaN</td></tr><tr><td>USA</td><td>2.0</td></tr></tbody></table></li></ul></li><li><ul><li>The main data structure in pandas is dataframe and it is built on top of series.</li><li>We could say a dataframe is a number of series that share the same index with each other. </li><li>Each column or row in a dataframe is a series if we consider it independently.</li></ul></li><li><p>Hard code method for creating a dataframe:</p><ul><li><p>Method 1(filling each column in a dictionary):</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">dic1 = &#123;<span class="string">"date"</span>:[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>],</span><br><span class="line">        <span class="string">"value"</span>:[<span class="number">2</span>,<span class="number">35</span>,<span class="number">64</span>,<span class="number">53</span>,<span class="number">67</span>,<span class="number">64</span>,<span class="number">32</span>,<span class="number">66</span>,<span class="number">87</span>,<span class="number">12</span>],</span><br><span class="line">        <span class="string">"ratio"</span>:[<span class="number">0.2</span>,<span class="number">0.3</span>,<span class="number">0.43</span>,<span class="number">0.52</span>,<span class="number">0.41</span>,<span class="number">0.87</span>,<span class="number">0.12</span>,<span class="number">0.32</span>,<span class="number">0.15</span>,<span class="number">0.76</span>]&#125;</span><br><span class="line">df = pd.DataFrame(dic1)</span><br><span class="line">print(df)</span><br></pre></td></tr></table></figure></li><li><p>Method 2(filling each row in a list): </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">df=pd.DataFrame([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">0.2</span>],</span><br><span class="line">                 [<span class="number">2</span>,<span class="number">35</span>,<span class="number">0.3</span>],</span><br><span class="line">                 [<span class="number">3</span>,<span class="number">64</span>,<span class="number">0.43</span>],</span><br><span class="line">                 [<span class="number">4</span>,<span class="number">53</span>,<span class="number">0.52</span>],</span><br><span class="line">                 [<span class="number">5</span>,<span class="number">67</span>,<span class="number">0.41</span>],</span><br><span class="line">                 [<span class="number">6</span>,<span class="number">64</span>,<span class="number">0.87</span>],</span><br><span class="line">                 [<span class="number">7</span>,<span class="number">32</span>,<span class="number">0.12</span>],</span><br><span class="line">                 [<span class="number">8</span>,<span class="number">66</span>,<span class="number">0.32</span>],</span><br><span class="line">                 [<span class="number">9</span>,<span class="number">87</span>,<span class="number">0.15</span>],</span><br><span class="line">                 [<span class="number">10</span>,<span class="number">12</span>,<span class="number">0.76</span>]],columns=[<span class="string">'date'</span>,<span class="string">'value'</span>,<span class="string">'ratio'</span>])</span><br><span class="line">print(df)</span><br></pre></td></tr></table></figure></li><li><p>Another example:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">df = pd.DataFrame(np.random.rand(<span class="number">5</span>,<span class="number">4</span>),columns = [<span class="string">"A"</span>,<span class="string">"B"</span>,<span class="string">"C"</span>,<span class="string">"D"</span>],index = [<span class="string">"CHINA"</span>,<span class="string">"USA"</span>,<span class="string">"UK"</span>,<span class="string">"FRANCE"</span>,<span class="string">"GERMANY"</span>])</span><br><span class="line">print(df)</span><br></pre></td></tr></table></figure></li></ul></li><li><p>Adding new columns to an existing dataframe</p><ul><li><code>df[&#39;new_column&#39;]=(df.old_1+df.old_2)</code> add a new column from existing columns.</li><li><code>df[&#39;name_of_new_column&#39;] = list_of_data</code> add a new column into the dataframe directly.</li></ul></li><li><ul><li><code>df.drop(&quot;column name&quot;,axis = 1)</code> remove a column from the dataframe</li><li><code>df.drop([&quot;row_index_1&quot;,&quot;row_index_2&quot;],axis = 0)</code> remove a row from the dataframe </li></ul></li><li><p><code>df.index</code> return values in the <strong>index</strong> column of the dataframe. </p></li><li><p><code>df.columns</code>  return <strong>all column names</strong> of the dataframe.</p></li><li><p>If in the dataframe, we have missing data, we may assign <code>np.nan</code> to it which stands for <strong>not an number</strong></p></li><li><p>Slicing columns:</p><ul><li><code>df.Name_of_column</code> return all values under a column which is a <strong>series</strong>.</li><li><code>df[&#39;Name_of_column&#39;]</code> does exactly the same. You are encouraged to use this method.</li><li><code>df = df[[&#39;Name_of_column_1&#39;,&#39;Name_of_column_2&#39;]]</code> slicing multiple columns from the dataframe </li><li>The attribute method doesn’t need <code>&quot;&quot;</code> while the index method do.</li></ul></li><li><p>Slicing rows:</p><ul><li><p><code>df.head(n)</code> return first n rows in the dataframe </p></li><li><p><code>df.tail(n)</code> return last n rows in the dataframe</p></li><li><p><code>df = df[2:5]</code> slicing the data frame i.e. row 2,3,4</p></li><li><p><code>df = df.loc[&quot;index_name&quot;,[&#39;Name_of_column_1&#39;,&#39;Name_of_column_2&#39;]]</code></p><p>Extremely useful when values inside the index columns are not numerical.</p></li><li><p><code>df = df.iloc[from_row:to_row,[Index_of_column_1,Index_of_column_2]]</code></p><p>Very similar to <code>.loc[]</code> but we can treat index values as numerical based ascending index even though index values themselves may not be numerical. We must use the index numbers of columns instead of name of columns for <code>.iloc</code>.</p></li><li><p><code>.loc</code> and <code>.iloc</code> methods are based on indexing a matrix in numpy <code>a[row_index,column_index]</code></p></li></ul></li><li><p>Example for <code>.loc</code> and <code>.iloc</code>:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">df = pd.DataFrame(np.random.rand(<span class="number">5</span>,<span class="number">4</span>),columns = [<span class="string">"A"</span>,<span class="string">"B"</span>,<span class="string">"C"</span>,<span class="string">"D"</span>],index = [<span class="string">"CHINA"</span>,<span class="string">"USA"</span>,<span class="string">"UK"</span>,<span class="string">"FRANCE"</span>,<span class="string">"GERMANY"</span>])</span><br><span class="line">print(df.loc[[<span class="string">"UK"</span>,<span class="string">"FRANCE"</span>],[<span class="string">"B"</span>,<span class="string">"C"</span>]])</span><br><span class="line">print(df.iloc[<span class="number">2</span>:<span class="number">4</span>,<span class="number">1</span>:<span class="number">3</span>])</span><br></pre></td></tr></table></figure><p>These two methods both give data at column “B” and “C” from row “UK” and “FRANCE”.</p></li><li><p><code>df.loc[row_num,[“Name of the column”]] = new_value</code> modify values in the dataframe</p></li><li><p><code>df.describle()</code> will return a number of useful statistical data of the dataframe includes: count, mean, std, min, 25% percentile, 50% percentile, 75% percentile and max.</p></li><li><p><code>df = df.sort_values(Name_of_column,ascending=True)</code> sort the dataframe according to numerical values in the column specified.</p></li><li><p>Filter:</p><ul><li><p>Filter by values in a column: <code>df[df[&quot;column_name&quot;]&gt;1.0]</code> applying the <strong>conditional selection</strong> method. This means return rows in the dataframe where we have a <code>True</code>.</p></li><li><p>Example:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">df = pd.DataFrame(np.random.rand(<span class="number">5</span>,<span class="number">4</span>),columns = [<span class="string">"A"</span>,<span class="string">"B"</span>,<span class="string">"C"</span>,<span class="string">"D"</span>],index = [<span class="string">"CHINA"</span>,<span class="string">"USA"</span>,<span class="string">"UK"</span>,<span class="string">"FRANCE"</span>,<span class="string">"GERMANY"</span>])</span><br><span class="line">print(df[df&gt;<span class="number">0.5</span>])</span><br><span class="line">print(df[df[<span class="string">"A"</span>]&gt;<span class="number">0.5</span>])</span><br></pre></td></tr></table></figure><ul><li><code>df[df&gt;0.5]</code> will return a dataframe with <code>NaN</code> for values less than 0.5. This is because <code>df&gt;0.5</code> will return a dataframe.</li><li><code>df[df[&quot;A&quot;]&gt;0.5]</code> will only return rows whose values under column A are greater than 0.5. This is because <code>df[&quot;A&quot;]&gt;0.5</code> will return a pandas series rather than a dataframe.</li></ul></li><li><p>What if we want to put in multiple conditions, we CANNOT simply do <code>df[(df[&quot;A&quot;]&gt;0.5) and  (df[&quot;B&quot;]&gt;0.3)]</code> This is because normal python <code>and</code> doesn’t support pandas series. We need to use <code>&amp;</code> for <code>and</code> operator, <code>|</code> for <code>or</code> operator. See the example below:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">df = pd.DataFrame(np.random.rand(<span class="number">5</span>,<span class="number">4</span>),columns = [<span class="string">"A"</span>,<span class="string">"B"</span>,<span class="string">"C"</span>,<span class="string">"D"</span>],index = [<span class="string">"CHINA"</span>,<span class="string">"USA"</span>,<span class="string">"UK"</span>,<span class="string">"FRANCE"</span>,<span class="string">"GERMANY"</span>])</span><br><span class="line">print(df[(df[<span class="string">"A"</span>]&gt;<span class="number">0.5</span>) &amp; (df[<span class="string">"B"</span>]&gt;<span class="number">0.3</span>)])</span><br><span class="line">print(df[(df[<span class="string">"A"</span>]&gt;<span class="number">0.5</span>) | (df[<span class="string">"B"</span>]&gt;<span class="number">0.3</span>)])</span><br></pre></td></tr></table></figure></li></ul></li><li><ul><li><p><code>df.rename(columns = &quot;old name&quot;: &quot;new name&quot;, inplace = True)</code> to change a column name</p></li><li><p><code>df = df.rename(columns = &quot;old name&quot;: &quot;new name&quot;)</code> does exactly the same</p></li><li><p>Change multiple column names:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">new_name = [<span class="string">"new_date"</span>,<span class="string">"new_value"</span>,<span class="string">"new_ratio"</span>]</span><br><span class="line">df.columns = new_name</span><br></pre></td></tr></table></figure></li></ul></li><li><p>Treating the dataframe as an iterable object, see the example below:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> index,row <span class="keyword">in</span> df.iterrows():</span><br><span class="line">    print(index)</span><br><span class="line">    print(row[<span class="string">"A"</span>],row[<span class="string">"B"</span>],row[<span class="string">"C"</span>],row[<span class="string">"D"</span>])</span><br></pre></td></tr></table></figure><p>In other words, <code>.iterrows()</code> function will slice each row into pandas series.</p></li><li><ul><li><code>df = df.reset_index()</code> reset customized index back to numerical ascending index, the old index column will become a new column called <code>&quot;index&quot;</code> of the dataframe. It won’t cause confusion as we need to use <code>df.index</code> for new numerical index column and <code>df[&quot;index&quot;]</code> for old index column.</li><li><code>df = df.set_index(“name_of_the_column”)</code> will automatically remove the column we select and make it become the index column. </li><li>We may use <code>df.index = df[“name_of_the_column”]</code> but we still need to remove the <code>“name_of_the_column”</code> column using <code>df.drop(&quot;name_of_the_column&quot;,axis = 1)</code> </li></ul></li><li><p>Working with compound index: indexing from the outside to inside</p><ul><li><p>Producing a dataframe with compound index</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">outside = [<span class="string">'G1'</span>,<span class="string">'G1'</span>,<span class="string">'G1'</span>,<span class="string">'G2'</span>,<span class="string">'G2'</span>,<span class="string">'G2'</span>]</span><br><span class="line">inside = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">hier_index = list(zip(outside,inside))</span><br><span class="line">hier_index = pd.MultiIndex.from_tuples(hier_index)</span><br><span class="line">df = pd.DataFrame(np.random.randn(<span class="number">6</span>,<span class="number">2</span>),index=hier_index,columns=[<span class="string">'A'</span>,<span class="string">'B'</span>])</span><br><span class="line">print(df)</span><br></pre></td></tr></table></figure><p>This will produce the following dataframe with two columns of index.</p><table><thead><tr><th>Group</th><th>Num</th><th>A</th><th>B</th></tr></thead><tbody><tr><td></td><td>1</td><td>0.153661</td><td>0.167638</td></tr><tr><td>G1</td><td>2</td><td>-0.765930</td><td>0.962299</td></tr><tr><td></td><td>3</td><td>0.902826</td><td>-0.537909</td></tr><tr><td></td><td>1</td><td>-1.549671</td><td>0.435253</td></tr><tr><td>G2</td><td>2</td><td>1.259904</td><td>-0.447898</td></tr><tr><td></td><td>3</td><td>0.266207</td><td>0.412580</td></tr></tbody></table></li><li><p>If we want to index 0.412580 at the bottom right corner, use: <code>print(df.loc[&quot;G2&quot;].loc[3,&quot;B&quot;])</code></p></li><li><p><code>df.loc[&quot;G2&quot;]</code> returns a dataframe with 3 rows under G2. Do <code>.loc</code> again inside this dataframe.</p></li><li><p><code>df.index.names = [&#39;Group&#39;,&#39;Num&#39;]</code> assign column names to compound index</p></li><li><p>What if rows with inside index <code>Num=1</code> are needed? It is a bit tedious to use <code>.loc</code> multiple times. There is another method: <code>print(df.xs(1,level=&#39;Num&#39;))</code> The <code>level</code> attribute specifies the column inside the compound index.</p></li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Pandas-Python-data-analysis-library-basics&quot;&gt;&lt;a href=&quot;#Pandas-Python-data-analysis-library-basics&quot; class=&quot;headerlink&quot; title=&quot;Pandas(Python data analysis library) basics&quot;&gt;&lt;/a&gt;Pandas(Python data analysis library) basics&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; numpy &lt;span class=&quot;keyword&quot;&gt;as&lt;/span&gt; np&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; pandas &lt;span class=&quot;keyword&quot;&gt;as&lt;/span&gt; pd&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;pd.Series()&lt;/code&gt; is similar to &lt;code&gt;np.array()&lt;/code&gt; but we can assign series with a &lt;strong&gt;string&lt;/strong&gt; or &lt;strong&gt;datetime&lt;/strong&gt; index rather than just numerical index.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Convert list, array and dictionary to a series:&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; numpy &lt;span class=&quot;keyword&quot;&gt;as&lt;/span&gt; np&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; pandas &lt;span class=&quot;keyword&quot;&gt;as&lt;/span&gt; pd&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;list1 = [&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;20&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;30&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;40&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;array1 = np.array([&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;20&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;30&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;40&lt;/span&gt;])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;dict1 = &amp;#123;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;:&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;:&lt;span class=&quot;number&quot;&gt;20&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;:&lt;span class=&quot;number&quot;&gt;30&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;:&lt;span class=&quot;number&quot;&gt;40&lt;/span&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;series1 = pd.Series(list1)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;series2 = pd.Series(array1)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;series3 = pd.Series(dict1)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;print(series1)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;print(series2)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;print(series3)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;By default, we have ascending numerical index&lt;/p&gt;
    
    </summary>
    
    
      <category term="Programming" scheme="https://yuxuanliu.tech/categories/Programming/"/>
    
    
      <category term="Python" scheme="https://yuxuanliu.tech/tags/Python/"/>
    
      <category term="Pandas" scheme="https://yuxuanliu.tech/tags/Pandas/"/>
    
  </entry>
  
  <entry>
    <title>Numpy notes</title>
    <link href="https://yuxuanliu.tech/numpy_notes/"/>
    <id>https://yuxuanliu.tech/numpy_notes/</id>
    <published>2019-09-09T23:05:15.000Z</published>
    <updated>2019-09-18T07:08:40.538Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Numpy-Numerical-Python-notes"><a href="#Numpy-Numerical-Python-notes" class="headerlink" title="Numpy(Numerical Python) notes"></a>Numpy(Numerical Python) notes</h1><h2 id="1-Basics"><a href="#1-Basics" class="headerlink" title="1. Basics"></a>1. Basics</h2><ol><li><p><code>import numpy as np</code></p></li><li><p>The data type in Numpy is called <strong>array</strong></p></li><li><p><code>a = np.array([1,2,3])</code> to create a new array</p><p>Alternatively:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">list1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">array1 = np.array(list1)</span><br><span class="line">print(array1)</span><br></pre></td></tr></table></figure></li><li><p><code>a=np.arange(1,12,3)</code> from 1 to 11 with a step of 3   i.e. <code>[1,4,7,10]</code>  Super useful in <strong>matplotlib</strong>. </p><p>The starting value will be included for sure but the ending value may not be included(depend on step).</p><p><strong>arange</strong> stands for array range </p></li><li><p><code>a=np.linspace(1,13,5)</code> create an evenly spaced array with 5 values i.e.<code>[1,4,7,10,13]</code> Both, beginning and ending values will be included.</p><a id="more"></a></li><li><p><code>a = a.reshape(3,2)</code> change the dimension of an existing array. It means 3 rows and 2 columns here(2d array or <strong>matrix</strong>). </p><p>We may also create a 2d array(<strong>matrix</strong>) manually using <code>a = np.array([[1,2,3],[4,5,6],[7,8,9]])</code></p><p>Alternatively:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">list1 = [(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>),(<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>),(<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>)]</span><br><span class="line">array1 = np.array(list1)</span><br><span class="line">print(array1)</span><br></pre></td></tr></table></figure></li><li><p><code>print(a.shape)</code> will give us the shape of the array.</p></li><li><p><code>print(a.size)</code> will give us the length of the array kinda similar to <code>len(list1)</code></p></li><li><p><code>print(a.dtype)</code> will give us the datatype of elements inside the array.</p></li><li><p><code>a = np.zeros((3,4))</code> This creates a 3*4 matrix with zeros. Similarly, we have <code>a = np.ones((3,4))</code></p><p>Be careful, <code>a = np.ones((1,4))</code> will return a 2d matrix <code>[[1,1,1,1]]</code> .</p><p>However, <code>a = np.ones(4)</code> will return an 1d array <code>[1,1,1,1]</code>.</p></li><li><p><code>a = np.random.rand(3,4)</code> create a 3*4 matrix with random decimal values under 1. Each value has the equal possibility being picked.</p></li><li><p><code>a= np.random.randn(3,4)</code> The difference between <code>np.random.rand()</code> is that the possibility for each value being picked follows the standard normal distribution with mean at <strong>0</strong> and variance equals <strong>1</strong>.</p></li><li><p><code>a = np.random.randint(0,10,5)</code> create an array with 5 elements random integers ranging 0-10.</p></li><li><p><code>value = np.random.choice(a)</code> will help you choose a random value from the array <strong>a</strong>.</p></li><li><ul><li><code>print(a.sum())</code> will sum up all elements inside the array.</li><li><code>print(a.sum(axis=1))</code> sum up elements in each <strong>row</strong> (This axis trick also works for <code>min</code>, <code>max</code>, <code>mean</code> and <code>std</code> below)</li><li><code>print(a.sum(axis=0))</code> sum up elements in each <strong>column</strong></li></ul></li><li><p><code>print(a.min())</code> will give the minimum element.</p><p><code>print(a.max())</code> will give the maximum element.</p><p><code>print(a.argmin())</code> will give the index of the minimum element.</p><p><code>print(a.argmax())</code> will give the index of the maximum element.</p></li><li><p><code>print(a.mean())</code> will give the mean of the array.</p></li><li><p><code>print(a.std())</code> will give the standard deviation of the array.</p></li><li><p><code>print(a.ndim)</code> to find the dimension of the array.</p></li><li><p>print a sin function using both <strong>numpy</strong> and <strong>matplotlib</strong>:</p></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">x = np.arange(<span class="number">0</span>,<span class="number">3</span>*np.pi,<span class="number">0.1</span>)</span><br><span class="line">y = np.sin(x)</span><br><span class="line">plt.plot(x,y)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><h2 id="2-Advanced"><a href="#2-Advanced" class="headerlink" title="2. Advanced"></a>2. Advanced</h2><ol><li><p><code>a = a*3</code> will multiply every element in array by 3. </p><p>Other Math operations(<code>+</code>,<code>-</code>,<code>/</code>,<code>**</code>) can also be applied this way.</p></li><li><p>There is a lot of math functions in numpy. You can do <code>np.sin(a)</code>, <code>np.log(a)</code>, <code>np.exp(a)</code>, <code>np.sqrt(a)</code> etc. Check the doc for more information</p></li><li><p>Product of metrics is super easy to do in numpy. See the example below</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">a = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],</span><br><span class="line">              [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>],</span><br><span class="line">              [<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]])</span><br><span class="line">b = np.array([[<span class="number">1</span>],</span><br><span class="line">              [<span class="number">2</span>],</span><br><span class="line">              [<span class="number">3</span>]])</span><br><span class="line">print(a.dot(b))</span><br></pre></td></tr></table></figure><ul><li>Either <code>a.dot(b)</code> or <code>np.dot(a,b)</code> may be used.</li><li>It is a good practice to make sure both arrays are 2d before doing dot product</li></ul></li><li><p>Dot product and cross product between two vectors</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">a = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line">b = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line">print(np.dot(a,b))</span><br><span class="line">print(np.cross(a,b))</span><br></pre></td></tr></table></figure></li><li><p>Indexing of an array: <code>a=np.array([1,2,3,4,5,6,7,8])</code></p><ul><li>Very similar to Python list</li><li><code>print(a[3])</code> This will return 4.</li><li><code>print(a[3:5])</code> This will return 4, 5.</li></ul></li><li><p>Indexing of the matrix <code>a = np.array([(1,2,3),(4,5,6)])</code></p><ul><li>A bit different from Python, in the format <code>matrix[row,column]</code></li><li><code>print(a[0,2])</code> This will return <code>3</code>.</li><li><code>print(a[0:,2])</code> or <code>print(a[0:2,2])</code> These will return <code>[3, 6]</code>.</li></ul></li><li><p>Broadcasting: super cool, not working for standard Python list. See below:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">a=np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>])</span><br><span class="line">a[<span class="number">0</span>:<span class="number">3</span>]=<span class="number">20</span></span><br><span class="line">print(a)</span><br></pre></td></tr></table></figure><p><code>a</code> becomes <code>[20,20,20,4,5,6,7,8]</code></p></li><li><p>See the example below.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">a = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>])</span><br><span class="line">b = a</span><br><span class="line">a[<span class="number">0</span>:<span class="number">2</span>]=<span class="number">10</span></span><br><span class="line">print(a)</span><br><span class="line">print(b)</span><br></pre></td></tr></table></figure><p>You will find out both <code>a</code> and <code>b</code> are changed even though we didn’t write any code to change b. It is because <code>b=a</code> is in fact setting the pointer of <code>b</code> to the pointer of <code>a</code>(in order to save RAM). If we want to fix this issue. We need to use <code>.copy()</code>. See below.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">a = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>])</span><br><span class="line">b = a.copy()</span><br><span class="line">a[<span class="number">0</span>:<span class="number">2</span>]=<span class="number">10</span></span><br><span class="line">print(a)</span><br><span class="line">print(b)</span><br></pre></td></tr></table></figure></li><li><p>Conditional selection</p><ul><li><p><code>print(a&gt;1)</code> to test size of elements inside the array. This will automatically compare all elements inside the array with 1 and return <code>True</code> or <code>False</code> for each element. This is the basis for conditional selection.</p></li><li><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">a = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>])</span><br><span class="line">a_compare = a&gt;<span class="number">4</span></span><br><span class="line">b = a[a_compare]</span><br><span class="line">print(b)</span><br></pre></td></tr></table></figure><p>This will give us all elements which are greater than 4.</p></li><li><p>We can shorten the operation above, see below.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">a = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>])</span><br><span class="line">b = a[a&gt;<span class="number">4</span>]</span><br><span class="line">print(b)</span><br></pre></td></tr></table></figure><p>This trick is used in Pandas a lot.</p></li><li><p>Another example:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">a = np.arange(<span class="number">10</span>,<span class="number">51</span>)</span><br><span class="line">print(a[a%<span class="number">2</span>==<span class="number">0</span>])</span><br></pre></td></tr></table></figure></li></ul></li><li><p>The identical matrix $I$ is often used, we can produce one using <code>np.eye(3)</code>. 3 is the dimension of the identical matrix. In other words, it is a $3\times 3$ matrix.   </p></li><li><p>Putting two array together. We can do it in two directions vertically &amp; horizontally</p><ul><li><p>Vertically:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">a = np.array([(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>),(<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)])</span><br><span class="line">b = np.array([(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>),(<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)])</span><br><span class="line">c = np.vstack((a,b))</span><br><span class="line">print(c)</span><br></pre></td></tr></table></figure></li><li><p>Horizontally:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">  a = np.array([(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>),(<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)])</span><br><span class="line">  b = np.array([(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>),(<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)])</span><br><span class="line">  c = np.hstack((a,b))</span><br><span class="line">  print(c)</span><br></pre></td></tr></table></figure></li></ul></li></ol><ol start="11"><li><p>Change 2d array to one dimension</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">a = np.array([(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>),(<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>)])</span><br><span class="line">a = a.ravel()</span><br><span class="line">print(a)</span><br></pre></td></tr></table></figure><p>We get <code>[1,2,3,4,5,6]</code></p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Numpy-Numerical-Python-notes&quot;&gt;&lt;a href=&quot;#Numpy-Numerical-Python-notes&quot; class=&quot;headerlink&quot; title=&quot;Numpy(Numerical Python) notes&quot;&gt;&lt;/a&gt;Numpy(Numerical Python) notes&lt;/h1&gt;&lt;h2 id=&quot;1-Basics&quot;&gt;&lt;a href=&quot;#1-Basics&quot; class=&quot;headerlink&quot; title=&quot;1. Basics&quot;&gt;&lt;/a&gt;1. Basics&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;import numpy as np&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;The data type in Numpy is called &lt;strong&gt;array&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;a = np.array([1,2,3])&lt;/code&gt; to create a new array&lt;/p&gt;
&lt;p&gt;Alternatively:&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; numpy &lt;span class=&quot;keyword&quot;&gt;as&lt;/span&gt; np&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;list1 = [&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;array1 = np.array(list1)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;print(array1)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;a=np.arange(1,12,3)&lt;/code&gt; from 1 to 11 with a step of 3   i.e. &lt;code&gt;[1,4,7,10]&lt;/code&gt;  Super useful in &lt;strong&gt;matplotlib&lt;/strong&gt;. &lt;/p&gt;
&lt;p&gt;The starting value will be included for sure but the ending value may not be included(depend on step).&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;arange&lt;/strong&gt; stands for array range &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;a=np.linspace(1,13,5)&lt;/code&gt; create an evenly spaced array with 5 values i.e.&lt;code&gt;[1,4,7,10,13]&lt;/code&gt; Both, beginning and ending values will be included.&lt;/p&gt;
    
    </summary>
    
    
      <category term="Programming" scheme="https://yuxuanliu.tech/categories/Programming/"/>
    
    
      <category term="Python" scheme="https://yuxuanliu.tech/tags/Python/"/>
    
      <category term="Numpy" scheme="https://yuxuanliu.tech/tags/Numpy/"/>
    
  </entry>
  
</feed>
